#!/bin/bash
SOURCE="$0"
source /usr/lib/elive-tools/functions
REPORTS="1"
el_make_environment
. gettext.sh
TEXTDOMAIN="elive-tools"
export TEXTDOMAIN



main(){
    # pre {{{
    local file mode cmd pid

    # }}}

    # Usage
    if [[ -z "${1}" ]] ; then
        echo -e "Usage: $(basename $BASH_SOURCE) [start|stop]"
        echo -e "Runs the XDG autostart applications selected by the user"
        exit 1
    fi

    mode="$1"

    case "$mode" in
        start)
            is_start=1
            ;;
        stop)
            is_stop=1
            ;;
        *)
            el_error "unknown mode for $SOURCE"
            ;;
    esac

    if [[ -n "$EROOT" ]] ; then
        # e16
        order_file="$HOME/.e16/startup-applications.list"
        e_version="0.16"
    else
        if [[ -x "$(which enlightenment)" ]] ; then
            e_version="$( enlightenment --version | grep "^Version: " | sed -e 's|^Version: ||g' | tail -1 )"
            case "$e_version" in
                0.17.*)
                    order_file="$HOME/.e/e17/applications/startup/.order"
                    ;;
                *)
                    el_error "unknown version of Enlightenment, ignoring selection of startup applications: '$E_VERSION' "
                    exit
                    ;;
            esac
        fi
    fi

    if ! [[ -e "$order_file" ]] ; then
        el_info "This tool requires a list of startup applications, located in '$order_file' "
        el_info "This file is a plain text list containing the full address of the .desktop files to run"
        el_info "example: /etc/xdg/autostart/elive-upgrader.desktop "
        exit 1

    fi

    # run them:
    if test -s "$order_file" ; then
        while read -ru 3 line
        do
            unset executable cmd pid
            read -r line <<< "$line"

            # skip already runs:
            if el_array_member_check "$line" "${already_run[@]}" ; then
                continue
            fi

            # skip comments
            if [[ "$line" = "#"* ]] || [[ -z "$line" ]] ; then
                continue
            fi

            # parse and get info
            case "$line" in
                *.desktop|*.DESKTOP)
                    cmd="$( grep "^Exec=" "$line" | sed -e 's|^Exec=||g' | sed -e 's|%.*$||g' | tail -1 )"
                    executable="$( echo "$cmd" | awk '{print $1}' )"

                    ;;
                *)
                    cmd="$line"
                    executable="$( echo "$line" | awk '{print $1}')"
                    ;;
            esac

            # check and report to user
            if ! [[ -x "$( which "$executable" )" ]] && ! [[ -x "$executable" ]] ; then
                #el_warning "unable to run executable '$executable' with command '$cmd': $line"
                unable_executable="$executable"
                if [[ -z "$unable_executable" ]] ; then
                    unable_executable="$cmd"
                else
                    if [[ -z "$unable_executable" ]] ; then
                        unable_executable="$line"
                    fi
                fi

                local message_unable_title
                message_unable_title="$( printf "$( eval_gettext "Unable to run %s" )" "$unable_executable" )"
                local message_unable_description
                message_unable_description="$( printf "$( eval_gettext "You have an autostart application unable to be run. You must install this application or remove it from your list:" )" "" )"

                notify-send -u critical -t 14000 -i gnome-searchtool "$message_unable_title" "$message_unable_description\n\n~/.e16/startup-applications.list"

                # next!
                continue
            fi

            # start or stop them
            if [[ -n "$cmd" ]] && [[ -n "$executable" ]] ; then

                if ((is_start)) ; then
                    # close other instances, just in case
                    killall "$(basename "$executable" )"  2>/dev/null || true

                    el_debug "running: $cmd"
                    bash -c "$cmd  & disown"
                fi

                if ((is_stop)) ; then
                    el_debug "killing: $(basename "$executable" )"
                    #el_debug "ex: $executable , cmd $cmd"
                    if ! killall "$( basename "$executable" )"  2>/dev/null ; then
                        if ! killall -9 "$( basename "$executable" )"  2>/dev/null ; then
                            pid="$( ps kstart_time ux | grep -v "grep .*$cmd" | grep "$cmd" | awk '{print $2}' | tail -1 )"
                            if [[ -n "$pid" ]] ; then
                                kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null

                                if ps -p "$pid" 1>/dev/null 2>&1 ; then
                                    kill -9 "$pid" 2>/dev/null
                                fi
                            fi

                        fi
                    fi
                fi
            fi

            # append to the already run list:
            el_array_member_add "$line" "${already_run[@]}" ; already_run=("${_out[@]}")

        done 3<<< "$( cat "$order_file" )"
    fi


}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
