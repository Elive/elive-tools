#!/bin/bash

el_c_def="\033[0;39m" # Normal color  (orig: normal)
el_c_r="\033[1;31m" # Red color  (orig: red)
el_c_r2="\033[0;31m" # Red2 color  (orig: red)
el_c_g="\033[1;32m" # Green color  (orig: green)
el_c_g2="\033[0;32m" # Green2 color  (orig. green2)
el_c_y="\033[1;33m" # Yellow color  (orig. yellow)
el_c_y2="\033[0;33m" # Yellow2 color  (orig. yellow)
el_c_m="\033[1;35m" # Magenta color
el_c_m2="\033[0;35m" # Magenta2 color
el_c_c="\033[1;36m" # Cyan color
el_c_c2="\033[0;36m" # Cyan2 color
el_c_b="\033[1;34m" # Blue color
el_c_b2="\033[0;34m" # Blue2 color
el_c_gr="\033[1;30m" # Gray color
el_c_gr2="\033[0;30m" # Gray2 color

el_c_blink="\033[5m" # Blink 'color' effect  (orig. blink)
el_c_underline="\033[4m" # Underline 'color' effect  (orig. underline)
el_c_italic="\033[3m" # Italic 'color' effect
el_c_bold="\033[1m" # Bold 'color' effect



#-------------------------------------------------------------------------------
#   Set the DISPLAY variable
#-------------------------------------------------------------------------------
el_set_display_variables(){ # Set DISPLAY variables of our actual user
    if [[ -z "${DISPLAY}" ]] || [[ -z "${E_IPC_SOCKET}" ]] ; then

       if ls --color=none /tmp/enlightenment-${USER}@*/disp-* 1>/dev/null 2>/dev/null ; then
          DISPLAY="$( find /tmp/enlightenment-${USER}@*/disp-* -mindepth 0 -maxdepth 0 -type s | sort -g | tail -1 2>/dev/null )"

          E_IPC_SOCKET="${DISPLAY%|*}"
          export E_IPC_SOCKET

          DISPLAY="${DISPLAY##*disp-}"
          DISPLAY="${DISPLAY%%-*}"
          export DISPLAY

          # FIXME: if values are not obtained we should make a kind of statistics/reports
       fi
   fi

   if [[ -z "$XAUTHORITY" ]] ; then
      XAUTHORITY="$HOME/.Xauthority"
      export XAUTHORITY
   fi
}
#-------------------------------------------------------------------------------
#   Send a notification to the user
#-------------------------------------------------------------------------------
el_notify_user(){ # notify the user (desktop || email). "title" "text"
   el_set_display_variables

   notify-send -t 40000 "$@"
}
#-------------------------------------------------------------------------------
#   Send an important notification to the user
#-------------------------------------------------------------------------------
el_notify_user_important(){ # notify the user (desktop || email). "title" "text" (no timeout mode)
   el_set_display_variables

   notify-send -t 50000000 "$@"
}

#-------------------------------------------------------------------------------
#   Verify if we have internet connection (return value)
#-------------------------------------------------------------------------------
el_verify_internet(){ # verify if we have internet connection (true or false, return value)
    # pre {{{
    local stamp_hour_prev date_hour_now date_hour_prev returned

    stamp_hour_prev="/tmp/.stamps/verify_internet-${USER}-last_run_hour"
    mkdir -p "$(dirname "${stamp_hour_prev}" )"

    date_hour_now="$( date +%F-%H )"
    date_hour_prev="$( tail -1 "${stamp_hour_prev}" 2>/dev/null )"

    # remove extra leading blank chars
    read -r date_hour_prev <<< "$date_hour_prev"

    # }}}

    # exit if we have already run that before
    if [[ "${date_hour_prev}" = "$date_hour_now" ]] ; then
        echo "$date_hour_now" > "$stamp_hour_prev"
        return 0
    fi

    el_set_display_variables
    if timeout 50 curl www.google.com 2>/dev/null | grep -qi 'html' ; then
        echo "$date_hour_now" > "$stamp_hour_prev"
        return 0
    else
        sleep 60
        if timeout 50 curl www.google.com 2>/dev/null | grep -qi 'html' ; then
            echo "$date_hour_now" > "$stamp_hour_prev"
            return 0
        else
            sleep 120
            if timeout 50 curl www.google.com 2>/dev/null | grep -qi 'html' ; then
                echo "$date_hour_now" > "$stamp_hour_prev"
                return 0
            else
                echo -e "Connection to internet not found" 1>&2
                echo "$date_hour_now" > "$stamp_hour_prev"
                return 1
            fi
        fi
    fi
}


#-------------------------------------------------------------------------------
#   Speak something
#-------------------------------------------------------------------------------
el_speak_text(){
   el_check_dependencies text2wave
   local text
   text="$( echo "$text" | iconv -f utf8 -t ISO-8859-15 )"
   echo -e "$text" | text2wave -scale 5 > /tmp/.$$-festival-message.wav
   mplayer -really-quiet /tmp/.$$-festival-message.wav 2>/dev/null
   rm -f /tmp/.$$-festival-message.wav
}

#-------------------------------------------------------------------------------
#   Make ready the user's environment (bash variables, extra functions, etc)
#-------------------------------------------------------------------------------
el_make_environment(){ # make ready our environment (source variables and functions)
    if [[ -z "${USER}" ]] ; then
        if [[ -z "${HOME}" ]] ; then
            export HOME="/home"
        fi
        USER="$(basename $HOME)"
        export USER
    fi

    # in order to avoid not-possible remote display connections, we set it only when don't have it
    if [[ -z "${DISPLAY}" ]] ; then
        el_set_display_variables
    fi

    if [[ "$PATH" != *"$HOME/bin"* ]] ; then
        PATH="$HOME/bin:$PATH"
    fi

    if [[ -n "${BASH_SOURCE}" ]] ; then
        export PS4='+ ($(basename ${BASH_SOURCE}):${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}():  }'
    else
        export PS4='+ (SHELL:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}():  }'
    fi

}

#-------------------------------------------------------------------------------
#   Title Set: sets the title of a window
#-------------------------------------------------------------------------------
el_title_set(){ # set the Title on the actual Window
   el_set_display_variables
   echo -ne '\033]0;'$@'\007'
}

#-------------------------------------------------------------------------------
#   Resolutions, get the resolution values
#-------------------------------------------------------------------------------
el_resolution_get(){ # show our actual resolution
   el_check_dependencies xdpyinfo
   el_set_display_variables

   xdpyinfo | grep dimension | awk '{print $2}' | grep x | tail -1
}

#-------------------------------------------------------------------------------
#   Dependencies Check
#-------------------------------------------------------------------------------
el_check_dependencies(){ # check if we have these command dependencies, if not, notify and exit
   # example:  el_check_dependencies gmplayer,find,sed,etc
   local check found found_no dir
   while read -ru 3 check
   do
      unset found

      for dir in $(echo ${PATH}:/usr/local/sbin:/usr/sbin:/sbin | tr ':' ' ')
      do
         if test -x ${dir}/$check
         then
            found=yes
            break
         fi
      done

      if [[ "$found" != "yes" ]] ; then
         echo "Error: command '$check' not found" 1>&2
         el_notify_user "Command Not Found" "Error: command '$check' for $(basename $0) not found"
         found_no="yes"
      fi

   done 3<<< "$( echo "$@" | tr ',' '\n' )"

   if [[ "$found_no" = "yes" ]] ; then
       return 1
   else
       return 0
   fi
}


#-------------------------------------------------------------------------------
#   Check if variable exists
#-------------------------------------------------------------------------------
el_check_variables(){ # check if we have set these variables, if not, notify and exit
   # example $0 foo,bar,we
   local found_no var

   while read -ru 3 var
   do
       if [[ ! -n "${!var}" ]] ; then
           el_notify_user "E: Variable not exists" "E: the variable '$var' is not set"
           found_no="yes"
       fi
   done 3<<< "$( echo "$@" | tr ',' '\n' )"

   if [[ "$found_no" = "yes" ]] ; then
       return 1
   else
       return 0
   fi
}


#-------------------------------------------------------------------------------
#   Check if files exists
#-------------------------------------------------------------------------------
el_check_files(){ # check if we have these files (and non-zero), if not, notify and exit
   # example $0 foo,bar,we
   local var found_no
   if [[ -z "$1" ]] ; then
      echo -e "E: $FUNCNAME called without parameters (nothing to check?)"
      return 1
   fi

   while read -ru 3 var
   do
      if [[ ! -s "${var}" ]] ; then
         el_notify_user "E: File not exists" "E: the file '$var' not exists"
         found_no="yes"
      fi
   done 3<<< "$( echo "$@" | tr ',' '\n' )"

   if [[ "$found_no" = "yes" ]] ; then
       return 1
   else
       return 0
   fi
}


#-------------------------------------------------------------------------------
#   Check if dir exists
#-------------------------------------------------------------------------------
el_check_dirs(){ # check if we have these dirs (and non-zero), if not, notify and exit
   # example $0 foo,bar,we
   local var found_no
   if [[ -z "$1" ]] ; then
      echo -e "E: $FUNCNAME called without parameters (nothing to check?)"
      return 1
   fi

   while read -ru 3 var
   do
      if [[ ! -d "${var}" ]] ; then
         el_notify_user "E: Dir not exists" "E: the dir '$var' not exist"
         found_no="yes"
      fi
   done 3<<< "$( echo "$@" | tr ',' '\n' )"

   if [[ "$found_no" = "yes" ]] ; then
       return 1
   else
       return 0
   fi
}


#-------------------------------------------------------------------------------
#   check if dir has files
#-------------------------------------------------------------------------------
el_check_dir_has_files(){
   local dir
   dir="$1"
   if [[ -z "$1" ]] ; then
      echo -e "E: $FUNCNAME called without parameters (nothing to check?)"
      return 1
   fi

   if [[ ! -d "$dir" ]] ; then
      el_notify_user "Dir not exist" "$dir"
      return 1
   else
      if ! ls "${dir}/"*  2>/dev/null 1>/dev/null ; then
         el_notify_user "Dir has no files" "$dir"
         return 1
      fi
   fi
}

#-------------------------------------------------------------------------------
#   check if we have automatic sudo
#-------------------------------------------------------------------------------
el_check_sudo_automated(){
    if ! sudo -H -n echo 2>&1 ; then
         el_notify_user "Automated sudo is required" "Your sudo requires a password, we need it to be configured for not request it"
         exit 1
     else
         return 0
     fi

}


# vim: set foldmethod=marker :

