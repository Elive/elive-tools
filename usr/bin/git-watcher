#!/bin/bash
source /usr/lib/elive-tools/functions
el_make_environment

# TODO: alternative to bkp that should be faster, try git stage
# FIXME: add variable checkers everywhere neeeded

#===  FUNCTION  ================================================================
#          NAME:  exit_cleanups
#   DESCRIPTION:  delete temporal things when exit
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
exit_cleanups(){
    # pre {{{
    el_debug

    # }}}
    # do we need to recover our original position?
    travel_restore

    if ! [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
        rm -rf "$conf_repo_d"
    fi

    # tell us if we save
    if [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
        el_explain 0 "Session __saved__"
    else
        el_explain 0 "Session not saved"
    fi

    # share session always when exiting
    if ((is_shared)) ; then
        # store actual position for future calls of this tool
        if [[ "$commit_id" != "$( tail -1 "$shared_personal_d/last_commit_tracked" 2>/dev/null )" ]] ; then
            # store our commit-id
            echo "$commit_id" > "$shared_personal_d/last_commit_tracked"
            # store our progress
            echo -e "$counter $counter_total" > "$shared_personal_d/last_commit_tracked_progress"

            #echo "$counter $counter_total" > "$shared_personal_d/last_commit_tracked_progress"
            el_explain 0 "Share __saved__"
        fi

    else
        el_explain 0 "Session is not shared"
    fi
}

el_add_on_exit exit_cleanups

#===  FUNCTION  ================================================================
#          NAME:  shared_accounts_state_show
#   DESCRIPTION:  scan and show status of other accounts
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
shared_accounts_state_show(){
    # pre {{{
    el_debug

    local _user _dir _email
    # }}}

    # loop for each user found
    if ((is_shared)) ; then
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "  ${el_c_gr}${el_c_blink}Scanning paralel dimensions...${el_c_n}"

        for _dir in "$shared_d"/*
        do
            _user="$( basename "$_dir" )"
            _email="$( cat "$_dir/email.txt" )"
            _commit_id="$( cat "$_dir/last_commit_tracked" )"
            _commits_step="$( cat "$_dir/last_commit_tracked_progress" | awk '{print $1}' )"
            _commits_total="$( cat "$_dir/last_commit_tracked_progress" | awk '{print $2}' )"

            # skip our own user
            # TODO: re-enable after to finish tests
            #if [[ "${git_email}" = "$_email" ]] ; then
                #continue
            #fi

            # header nice image
            if [[ -n "$TERMINOLOGY" ]] ; then
                if [[ -s "$_dir/gravatar.png" ]] ; then
                    tycat "$_dir"/gravatar.png
                fi
            fi

            echo -e "..:: $_user ::.."
            #echo -e ""
            echo -e "email:   $_email"
            echo -e "step:    ${el_c_n}[${el_c_g}${_commits_step}${el_c_n}/${el_c_y}${_commits_total}${el_c_n}]${el_c_n}  (${_commit_id:0:12})"


            # only if we are not ourselves
            if [[ "${git_email}" != "$_email" ]] ; then
                # anything to work later?
                if [[ "$_commits_total" -gt "$_commits_total_biggest" ]] ; then
                    _commits_total_biggest="$_commits_total"
                    _commits_total_biggest_user="$_user"
                fi

                if [[ "$_commits_step" -gt "$_commits_step_biggest" ]] ; then
                    _commits_step_biggest="$_commits_step"
                    _commits_step_biggest_user="$_user"
                    _commit_id_biggest="$_commit_id"
                fi

                # show available time-traveling capsules
                if el_check_dir_has_files "${_dir}/ttc/to_${git_username}/review" 2>/dev/null ; then
                    _ttc_counter="$( ls -1 "${_dir}/ttc/to_${git_username}/review" | wc -l )"
                    el_explain 0 "__${_user}__ has __${_ttc_counter}__ XXTime-Traveling CapsulesXX for you!"
                fi

                if el_check_dir_has_files "${_dir}/ttc/to_${git_username}/questions" 2>/dev/null ; then
                    _ttc_counter="$( ls -1 "${_dir}/ttc/to_${git_username}/review" | wc -l )"
                    el_explain 0 "__${_user}__ has __${_ttc_counter}__ XXQuestionsXX in Capsules for you!"
                fi

            fi

            # done
            echo -e ""
        done
    fi

    # compare and update if needed
    if [[ "$_commits_total_biggest" -gt "$counter_total" ]] ; then
        el_explain 0 "Seems like __${_commits_total_biggest_user}__ is using an updated repo than yours"
        if el_confirm "Update your git repo now? (git pull --rebase)" ; then

            # which remote to fetch from?
            if [[ -z "$remote_fetching_working" ]] ; then
                if [[ "$( command git remote -v | grep "(fetch)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
                    echo -e "\nWhich remote you want to fetch $branch_working from ?\n"
                    command git remote -v | grep "(fetch)" | awk '{print $1}'

                    read -e remote_fetching_working
                else
                    remote_fetching_working="$(command git remote -v | grep "(fetch)" | awk '{print $1}' | head -1 )"
                fi

                echo "$remote_fetching_working" > "$conf_remote_fetch_working_from_f"
            fi

            # pull remote
            command git pull --rebase "$remote_fetching_working" "$branch_working"

            # update total of commits
            do_count_commits

            _is_shared_scanned=1
        fi
    fi

    # walk steps?
    if [[ "$_commits_step_biggest" -gt "$counter" ]] ; then
        el_explain 0 "Seems like __${_commits_step_biggest_user}__ is ahead of you in steps"

        # FIXME: make sure that we are not our own same user (same in other parts?)
        if el_confirm "Join its commit-id position?" ; then
            commit_id="$_commit_id_biggest"

            # update total of commits
            do_count_commits

            _is_shared_scanned=1
        fi
    fi


    if ((_is_shared_scanned)) ; then
        el_explain 0 "Finished to scan paralel worlds, press Enter to continue..."
        read nothing
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  shared_messages_create
#   DESCRIPTION:  elaborate messages to send to other users
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
shared_messages_create(){
    # pre {{{
    el_debug
    local _message_option _mark_message _entity

    # }}}

    # Select a user where to send message:
    el_explain 0 "Other carbon-based life forms:"
    echo -en "${el_c_g}"

    if [[ "$( ls -1 "${shared_d}" | grep -v "$git_username" | wc -l )" -gt 1 ]] ; then
        ls -1 "${shared_d}" | grep -v "$git_username"
        echo -en "${el_c_n}"

        echo -e "\nType an entity:"
        read _entity
    else
        _entity="$( ls -1 "${shared_d}" | grep -v "$git_username" | tail -1 )"
        el_explain 0 "Messaging to the XX${_entity}XX carbon-based life form"
    fi

    if ! [[ -d "${shared_d}/$_entity" ]] ; then
        el_error "Carbon-based life form doesn't exist, are you in the correct planet?"
        echo -e "\nType an entity:"
        read _entity

        if ! [[ -d "${shared_d}/$_entity" ]] ; then
            return
        fi
    fi


    # message type?
    option_show "a" "Ask a question to ${_entity} (no importing required)"
    option_show "i" "Importing request to backport this commit"
    ###option_show "r" "Reply a question"
    option_show "q" "quit this menu"

    read -N 1 _message_option
    case "$_message_option" in
        a)
            _message_option="questions"
            ;;
        i)
            _message_option="review"
            ;;
        q|*)
            return
            ;;
    esac

    # message?
    echo -e "\nMessage to include?  (blank = no message)"
    read -e _mark_message

    # create mark
    mkdir -p "${shared_personal_d}/ttc/to_$_entity/$_message_option/${commit_id}"

    if [[ -n "$_mark_message" ]] ; then
        echo "$_mark_message" >> "${shared_personal_d}/ttc/to_$_entity/$_message_option/${commit_id}/message.txt"
    fi


}

#===  FUNCTION  ================================================================
#          NAME:  scan_travels
#   DESCRIPTION:  Scans available travels and allow to pick them
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
scan_travels(){
    # pre {{{
    el_debug
    if ! ((is_shared)) ; then
        el_explain 0 "Skipping reading capsules, this watcher is not shared"
        return
    fi


    local _user _dir _email
    # }}}

    # loop for each user found
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    echo -e "  ${el_c_gr}${el_c_blink}Scanning Time-Traveling Capsules...${el_c_n}"

    for _dir in "$shared_d"/*
    do
        _user="$( basename "$_dir" )"
        _email="$( cat "$_dir/email.txt" )"
        _commit_id="$( cat "$_dir/last_commit_tracked" )"
        _commits_step="$( cat "$_dir/last_commit_tracked_progress" | awk '{print $1}' )"
        _commits_total="$( cat "$_dir/last_commit_tracked_progress" | awk '{print $2}' )"

        # skip our own user
        if [[ "${git_email}" = "$_email" ]] ; then
            continue
        fi

        # show available time-traveling capsules
        if el_check_dir_has_files "${_dir}/ttc/to_${git_username}/review" 2>/dev/null ; then
            _ttc_review=1
        fi

        if el_check_dir_has_files "${_dir}/ttc/to_${git_username}/questions" 2>/dev/null ; then
            _ttc_question=1
        fi


        # show info of only needed ones
        if ((_ttc_review)) || ((_ttc_question)) ; then
            # header nice image
            if [[ -n "$TERMINOLOGY" ]] ; then
                if [[ -s "$_dir/gravatar.png" ]] ; then
                    tycat "$_dir"/gravatar.png
                fi
            fi

            echo -e "..:: $_user ::.."
            #echo -e ""
            echo -e "email:   $_email"
            echo -e "step:    ${el_c_n}[${el_c_g}${_commits_step}${el_c_n}/${el_c_y}${_commits_total}${el_c_n}]${el_c_n}  (${_commit_id:0:12})"
        fi

        if ((_ttc_review)) ; then
            _ttc_counter="$( ls -1 "${_dir}/ttc/to_${git_username}/review" | wc -l )"
            el_explain 0 "XX${_user}XX wants you to consider backporting XX${_ttc_counter}XX __commits__:"
            echo ""

            while read -ru 3 dir
            do
                [[ -n "$dir" ]] || continue

                _has_capsules=1

                echo -e "${el_c_b}ID:       ${el_c_g}$(basename "$dir" )${el_c_n}"

                if [[ -s "$dir/message.txt" ]] ; then

                    echo -en "${el_c_b}Message:  ${el_c_m2}"
                    cat "$dir/message.txt" 2>/dev/null
                    echo -e "${el_c_n}"
                fi

            done 3<<< "$( find "${_dir}/ttc/to_${git_username}/review" -mindepth 1 -maxdepth 1 -type d )"
        fi

        if ((_ttc_question)) ; then
            _ttc_counter="$( ls -1 "${_dir}/ttc/to_${git_username}/review" | wc -l )"
            el_explain 0 "XX${_user}XX wants you to ask you XX${_ttc_counter}XX things about specific commits:"
            echo ""

            while read -ru 3 dir
            do
                [[ -n "$dir" ]] || continue

                _has_capsules=1

                echo -e "${el_c_b}ID:       ${el_c_g}$(basename "$dir" )${el_c_n}"

                if [[ -s "$dir/message.txt" ]] ; then

                    echo -en "${el_c_b}Message:  ${el_c_m2}"
                    cat "$dir/message.txt" 2>/dev/null
                    echo -e "${el_c_n}"
                fi

            done 3<<< "$( find "${_dir}/ttc/to_${git_username}/questions" -mindepth 1 -maxdepth 1 -type d )"
        fi


        # done
        echo -e ""
    done

    # finished
    if ((_has_capsules)) ; then
        #el_explain 0 "You can travel to their __ID__ on the __Go__ option"
        #el_explain 0 "If you need external help you can go to it and send a message to somebody"
        #echo -e "Press Enter to continue..."
        #read nothing
        go_to_commit
    fi

    }

    #===  FUNCTION  ================================================================
    #          NAME:  scan_marked_states
    #   DESCRIPTION:  Scans and show marked states like todo's
    #    PARAMETERS:  -
    #       RETURNS:  -
    #===============================================================================
    scan_marked_states(){
        # pre {{{
        el_debug

        # }}}
        if ! el_check_dir_has_files "${conf_repo_d}/ttc" 2>/dev/null ; then
        return
    fi

    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    el_explain 0 "You have got XXTime-Traveling CapsulesXX!"


    while read -ru 3 dir
    do
        [[ -d "$dir" ]] || continue

        echo -e "${el_c_b}ID:       ${el_c_g}$(basename "$dir" )${el_c_n}"

        if [[ -s "$dir/message.txt" ]] ; then

            echo -en "${el_c_b}Message:  ${el_c_m2}"
            cat "$dir/message.txt" 2>/dev/null
            echo -e "${el_c_n}"
        fi

    done 3<<< "$( find "${conf_repo_d}/ttc/" -mindepth 1 -maxdepth 1 -type d )"

    el_explain 0 "You can travel to their __ID__ on the __Go__ option"
    el_explain 0 "If you need external help you can go to it and send a message to somebody"

    #echo -e "Press Enter to continue..."
    LC_ALL=C sleep 0.8
    #read nothing

}

#===  FUNCTION  ================================================================
#          NAME:  conf_share_setup
#   DESCRIPTION:  configure shares if not configured yet
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
conf_share_setup(){
    # pre {{{
    local arg
    el_debug

    # }}}
    # TODO: implementation:
    # - run an inotify in BG that prints el_explain's everytime founds a modification of X files, + read nada
    # - send email summarized to collaborators when we finish & save a session
    # - mark "points" to ask collaborators to review them, a message must be included, and options should be shown as resolved/unnaccepted, etc... which reverse notification
    # -
    #
    # TODO: show marks / messages, reviews, etc...
    # TODO: marks:
    #       - later / todo
    #       - review (accept / approve)
    #       - ask/suggest a cherry-pick
    #       - message to @who
    #       - positions (marks of commits should move you [temporally] to the marked position)


    # TODO: INBOX: show by default message to "you"



    # setup new shared conf
    if ! [[ -L "$conf_repo_d/shared" ]] ; then
        if el_confirm "Enable sharing features?" ; then
            # let's cowork!
            run_dropbox

            # dropbox shared dir
            local _dropbox_dir
            if [[ -z "$shared_main_d" ]] ; then
                _dropbox_dir="$( find-approximate-matching-homedir dropbox )"
                if [[ -n "$_dropbox_dir" ]] ; then
                    _dropbox_dir="$_dropbox_dir/git-watcher-eworks"
                else
                    _dropbox_dir="$HOME/Dropbox/git-watcher-eworks"
                fi
            else
                _dropbox_dir="$shared_main_d"
            fi

            echo -e "\nTo be synced with others we use Dropbox, please insert the full path of the main shared directory\nfor example: $_dropbox_dir (TAB to autocomplete)"
            read -e shared_main_d
            # remove extra leading blank chars
            read -r shared_main_d <<< "${shared_main_d%/}"


            # check it
            if [[ -d "$shared_main_d" ]] ; then
                mkdir -p "$shared_main_d"
                # add a small readme file
                echo -e "This directory is used for share git-watcher projects, do not delete it, EVER! :) so it is used automagically by git-watcher tool, you don't need to do anything with it, but you can manually modify things if you know what are you doing!, there's no manual pages so use your intuition powers!" > "$shared_main_d/README.txt"

                # save this conf as default
                echo "$shared_main_d" > "$conf_d/shared_main_default_dir.txt"
            fi

            # remote working place, needed for use as an identifier in the shares
            if [[ -z "$remote_working" ]] ; then
                if [[ "$( command git remote -v | grep "(push)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
                    echo -e "\nWhich one is the remote repo where you normally push your work that is shared with your collaborators?\n"
                    command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | column -t | awk '{$1 = "(id: "$1") "; print $0}'

                    echo -e "\nInsert remote repo URL (not name)"
                    read -e remote_working

                    # small check, just in case
                    if ! echo "$remote_working" | grep -qsE "(@|:|/)" ; then
                        el_error "Have you inserted the identifier instead of the remote URL? mmh... please do it again:"
                        read -e remote_working
                    fi
                else
                    remote_working="$( command git remote -v | grep "(push)" | awk '{print $2}' | head -1 )"
                fi

                echo "$remote_working" > "$conf_remote_work_from_f"
            fi

            # send invitations (+ instructions) via email
            echo -e "\nGive me a list of emails (comma-separated) to send invitations to this watcher with the needed instructions (can be empty):"
            read _emails_invitations
            _emails_invitations="$( echo "$_emails_invitations" | tr ',' ' ' | tr ';' ' ' | tr ' ' '\n' )"
            while read -ru 3 _email
            do
                [[ -z "$_email" ]] && continue

                el_explain 0 "Sending email to __${_email}__"

                email-sender -t "$_email" -s "$git_username wants to share a $(basename $0) with you" -S "These are the needed instructions to join the watcher:" <<EOF
This could be one of the most amazing tools that you may have never see!

First: check your email and accept the Dropbox invitation for the shared directory and then run dropbox to have a copy of this directory already updated in your computer.

After that, go to the git repository that references to '${remote_working}', and run from it:

<ul>$ <strong>$(basename $0) $tool_argumentsz</strong></ul>

Now simply exit from it and use these options:
<li>Save the session</li>
<li>Enable Share features</li>
<li>Fill up the correct sharing information</li>

After to have exit from $(basename $0), run the same command again to start using it in shared mode!

EOF

            done 3<<< "$( echo "$_emails_invitations" | grep "@" )"


            # create location for this repository identifier
            if ! [[ -d "$shared_main_d/$remote_working/$repo_id" ]] ; then
                mkdir -p "$shared_main_d/$remote_working/$repo_id"
                el_explain 2 "created watcher reference in __$shared_main_d/$remote_working/${repo_id}__"

                # invite friends! (on this step because we are the first ones to use this share, dir not existed before)
                if el_confirm "You need to invite collaborators from Dropbox too to use this directory, open Dropbox Web now?" ; then
                    { /etc/alternatives/x-www-browser "https://www.dropbox.com/home" & disown ; } 1>/dev/null 2>&1
                fi
            fi

            ln -s "$shared_main_d/$remote_working/$repo_id" "$conf_repo_d/shared"
            el_explain 2 "linked shared location on __$conf_repo_d/shared__"


            shared_d="$conf_repo_d/shared"
            shared_personal_d="$shared_d/$git_username"
            mkdir -p "$shared_personal_d"

            echo "$git_email" > "$shared_personal_d/email.txt" # and this is how we expect to be contacted
            el_explain 2 "added your email reference in __$shared_personal_d/email.txt"

            # save gravatar too, w00t!
            curl -s "http://www.gravatar.com/avatar/"$( echo -n "$git_email" | awk '{print tolower($0)}' | tr -d '\n ' | md5sum --text | tr -d '\- ' )"?s=48&d=404" > "$shared_personal_d/gravatar.png"
            if ! file "$shared_personal_d/gravatar.png" | grep -qsi "image" ; then
                rm -f "$shared_personal_d/gravatar.png"
            fi



            # sync our changes
            run_dropbox

            # done
            el_explain 0 "You are now ready to work with others on this shared watcher! __enjoy__"
            el_explain 0 "The next time that you will work on this watcher, your collaborators will be __notified__ and you __can walk__ on their steps"

            # save shared confs at exit
            is_shared=1

        fi
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  run_dropbox
#   DESCRIPTION:  run the dropbox daemon
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
run_dropbox(){
    # pre {{{
    el_debug

    el_dependencies_check "dropbox"

    # }}}
    if ! ps ux | grep -v grep | grep -qs "$HOME/\.dropbox-dist/" ; then
        dropbox start -i
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  go_to_commit
#   DESCRIPTION:  go to a commit position, and returns back on the normal history when finished
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
go_to_commit(){
    # pre {{{
    el_debug
    # }}}

    # save our real position
    _commit_id="$commit_id"

    is_traveling=1

    echo -e "Insert the commit-ID to go on"
    read -e commit_id

    # check if space-time position exists
    if ! command git rev-parse "$commit_id" 1>/dev/null 2>&1 ; then
        el_error "This ID don't exist?"

        echo -e "Insert the commit-ID to go on"
        read -e commit_id

        if ! command git rev-parse "$commit_id" 1>/dev/null 2>&1 ; then

            el_error "Commit-id not found. Perhaps you need to update your repo first?"
            LC_ALL=C sleep 0.4

            el_explain 0 "restoring original ID..."
            # something went wrong so make sure the user read this rare-case moment
            sleep 2
            commit_id="$_commit_id"
            unset is_traveling

            return
        fi
    fi

    tycat "${conf_d}/images/ttc.gif"

    # mark our new position
    echo "$commit_id" > "$conf_commit_last_f"

    # count our new position
    do_count_commits

    # and so, what you want to do now?
    options_main_interact

    # restore our original position
    travel_restore

}

#===  FUNCTION  ================================================================
#          NAME:  travel_restore
#   DESCRIPTION:  restores a possible traveled position
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
travel_restore(){
    # pre {{{
    el_debug

    # we should not be here
    if ! ((is_traveling)) ; then
        return
    fi

    if ! [[ -n "$_commit_id" ]] ; then
        el_error "You have not a location of origin in your passport for traveling? (prev commit-id)"
    fi

    # }}}

    tycat "${conf_d}/images/ttc.gif"
    el_explain 0 "Restoring time-traveling position!"

    # marks: delete
    if [[ -d "${conf_repo_d}/ttc/${commit_id}" ]] ; then

        if el_confirm "Delete marked state?" ; then
            if el_check_variables "conf_repo_d,commit_id" ; then

                rm -rf "${conf_repo_d}/ttc/${commit_id}"
                el_debug "deleted mark: '${conf_repo_d}/ttc/${commit_id}'"
            else
                el_error "Very fatal error, report it, we were going to rm -rf something wrong but this super smart application avoided it!"
            fi
        fi
    fi

    # requests / questions by others:
    for dir in "${shared_d}/"*"/ttc/to_${git_username}/review"/*
    do
        [[ -n "$dir" ]] || continue

        _tts_id="$( basename "$dir" )"
        if [[ "$commit_id" = "$_tts_id" ]] ; then
            if el_confirm "Delete capsule?" ; then
                echo rm -rf "$dir"
            fi
        fi
    done
    # FIXME: what about questions?


    # we are back! let's restore
    commit_id="$_commit_id"

    # count our new position
    do_count_commits

    # mark our back position
    echo "$commit_id" > "$conf_commit_last_f"

    unset is_traveling
}
#===  FUNCTION  ================================================================
#          NAME:  show_history
#   DESCRIPTION:  show last history if any
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
show_history(){
    # pre {{{
    el_debug
    local lines

    # }}}
    el_explain 0 "Showing history:"

    lines="$( LC_ALL=C command git status | grep "ahead.*by.*commits" | sed -e 's|^.* by ||g' -e 's| commits.*$||g' )"
    if [[ -n "$lines" ]] ; then
        lines="$(( $lines +1 ))"
        el_explain 0 "Your __not pushed__ changes:"


        command git log --graph --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(bold white)%an%C(reset) %C(white)— %s%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative -$lines
    else
        el_explain 0 "Recent history in your working branch:"
        command git log --graph --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(bold white)%an%C(reset) %C(white)— %s%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative -12

    fi
}

#===  FUNCTION  ================================================================
#          NAME:  show_states
#   DESCRIPTION:  shows our actual snapshoted states list available
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
show_states(){
    # pre {{{
    local _branch_working _keyword_search _files_search is_header_show _progress _commits_total _commits_remaining _commits_done

    el_check_variables "conf_d"
    el_check_dirs "$conf_d"
    # - pre }}}

    while read -ru 3 line
    do
        if [[ -d "$conf_d/$line" ]] ; then
            if ! ((is_header_show)) ; then
                #echo -e "Watchers:"
                #echo '---------'

                echo -e "${el_c_b}Watchers Tracking:${el_c_n}"
                echo -e "on Branch: | only Keyword: | on Files: | Remaining:"
                echo -e "|"

                is_header_show=1
            fi

            _branch_working="$( echo "$line" | awk -F "::" '{print $1}')"
            _keyword_search="$( echo "$line" | awk -F "::" '{print $2}')"
            _files_search="$(   echo "$line" | awk -F "::" '{print $3}' | sed -e 's|#|/|g' )"

            #_commits_total="$( echo "$( cat "$conf_d/$line/last_commit_tracked_progress" 2>/dev/null | awk '{print $2}' )" )"
            _commits_remaining="$( echo "$( cat "$conf_d/$line/last_commit_tracked_progress" 2>/dev/null | awk '{print $1}' )" )"
            #_commits_done="$( echo "$_commits_total - $_commits_remaining" | bc -l 2>/dev/null )"

            #if [[ -n "$_commits_done" ]] ; then
                #_progress="$( echo "${_commits_done}/${_commits_remaining}" )"
            #fi


            if [[ "$_branch_working" = "$branch_working" ]] \
                && [[ "$_keyword_search" = "$keyword_search" ]] \
                && [[ "$_files_search" = "$files_search" ]] ; then
                echo -e "${el_c_g}$_branch_working | $_keyword_search | $_files_search | $_commits_remaining  ${el_c_y}${el_c_n}"
            else

                if [[ -n "$_branch_working" ]] ; then

                    echo -e "$_branch_working | $_keyword_search | $_files_search | $_commits_remaining "

                fi
            fi


            unset _branch_working _keyword_search _files_search _commits_remaining _commits_total _progress
        fi
    done 3<<< "$( ls -1 "$conf_d" )"  | column -s $'|' -t
    # append space
    echo '' 1>&2

    # end
    echo '' 1>&2
}

#===  FUNCTION  ================================================================
#          NAME:  show_commit_stat
#   DESCRIPTION:  show the actual commit stat, good to "remember" where you are
#    PARAMETERS:  $1 = pre-git options
#       RETURNS:  -
#===============================================================================
show_commit_stat(){
    # pre {{{
    el_debug
    local pre_git_options

    el_check_variables "commit_id"
    pre_git_options="$1"

    # }}}
    # show actual position
    #echo -e "${el_c_y} [$counter/$counter_total] ${el_c_g} Position in remaining commits  ${el_c_n}"
    echo -e "${el_c_y}[$counter/$counter_total] ${el_c_n}"

    # show actual commit-id
    if [[ -n "$keyword_search" ]] ; then
        # hilight the keyword to search
        command git $pre_git_options show --stat "$commit_id" | grep --color -Ei "^|$keyword_search|"
    else
        command git $pre_git_options show --stat "$commit_id"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  clear_screen
#   DESCRIPTION:  clears the screen
#    PARAMETERS:  $1 = default | interactive
#       RETURNS:  -
#===============================================================================
clear_screen(){
    # pre {{{
    local mode
    el_debug

    mode="$1"
    el_check_variables "mode"

    # }}}
    case "$mode" in
        default)
            true
            ;;
        interactive)
            echo -e "\nPress Enter to continue..." 1>&2
            read nothing
            ;;
    esac

    # clear is not enough, if you scroll back you can see old things, reset is too slow, so let's put some huge separator instead
    echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

    clear
}

#===  FUNCTION  ================================================================
#          NAME:  do_count_commits
#   DESCRIPTION:  counter of total commits to track
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
do_count_commits(){
    # pre {{{
    el_debug

    local _counter _counter_total is_commit_id_last_reached

    el_check_variables "branch_working,branch_watch"

    _counter_total="$counter_total"
    _counter="$counter"

    counter_total=0
    counter=1

    # }}}
    # pre-statistics a bit: show the amount of commits between branches
    while read -ru 3 line
    do
        # get commit line
        if [[ "$line" = "commit "* ]] ; then

            counter_total="$(( $counter_total + 1 ))"

            # skip until last commit
            if [[ -n "$commit_id" ]] && ! ((is_commit_id_last_reached)) ; then
                if [[ "$line" = "commit "$commit_id ]] ; then
                    is_commit_id_last_reached=1
                else
                    # loop until we reach the desired commit
                    counter="$(( $counter + 1 ))"
                fi
            fi

            #echo -en "\r${el_c_b}Calculating total commits and our position: \t${el_c_y}[$counter/$counter_total]   ${el_c_n}"
            echo -en "\r${el_c_b}Computing space time coordinates: \t${el_c_y}[$counter/$counter_total]   ${el_c_n}"
        fi

    done 3<<< "$( command git log $options_extra_git_before --reverse "$branch_working".."$branch_watch" $options_extra_git_after )"
    echo ""


    # do we have found new commits?
    if [[ -n "$_counter_total" ]] ; then
        if ! [[ "$(( $counter_total - $_counter_total ))" = 0 ]] ; then
            el_explain 0 "Nice! XX$(( $counter_total - $_counter_total ))XX New commits found on this watcher!"
            echo "Press Enter to continue"
            read nothing
        fi
    fi

    #el_explain 3 "Recounted commits: counter is $counter, total commits is $counter_total"
}

#===  FUNCTION  ================================================================
#          NAME:  do_cherry_pick_menu
#   DESCRIPTION:  menu of options in cherry-pick state, useful when it fails
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
do_cherry_pick_menu(){
    # pre {{{
    el_debug

    # }}}

    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    option_show "s" "Show status"
    option_show "a" "Abort cherry-pick"
    option_show "c" "Continue operation (cherry-pick) in progress"
    option_show "m" "mergetool (auto / smart mode)"
    option_show "M" "mergetool (manual / human mode)"
    option_show "h" "mergetool config"
    option_show "l" "Login Shell (to do things manually)"
    option_show "r" "return to main menu"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

    read -N 1 option
    echo

    case "$option" in
        s)
            command git status

            $FUNCNAME
            ;;
        a)
            command git cherry-pick --abort

            el_explain 0 "Aborted cherry-pick..."
            LC_ALL=C sleep 1.2

            ;;
        c)
            command git cherry-pick --continue
            $FUNCNAME
            ;;
        m)
            if grep -qs "mergetool.*meld-auto" "$HOME/.gitconfig" ; then
                command git mergetool -t meld-auto
                # mergetool can success or not, so ask again what to do
            else
                el_error "meld-auto conf for mergetool not found in your config, use the option 'h' first"
            fi
            $FUNCNAME
            ;;

        M)
            if grep -qs "mergetool.*meld-manual" "$HOME/.gitconfig" ; then
                command git mergetool -t meld-manual
                # mergetool can success or not, so ask again what to do
            else
                el_error "meld-auto conf for mergetool not found in your config, use the option 'h' first"
            fi
            # mergetool can success or not, so ask again what to do
            $FUNCNAME
            ;;

        h)
            el_explain 0 "Unfortunately there's no way to run specific git mergetools without touch the confs, so first, add these lines to your .gitconfig:"
            cat <<'EOF'
[merge]
# by default let's use meld-auto, if you need manual use "git mergetool -t meld-manual"
tool = meld-auto
conflictstyle = diff3
[mergetool "meld-auto"]
# cmd reference to the meld version 1.6 syntax1
cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $BASE $REMOTE $MERGED
;# howto use the meld on this way: http://blog.wuwon.id.au/2010/09/painless-merge-conflict-resolution-in.html
;# so you have in the first tab the differences between the base and the local work, in the second the base with the remote work, and in the last tab you have in the middle the state where you need to resolve and save the conflicts
;# TIP: in meld run ^F for search the (??) expression, which is the conflict marks, and ^G for search the next one
[mergetool "meld-manual"]
cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $MERGED $REMOTE

[mergetool "meld17"]
# use this for Meld >=1.7
# see http://stackoverflow.com/a/22911793/859591
# second solution:
cmd = meld $LOCAL $MERGED $REMOTE
# first solution:
#cmd = meld $LOCAL $BASE $REMOTE --auto-merge
# see entries for 1.7 in the old commented code
[mergetool "meld16"]
# this one not works very good, at least on wheezy's version of meld
;cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $BASE $REMOTE --output $MERGED
# old/previous
cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $BASE $REMOTE $MERGED
;cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $MERGED $REMOTE
# another attempt?
#cmd = meld $LOCAL $BASE $REMOTE -o $MERGED --diff $BASE $LOCAL --diff $BASE $REMOTE
EOF


            ;;
        l)
            el_explain 0 "Starting a login shell, use ^d or logout when you finish to return back here"

            $SHELL -l

            $FUNCNAME
            ;;
        r)
            true
            ;;
    esac


}
#===  FUNCTION  ================================================================
#          NAME:  do_cherry_pick
#   DESCRIPTION:    run a cherry-pick to the commit_id variable, run helpers if something fails
#===============================================================================
do_cherry_pick(){
    # pre {{{
    el_debug

    # }}}

    el_explain 0 "git cherry-pick -Xpatience -x -s '$commit_id'"
    if command git cherry-pick -Xpatience -x -s "$commit_id" ; then
        el_explain 0 "XXSuccessfullyXX applied!"
        el_explain 0 "If you need to __add related__ commits in more cherry-picks, use the list-nearest feature and give the commits in a list to the multiple-cherry-pick feature"
        echo -e "Press Enter to continue"
        read nothing
        # TODO: if cherry-pick success, show a list of the next 20 commits and ask if we want to include more of them (copypaste id),
        # note: we always need to start from the earliest one, just make sure that it is the case

        # store actual position for future calls of this tool
        echo "$commit_id" > "$conf_commit_last_f"
    else
        el_error "Oops, cherry-pick failed! select an option now:"

        do_cherry_pick_menu
    fi

    show_history

}

#===  FUNCTION  ================================================================
#          NAME:  do_cherry_pick_multiple
#   DESCRIPTION:  do cherry-picking of multiple commits
#    PARAMETERS:  $1 = comma-separated list of commit-ids to cherry-pick
#       RETURNS:  -
#===============================================================================
do_cherry_pick_multiple(){
    # pre {{{
    local commits
    el_debug

    commits="$1"
    commits="${commits//,/ }"
    el_check_variables "commits"

    # }}}

    if [[ -n "$commits" ]] ; then
        el_explain 0 "command git cherry-pick -x -s $commits"

        if command git cherry-pick -x -s $commits  ; then
            el_explain 0 "Successfully applied!  Hit return to continue"
            read nothing
        else
            el_error "Oops, cherry-pick failed! select an option now:"

            do_cherry_pick_menu
        fi

        show_history
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  option_show
#   DESCRIPTION:  show an option to pick in a nice-colored way
#    PARAMETERS:  $1 = char, $2 = description
#       RETURNS:  -
#===============================================================================
option_show(){
    # pre {{{
    local char
    local description

    char="$1"
    description="$2"
    el_check_variables "char,description"

    # }}}

    echo -e "${el_c_c} ${char}  ${el_c_g}${description}${el_c_n}"

}

#===  FUNCTION  ================================================================
#          NAME:  options_main_interact
#   DESCRIPTION:
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
options_main_interact(){
    # pre {{{
    el_debug

    # }}}

    echo -e ""
    #echo -e "${el_c_y} [$counter/$counter_total] ${el_c_g} Position in remaining commits  ${el_c_n}"
    echo -e "${el_c_b}-----------------------------------------------------${el_c_y}[$counter/$counter_total]${el_c_b}-----${el_c_n}"
    echo -e "${el_c_y}   OPTIONS: ${el_c_n}"
    #option_show "h"         "Help: how this tool works" # TODO add
    option_show "r"         "Read Capsules"
    option_show "n"         "Next commit"
    option_show "p"         "Prev commit"
    option_show "s"         "Show commit summary"
    option_show "S"         "Show detailed info"
    option_show "h"         "Show history"
    option_show "d"         "Show diff"
    option_show "e"         "Edit the files affected by this commit (good to read all code)"
    option_show "i"         "Import this commit (cherry-pick)"
    option_show "I"         "Import other commits (cherry-pick)"
    option_show "m"         "mark, adds a mark on this position, to review later"
    option_show "M"         "Message, questions and requests to others"
    option_show "g"         "Go to commit id"
    option_show "u"         "Update working branch (pull --rebase)"
    option_show "U"         "Update watching branch (pull --rebase)"

    if [[ -n "$user_input_backport_branches" ]] ; then
        option_show "b"         " > Backport to: $user_input_backport_branches"
    else
        option_show "b"         "Backport it to another branches too (set them as comma-separated)"
    fi
    option_show "z"         "Undo last commit in your working branch"
    option_show "c"         "compile (make), useful for check if new code is compatible"
    option_show "C"         "set a specific Command to run (ex: make && sudo make install && enlightenment_remote -restart )"
    if [[ -n "$user_input_command" ]] ; then
        option_show "r"     " > Run:  $user_input_command"
    fi
    option_show "l"         "Login Shell (to do things manually)"
    option_show "a"         "list Around commits (from our watching thread)"
    option_show "A"         "list Around commits (from the full branch history)"
    option_show "B/R"       "Backup / Restore directory state (bkp tool)" # bkp is the best option for not mess up things, can be slow but it has also incrememental saving states too
    option_show "q"         "Quit"
    option_show "Q"         "Quit!"
    echo -e "${el_c_b}================================================================${el_c_n}"


    # select an option {{{
    #read -N 1 option

    # alternative to previous "read", this option makes possible to skip multichars entries tripling the loop for when you use inputs like "up arrow", it basically cleans the input to a single entry and accepts only alpha/numeric values
    local _c _d
    while read -N 1 _c
    do
        while read -t 0
        do read -N1 _d
            _c+=$_d
        done
        option="$( printf "%q" "$_c" | grep --color=never -E "^[[:alnum:]]$" )"
        break
    done

    el_debug "option picked is: '$option'"
    echo

    # }}}

    case "$option" in
        r)  # read messages / capsules
            scan_travels

            # go back to main menu
            $FUNCNAME

            ;;

        n)  # Next commit
            #el_explain 0 "Saving last commit watched"
            return

            ;;
        p)  # Prev commit
            if ((is_traveling)) ; then
                # so we return from who called it, which is go_to_commit
                return
            fi

            # get the previous commit id
            commit_id="$( command git log $options_extra_git_before --reverse "$branch_working".."$branch_watch" $options_extra_git_after | grep "^commit" | grep -B 1 "$commit_id" | awk '{print $2}' | head -1 )"

            # mark our new position
            echo "$commit_id" > "$conf_commit_last_f"

            # set the counter to count another commit remaining
            counter="$(( $counter - 1 ))"

            # we cannot go down to 0
            if [[ "${counter}" = "0" ]] ; then
                break
            fi


            # cleanup
            clear_screen default

            # show commit stat
            show_commit_stat --no-pager

            # go back to main menu
            $FUNCNAME


            ;;
        g)  # go to commit id
            go_to_commit

            # go back to main menu
            $FUNCNAME

            ;;
        u)  # update working branch

            # which remote to fetch from?
            if [[ -z "$remote_fetching_working" ]] ; then
                if [[ "$( command git remote -v | grep "(fetch)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
                    echo -e "\nWhich remote you want to fetch $branch_working from ?\n"
                    command git remote -v | grep "(fetch)" | awk '{print $1}'

                    read -e remote_fetching_working
                else
                    remote_fetching_working="$(command git remote -v | grep "(fetch)" | awk '{print $1}' | head -1 )"
                fi

                echo "$remote_fetching_working" > "$conf_remote_fetch_working_from_f"
            fi

            el_explain 0 "git pull --rebase $remote_fetching_working $branch_working"
            command git pull --rebase "$remote_fetching_working" "$branch_working"

            # update total of commits
            do_count_commits

            # return back to main menu
            $FUNCNAME

            ;;
        U)  # update watching branch

            # which remote to fetch from?
            if [[ -z "$remote_fetching_watch" ]] ; then
                if [[ "$( command git remote -v | grep "(fetch)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
                    echo -e "\nWhich remote you want to fetch $branch_watch from ?\n"
                    command git remote -v | grep "(fetch)" | awk '{print $1}'

                    read -e remote_fetching_watch
                else
                    remote_fetching_watch="$(command git remote -v | grep "(fetch)" | awk '{print $1}' | head -1 )"
                fi

                echo "$remote_fetching_watch" > "$conf_remote_fetch_watch_from_f"
            fi


            el_explain 0 "git checkout $branch_watch"
            command git checkout "$branch_watch"

            el_explain 0 "git pull --rebase $remote_fetching_watch $branch_watch"
            command git pull --rebase "$remote_fetching_watch" "$branch_watch"

            el_explain 0 "git checkout $branch_working"
            command git checkout "$branch_working"


            # update total of commits
            do_count_commits

            # return back to main menu
            $FUNCNAME

            ;;
        s)  # show info
            # show actual commit-id
            show_commit_stat


            # return back to main menu
            $FUNCNAME
            ;;
        S)  # show detailed info
            echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # show history
            show_history
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # show status
            command git status
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # show actual commit-id
            show_commit_stat

            # return back to main menu
            $FUNCNAME
            ;;

        h)  #history
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # show history
            show_history
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # return back to main menu
            $FUNCNAME

            ;;
        d)  # show patch
            clear_screen default
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            command git --no-pager show "$commit_id" | lsdiff
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            command git show "$commit_id"
            # return back to main menu
            $FUNCNAME

            ;;
        e)  # edit files
            # TODO: enter in the specific lines if vim
            if [[ -z "$EDITOR" ]] ; then
                echo -e "Set the editor (command) that you want to use"
                read -e EDITOR
            fi

            # edit files
            $EDITOR $(git show "$commit_id" | lsdiff | sed -e 's|^a/||g' -e 's|^b/||g' | tr '\n' ' ' )


            # show back the diff, we always want to see it again
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            command git --no-pager show "$commit_id" | lsdiff
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            command git --no-pager show "$commit_id"

            # return back to main menu
            $FUNCNAME

            ;;
        i)  # cherry-pick
            do_cherry_pick

            # show the last commit, to make sure that we know where we are
            show_commit_stat --no-pager

            # return back to main menu
            $FUNCNAME
            ;;

        I)  # cherry-pick
            el_explain 0 "Give a list of spaces-separated commits to cherry-pick in earlier-order (last lines first)"
            el_explain 0 "Use the listing-nearest feature or a shell to show list them, empty value will skip"

            read _commits

            do_cherry_pick_multiple "$_commits"

            # show the last commit, to make sure that we know where we are
            show_commit_stat --no-pager

            # return back to main menu
            $FUNCNAME

            ;;
        m)
            el_explain 0 "TODO / mark added"

            echo -e "\nMessage to include?  (blank = no message)"
            read -e _mark_message

            # create mark
            mkdir -p "${conf_repo_d}/ttc/${commit_id}"

            if [[ -n "$_mark_message" ]] ; then
                echo "$_mark_message" >> "${conf_repo_d}/ttc/${commit_id}/message.txt"
            fi

            # return back to main menu
            $FUNCNAME

            ;;
        M)

            # create messages for other users
            shared_messages_create

            # return back to main menu
            $FUNCNAME

            ;;
        b)  # extra branches where to backport
            if [[ -z "$user_input_backport_branches" ]] ; then
                echo -e "Set the name of the branches which you want to backport too, ex. enlightenment-0.18"
                read -e user_input_backport_branches
            fi

            if [[ -n "$user_input_backport_branches" ]] ; then

                while read -ru 3 branch
                do
                    command git checkout "$branch"
                    do_cherry_pick
                    command git checkout "$branch_working"

                done 3<<< "$( echo "$user_input_backport_branches" | tr ',' '\n' )"
            fi

            # return back to main menu
            $FUNCNAME
            ;;
        z)  # undo

            # show our actual commit
            show_history
            echo ""

            if el_confirm "Do you want to permanently remove the last commit?" ; then
                el_explain 0 "$ git reset --hard HEAD~1"
                command git reset --hard HEAD~1
            fi

            # return back to main menu
            $FUNCNAME
            ;;
        c)  # make
            make

            el_speak_text "make complete"
            # return back to main menu
            $FUNCNAME
            ;;
        C)  # command specific
            echo -e "\nPlease enter the command that you want to use:"
            echo -e "Example:  make && sudo make install && enlightenment_remote -restart"
            read -e user_input_command

            # return back to main menu
            $FUNCNAME
            ;;
        r)  # run specific command
            if [[ -n "$user_input_command" ]] ; then
                $user_input_command
                el_speak_text "run finished"
            fi

            # return back to main menu
            $FUNCNAME
            ;;
        a)  #  list around nearest
            el_explain 0 "nearest commits to your actual position in our watcher:"

            el_explain 2 "command git log --oneline --abbrev=12 $options_extra_git_before \"$branch_working\"..\"$branch_watch\" $options_extra_git_after | grep --color -C 6 \"${commit_id:0:12}\""
            command git log --oneline --abbrev=12 $options_extra_git_before "$branch_working".."$branch_watch" $options_extra_git_after | grep --color -C 6 "${commit_id:0:12}"

            el_explain 0 "list showed from newest to oldest"


            # return back to main menu
            $FUNCNAME
            ;;
        A)  # list Around nearest commits full
            el_explain 0 "nearest commits to your actual position in its full branch history:"

            el_explain 2 "command git log --oneline --abbrev=12 $options_extra_git_before \"$branch_watch\" | grep --color -C 16 \"${commit_id:0:12}\""
            command git log --oneline --abbrev=12 $options_extra_git_before "$branch_watch" | grep --color -C 16 "${commit_id:0:12}"

            el_explain 0 "list showed from newest to oldest"

            # return back to main menu
            $FUNCNAME
            ;;
        l)  # shell
            el_explain 0 "Starting a login shell, use ^d or logout when you finish to return back here"

            $SHELL -l

            # return back to main menu
            $FUNCNAME

            ;;
        B)  # bkp
            bkp save

            # return back to main menu
            $FUNCNAME
            ;;
        R)  # bkp
            bkp get

            # return back to main menu
            $FUNCNAME
            ;;
        q)  # quit

            # ask if save
            if ! [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
                if el_confirm "Do you want to save this session?" ; then
                    # add a mark to know that this is a persistent watcher to save
                    touch "$conf_repo_d/flags/persistent_watcher"

                    # save some needed info
                    echo "$branch_working" > "$conf_branch_working_f"
                fi
            fi

            # ask if share, only if we are saving session
            if [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
                if ! [[ -L "$conf_repo_d/shared" ]] ; then
                    # ask and conf about sharing session
                    conf_share_setup
                fi
            fi

            exit

            ;;
        Q)
            exit
            ;;


        # LAST option
        *)
            # return back to main menu because you picked a wrong option accidentally
            echo -e "wrong option?"
            sleep 1
            $FUNCNAME
            ;;
    esac
}
#===  FUNCTION  ================================================================
#          NAME:  usage_show
#===============================================================================
usage_show(){
    echo ""
    echo -e "$(basename $0) is a tool to watch what recently happened to a git repository and gives you some handy features like cherry-picking." 1>&2

    echo -e "Important notes: " 1>&2
    echo -e " - you must be in the branch where you want to apply the work" 1>&2
    echo -e " - watching states will be saved and shareable among remotes, check the .$(basename $0) dir" 1>&2
    echo -e " - the last-commit ID is memorized, based on the directory-name/working-branch/keyword name" 1>&2

    echo -e ""
    echo -e "Options:"
    option_show "-b" "Branch that you want to track changes"
    option_show "-k" "Keyword to search in the commit descriptions, listing only these ones, ex: 'fix'"
    option_show "-f" "Files/dirs which to track changes only, comma-separated, ex: 'src/bin/e_border.c,src/bin/e_win.c'"


    echo -e ""
    echo -e "Example of a new watcher: $(basename $0) -b master -k fix" 1>&2
    echo -e "To delete an existing watcher just remove the dir reference in .git-watcher" 1>&2

    echo -e ""

    show_states
}

main(){
    # version of this tool
    tool_version="1.3"
    tool_arguments="$@"
    # pre {{{

    # get the working branch name
    branch_working="$( command git symbolic-ref HEAD )"
    branch_working="${branch_working#refs/heads/}"

    if [[ -z "$branch_working" ]] ; then
        el_error "You are not in a git repository, this tool is meant to be used from a git repo"
        exit 1
    fi

    local is_commit_id_last_reached

    # }}}
    # input parameters {{{

    while getopts "b:k:f:" opt ; do
        case "$opt" in
            b)
                branch_watch="$OPTARG"
                ;;
            k)
                keyword_search="$OPTARG"
                options_extra_git_before="-i --grep $keyword_search $options_extra_git_before"
                ;;
            f)
                files_search="$OPTARG"
                # cleanups {{{
                while read -ru 3 line
                do
                    if [[ -d "$line" ]] ; then
                        # append a / at the end of the entry, force it to not have wrongly duplicated sessions
                        _files_search="${_files_search},${line%/}/"
                    else
                        _files_search="${_files_search},${line}"
                    fi

                done 3<<< "$( echo "$files_search" | tr ',' '\n' )"

                files_search="${_files_search#,}"
                el_debug "$files_search"

                # }}}
                options_extra_git_after="$options_extra_git_after -- ${files_search//,/ }"
                ;;
            \?|*)
                echo ""
                #echo "Invalid option" 1>&2
                usage_show
                exit
                ;;
            :)
                echo ""
                #echo "Option -$OPTARG requires an argument" 1>&2
                usage_show
                exit
                ;;
        esac
    done

    # - input parameters }}}
    # configurations saved {{{
    conf_d="$HOME/.config/$(basename $0)"

    # compatibility replacements
    files_search_regexed="$( echo "$files_search" | sed -e 's|/|#|g' )"

    # checks {{{

    if ! el_check_dirs "$conf_d" 2>/dev/null ; then
        mkdir -p "$conf_d"
    fi

    if ! el_check_variables "branch_working,branch_watch" 2>/dev/null ; then
        usage_show
        exit
    fi


    # }}}

    # append keyword in conf file if we have it
    #repo_id="${repo_id}::${branch_working}::${keyword_search}::${files_search}"
    repo_id="${branch_watch}::${keyword_search}::${files_search_regexed}"
    conf_repo_d="${conf_d}/${repo_id}"

    mkdir -p "$conf_repo_d/flags"
    mkdir -p "$conf_repo_d/ttc"

    conf_commit_last_f="${conf_repo_d}/last_commit_tracked"
    conf_commit_last_progress_f="${conf_repo_d}/last_commit_tracked_progress"
    conf_remote_fetch_working_from_f="${conf_repo_d}/remote_fetching_working_from"
    conf_remote_fetch_watch_from_f="${conf_repo_d}/remote_fetching_watch_from"
    conf_remote_work_from_f="${conf_repo_d}/remote_fetching_from"
    conf_branch_working_f="${conf_repo_d}/branch_working_for"
    tool_version_f="${conf_repo_d}/version_tool.txt"

    # - configurations saved }}}
    # version tool {{{
    el_check_variables "tool_version"
    tool_version_watcher="$( tail -1 "${conf_d}/version.txt" 2>/dev/null )" # old, for compatibility
    tool_version_watcher="$( tail -1 "$tool_version_f" 2>/dev/null )"

    # first time? add it
    if [[ -z "$tool_version_watcher" ]] ; then
        tool_version_watcher="$tool_version"
        echo "$tool_version" > "${tool_version_f}"
    fi

    # upgrade required
    if dpkg --compare-versions "$tool_version_watcher" gt "$tool_version" ; then
        el_package_update_last_version "elive-tools"
        el_error "Your $(basename $0) has been upgraded, please run it again"

        exit
    fi

    # our tool is newer, manual upgrade required
    if dpkg --compare-versions "$tool_version_watcher" lt "$tool_version" ; then
        # prev conf dir:
        _conf_repo_d="${conf_repo_d}.old_v$tool_version_watcher"

        # do a backup for meld if wanted
        cp -a "${conf_repo_d}" "${_conf_repo_d}"
        el_explain 0 "XXWarning:XX your watcher confs needs to be upgraded, you can __manually__ merge later your old dir bits (first exit saving session) using meld as:  $  __meld \"${_conf_repo_d}\" \"${conf_repo_d}\"__"

        echo -e "\nPress Enter to continue..." 1>&2
        read nothing


        # upgrade cases (auto hooks): {{{
        while true
        do
            case "$tool_version_watcher" in
                1\.1)
                    # this version just needs to remove a file
                    el_explain 0 "Dummy / test upgrade state"
                    tool_version_watcher="1.2"
                    ;;
                1\.2)
                    # this version just needs to remove a file
                    set -x
                    rm -f "${conf_d}/version.txt"
                    rm -f "${conf_repo_d}/remote_fetching_from"
                    set +x

                    el_explain 0 "removed wrong files (you can safely continue)"
                    tool_version_watcher="1.3"
                    ;;
                *)
                    el_explain 0 "Nothing more to __automatically__ upgrade"
                    break
                    ;;
            esac
        done

        echo -e "\nPress Enter to continue..." 1>&2
        read nothing


        # }}}

        # update version number
        echo "$tool_version" > "$tool_version_f"
    fi


    # }}}
    # configurations get configurations {{{

    # last commit
    if [[ -s "$conf_commit_last_f" ]] ; then
        commit_id="$( tail -1 "$conf_commit_last_f" )"
    fi


    # remote fetching
    if [[ -s "$conf_remote_fetch_working_from_f" ]] ; then
        remote_fetching_working="$( tail -1 "$conf_remote_fetch_working_from_f" )"
    fi
    if [[ -s "$conf_remote_fetch_watch_from_f" ]] ; then
        remote_fetching_watch="$( tail -1 "$conf_remote_fetch_watch_from_f" )"
    fi
    # remote working
    if [[ -s "$conf_remote_work_from_f" ]] ; then
        remote_working="$( tail -1 "$conf_remote_work_from_f" )"
    fi


    # branch working
    if [[ -s "$conf_branch_working_f" ]] ; then
        _branch_working="$( tail -1 "$conf_branch_working_f" )"
        if [[ "$branch_working" != "$_branch_working" ]] ; then
            el_explain 0 "XXWarningXX: working branch set for this watcher is not __${_branch_working}__ but is ${branch_working}"
            if el_confirm "Want to switch to $_branch_working ?" ; then
                branch_working="${_branch_working}"
                command git checkout "$branch_working"
            fi
        fi
    fi

    git_username="$( command git config user.name | tail -1 )"
    git_email="$( command git config user.email | tail -1 )"

    # do we are in a saved session?
    if [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
        is_saved=1
    fi

    # - configurations get }}}

    # get share configurations
    if [[ -s "$conf_d/shared_main_default_dir.txt" ]] ; then
        shared_main_d="$( cat "$conf_d/shared_main_default_dir.txt" )"
    fi

    if [[ -L "$conf_repo_d/shared" ]] ; then
        is_shared=1

        shared_d="$conf_repo_d/shared"
        shared_personal_d="$shared_d/$git_username"

        # start the share daemon
        run_dropbox
    fi

    # get the total of commits list
    do_count_commits

    # scan your own to-do marks:
    scan_marked_states

    # scan if other users are ahead of you
    shared_accounts_state_show


    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

    # debug
    if [[ "${EL_DEBUG}" -ge "2" ]] ; then
        el_explain 2 "git log __${options_extra_git_before} --reverse __${branch_working}__..__${branch_watch}__ __${options_extra_git_after}"
        #sleep 2
    fi



    # loop
    while read -ru 3 line
    do
        # get commit
        if [[ "$line" = "commit "* ]] ; then

            # skip until last commit, this only runs when starting back a watcher
            if ! ((is_commit_id_last_reached)) && ((is_saved)) ; then
                if [[ -n "$commit_id" ]] && [[ "$line" = "commit "$commit_id ]] ; then
                    is_commit_id_last_reached=1
                else
                    # loop until we reach the desired commit
                    el_debug "skip commit because is not $commit_id : $line"
                    continue
                fi
            fi


            # get the commit id of this loop
            commit_id="${line#commit }"


            # show actual commit
            show_commit_stat --no-pager

            # store actual position for future calls of this tool
            echo "$commit_id" > "$conf_commit_last_f"
            el_debug "stored '$commit_id' to '$conf_commit_last_f'"

            echo -e "$counter $counter_total" > "$conf_commit_last_progress_f"
            el_debug "stored counter at '$counter' with '$counter_total' total in '$conf_commit_last_progress_f'"


            #
            # show main options
            options_main_interact

            el_debug "going to next loop"
            #
            #

            # count another commit because we go to next loop
            counter="$(( $counter + 1 ))"

            # clear screen, but after that we did everything before to start
            clear_screen default

        fi

    done 3<<< "$( command git log $options_extra_git_before --reverse "$branch_working".."$branch_watch" $options_extra_git_after )"



    if ! ((is_header_show)) ; then
        if ((is_commit_id_last_reached)) ; then
            el_explain 0 "No more matches found, __ow yeah baby!__"
        else
            el_error "Something wrong happened? seems like we cannot found your last position, so where is this commit then? $commit_id"
        fi
    fi

}

#
#  MAIN
#
main "$@"


# vim: set foldmethod=marker :

