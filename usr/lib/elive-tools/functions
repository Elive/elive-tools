#!/bin/bash

el_c_n="\033[0;39m" # Normal color  (orig: normal)
el_c_r="\033[1;31m" # Red color  (orig: red)
el_c_r2="\033[0;31m" # Red2 color  (orig: red)
el_c_g="\033[1;32m" # Green color  (orig: green)
el_c_g2="\033[0;32m" # Green2 color  (orig. green2)
el_c_y="\033[1;33m" # Yellow color  (orig. yellow)
el_c_y2="\033[0;33m" # Yellow2 color  (orig. yellow)
el_c_m="\033[1;35m" # Magenta color
el_c_m2="\033[0;35m" # Magenta2 color
el_c_c="\033[1;36m" # Cyan color
el_c_c2="\033[0;36m" # Cyan2 color
el_c_b="\033[1;34m" # Blue color
el_c_b2="\033[0;34m" # Blue2 color
el_c_gr="\033[1;30m" # Gray color
el_c_gr2="\033[0;30m" # Gray2 color

el_c_blink="\033[5m" # Blink 'color' effect  (orig. blink)
el_c_underline="\033[4m" # Underline 'color' effect  (orig. underline)
el_c_italic="\033[3m" # Italic 'color' effect
el_c_bold="\033[1m" # Bold 'color' effect

: ${EL_DEBUG:="0"} # debug default level


#-------------------------------------------------------------------------------
#   Set the DISPLAY variable
#-------------------------------------------------------------------------------
el_set_display_variables(){ # Set DISPLAY variables of our actual user
    # from enlightenment values {{{
    local display e_ipc_socket is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    if [[ -z "${DISPLAY}" ]] || [[ -z "${E_IPC_SOCKET}" ]] ; then
        if ls --color=none /tmp/enlightenment-${USER}@*/disp-* 1>/dev/null 2>/dev/null ; then
            display="$( find /tmp/enlightenment-${USER}@*/disp-* -mindepth 0 -maxdepth 0 -type s | sort -g | tail -1 2>/dev/null )"

            e_ipc_socket="${display%|*}"

            display="${display##*disp-}"
            display="${display%%-*}"

            if [[ -z "${DISPLAY}" ]] ; then
                DISPLAY="${display}"
                export DISPLAY

                E_IPC_SOCKET="${e_ipc_socket}"
                export E_IPC_SOCKET
            fi
            # FIXME: if values are not obtained we should make a kind of statistics/reports
        fi

    fi
    # END from enlightenment values }}}
    # xauthority {{{
    if [[ -z "$XAUTHORITY" ]] ; then
        XAUTHORITY="$HOME/.Xauthority"
        export XAUTHORITY
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
    # END xauthority }}}
}
#-------------------------------------------------------------------------------
#   Send a notification to the user
#-------------------------------------------------------------------------------
el_notify_user(){ # notify the user (desktop || email). "title" "text"
    local is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    el_set_display_variables

    if [[ "${DISPLAY}" = ":0.0" ]] && [[ -z "${TERM}" ]] ; then
        notify-send -t 20000 "$@"
    else
        echo -e "${el_c_y}Info: ${el_c_c}$2${el_c_n}" 1>&2
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}
#-------------------------------------------------------------------------------
#   Send an important notification to the user
#-------------------------------------------------------------------------------
el_notify_user_important(){ # notify the user (desktop || email). "title" "text" (no timeout mode)
    local is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    el_set_display_variables

    if [[ "${DISPLAY}" = ":0.0" ]] && [[ -z "${TERM}" ]] ; then
        notify-send -t 240000 "$@"
    else
        echo -e "${el_c_y}Important: ${el_c_m}$2${el_c_n}" 1>&2
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}

#-------------------------------------------------------------------------------
#   Verify if we have internet connection (return value)
#-------------------------------------------------------------------------------
el_verify_internet(){ # verify if we have internet connection (true or false, return value)
    # pre {{{
    local stamp_hour_prev date_hour_now date_hour_prev returned is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    stamp_hour_prev="/tmp/.stamps/verify_internet-${USER}-last_run_hour"
    mkdir -p "$(dirname "${stamp_hour_prev}" )"

    date_hour_now="$( date +%F-%H )"
    date_hour_prev="$( tail -1 "${stamp_hour_prev}" 2>/dev/null )"

    # remove extra leading blank chars
    read -r date_hour_prev <<< "$date_hour_prev"

    # }}}

    # exit if we have already run that before
    if [[ "${date_hour_prev}" = "$date_hour_now" ]] ; then
        echo "$date_hour_now" > "$stamp_hour_prev"

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 0
    fi

    el_set_display_variables
    if timeout 50 curl www.google.com 2>/dev/null | grep -qi 'html' ; then
        echo "$date_hour_now" > "$stamp_hour_prev"

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 0
    else
        sleep 60
        if timeout 50 curl www.google.com 2>/dev/null | grep -qi 'html' ; then
            echo "$date_hour_now" > "$stamp_hour_prev"

            ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
            return 0
        else
            sleep 120
            if timeout 50 curl www.google.com 2>/dev/null | grep -qi 'html' ; then
                echo "$date_hour_now" > "$stamp_hour_prev"

                ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
                return 0
            else
                echo -e "Connection to internet not found" 1>&2
                echo "$date_hour_now" > "$stamp_hour_prev"

                ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
                return 1
            fi
        fi
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}


#-------------------------------------------------------------------------------
#   Speak something
#-------------------------------------------------------------------------------
el_speak_text(){
    local text is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    el_check_dependencies text2wave

    text="$( echo "$text" | iconv -f utf8 -t ISO-8859-15 )"
    echo -e "$text" | text2wave -scale 5 > /tmp/.$$-festival-message.wav
    mplayer -really-quiet /tmp/.$$-festival-message.wav 2>/dev/null
    rm -f /tmp/.$$-festival-message.wav

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}

#-------------------------------------------------------------------------------
#   Make ready the user's environment (bash variables, extra functions, etc)
#-------------------------------------------------------------------------------
el_make_environment(){ # make ready our environment (source variables and functions)
    local is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    if [[ -z "${USER}" ]] ; then
        if [[ -z "${HOME}" ]] ; then
            export HOME="/home"
        fi
        USER="$(basename $HOME)"
        export USER
    fi

    el_set_display_variables

    if [[ "$PATH" != *"$HOME/bin"* ]] ; then
        PATH="$HOME/bin:$PATH"
    fi

    if [[ -n "${BASH_SOURCE}" ]] ; then
        export PS4='+ ($(basename ${BASH_SOURCE}):${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}():  }'
    else
        export PS4='+ (SHELL:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}():  }'
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}

#-------------------------------------------------------------------------------
#   Title Set: sets the title of a window
#-------------------------------------------------------------------------------
el_title_set(){ # set the Title on the actual Window
    local is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    el_set_display_variables
    echo -ne '\033]0;'$@'\007'

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}

#-------------------------------------------------------------------------------
#   Resolutions, get the resolution values
#-------------------------------------------------------------------------------
el_resolution_get(){ # show our actual resolution
    local is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    el_check_dependencies xdpyinfo
    el_set_display_variables

    xdpyinfo | grep dimension | awk '{print $2}' | grep x | tail -1

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}

#-------------------------------------------------------------------------------
#   Dependencies Check
#-------------------------------------------------------------------------------
el_check_dependencies(){ # check if we have these command dependencies, if not, notify and exit
    # example:  el_check_dependencies gmplayer,find,sed,etc
    local check found found_no dir is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    while read -ru 3 check
    do
        unset found

        for dir in $(echo ${PATH}:/usr/local/sbin:/usr/sbin:/sbin | tr ':' ' ')
        do
            if test -x ${dir}/$check
            then
                found=yes
                break
            fi
        done

        if [[ "$found" != "yes" ]] ; then
            echo "Error: command '$check' not found" 1>&2
            el_notify_user "Command Not Found" "Error: command '$check' for $(basename $0) not found"
            found_no="yes"
        fi

    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    else

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 0
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}


#-------------------------------------------------------------------------------
#   Check if variable exists
#-------------------------------------------------------------------------------
el_check_variables(){ # check if we have set these variables, if not, notify and exit
    # example $0 foo,bar,we
    local found_no var is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    while read -ru 3 var
    do
        if [[ ! -n "${!var}" ]] ; then
            el_notify_user "E: Variable not exists" "E: the variable '$var' is not set"
            found_no="yes"
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    else

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 0
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}


#-------------------------------------------------------------------------------
#   Check if files exists
#-------------------------------------------------------------------------------
el_check_files(){ # check if we have these files (and non-zero), if not, notify and exit
    # example $0 foo,bar,we
    local var found_no is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)"

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    fi

    while read -ru 3 var
    do
        if [[ ! -s "${var}" ]] ; then
            el_notify_user "E: File not exists" "E: the file '$var' not exists"
            found_no="yes"
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    else

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 0
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}


#-------------------------------------------------------------------------------
#   Check if dir exists
#-------------------------------------------------------------------------------
el_check_dirs(){ # check if we have these dirs (and non-zero), if not, notify and exit
    # example $0 foo,bar,we
    local var found_no is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)"

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    fi

    while read -ru 3 var
    do
        if [[ ! -d "${var}" ]] ; then
            el_notify_user "E: Dir not exists" "E: the dir '$var' not exist"
            found_no="yes"
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    else

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 0
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}


#-------------------------------------------------------------------------------
#   check if dir has files
#-------------------------------------------------------------------------------
el_check_dir_has_files(){
    local dir is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    dir="$1"

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)"

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    fi

    if [[ ! -d "$dir" ]] ; then
        el_notify_user "Dir not exist" "$dir"

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    else
        if ! ls "${dir}/"*  2>/dev/null 1>/dev/null ; then
            el_notify_user "Dir has no files" "$dir"

            ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
            return 1
        fi
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}

#-------------------------------------------------------------------------------
#   check if we have automatic sudo
#-------------------------------------------------------------------------------
el_check_sudo_automated(){
    local is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    if ! sudo -H -n echo 2>&1 ; then
        el_notify_user "Automated sudo is required" "Your sudo requires a password, we need it to be configured for not request it"

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        exit 1
    else

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 0
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}
#===  FUNCTION  ================================================================
#          NAME:  el_explain
#   DESCRIPTION:  function to show the progress of the application
#    PARAMETERS:
# verbose_level:    $1 = any number, from $EL_DEBUG levels
#                        levels: 0 = always, 1 = info, 2 = debug
#       message:    $2 = can include: __hilight words__, XXsuper hilightXX
#===============================================================================
el_explain(){
    # pre {{{
    local funclevel spaced verbose_level message trace_message trace_col is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    verbose_level="$1"
    shift
    message="$@"

    spaced="$verbose_level"
    funclevel="$(( ${#FUNCNAME[*]} - 2 ))"

    el_check_variables "spaced,verbose_level,message"
    # }}}
    # tabulate output {{{
    while [[ $spaced -gt 0 ]] ; do
        message="  $message"
        spaced="$(( $spaced - 1 ))"
    done

    # }}}
    # hilight words {{{
    message="${message/__/${el_c_b2}}"
    message="${message/__/${el_c_gr}}"
    message="${message/__/${el_c_b2}}"
    message="${message/__/${el_c_gr}}"
    message="${message/__/${el_c_b2}}"
    message="${message/__/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    # }}}
    # show {{{
    # this is a good example of levels of colors visualization for the user's eye

    # show only if we are on this verbose level
    if [[ "${EL_DEBUG}" -ge "$verbose_level" ]] ; then
        case $funclevel in
            1)
                echo -en "   ${el_c_gr}[${el_c_b2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            2)
                echo -en "   ${el_c_gr}[${el_c_b}${funclevel}${el_c_gr}] " 1>&2
                ;;
            3)
                echo -en "   ${el_c_gr}[${el_c_c2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            4)
                echo -en "   ${el_c_gr}[${el_c_c}${funclevel}${el_c_gr}] " 1>&2
                ;;
            5)
                echo -en "   ${el_c_gr}[${el_c_g2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            6)
                echo -en "   ${el_c_gr}[${el_c_g}${funclevel}${el_c_gr}] " 1>&2
                ;;
            7)
                echo -en "   ${el_c_gr}[${el_c_y2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            8)
                echo -en "   ${el_c_gr}[${el_c_y}${funclevel}${el_c_gr}] " 1>&2
                ;;
            9)
                echo -en "   ${el_c_gr}[${el_c_r2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            10)
                echo -en "   ${el_c_gr}[${el_c_r}${funclevel}${el_c_gr}] " 1>&2
                ;;
            11)
                echo -en "   ${el_c_gr}[${el_c_m2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            *)
                echo -en "   ${el_c_gr}[${el_c_m}${funclevel}${el_c_gr}] " 1>&2
                ;;
        esac

        # continuation of the message
        echo -e "${message}${el_c_n}" 1>&2

    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
    # }}}
}
#===  FUNCTION  ================================================================
#          NAME:  el_debug
#   DESCRIPTION:  show debug messages | EL_DEBUG -ge 1
#    PARAMETERS:  optional (message)
#===============================================================================
el_debug(){
    # debug {{{
    local funclevel is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
    funclevel="$funclevel"

    if [[ "${EL_DEBUG}" -ge 2 ]] ; then
        # level 2 is debug
        echo -e "${el_c_gr}D: ${el_c_gr}[${el_c_m}${funclevel}${el_c_gr}] ${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO} ${el_c_c}$@${el_c_n}" 1>&2

    fi

    # more debug, show function-call array
    if [[ "${EL_DEBUG}" -ge 3 ]] ; then
        # show the array of calls
        funclevel="${funclevels}"
        echo -en "${el_c_gr}calls:"
        while [[ $funclevel -gt 0 ]] ; do
            echo -en " -> ${FUNCNAME[$funclevel]}"
            funclevel="$(( $funclevel - 1 ))"
        done
        echo -e "${el_c_n}"
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_warning
#   DESCRIPTION:  show warning messages | EL_DEBUG -ge 1
#    PARAMETERS:  optional (message)
#===============================================================================
el_warning(){
    # warning {{{
    local is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    if [[ "${EL_DEBUG}" -ge 1 ]] ; then
        echo -e "${el_c_y}Warning: ${el_c_c}[${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO}${el_c_c}] ${el_c_c}$@${el_c_n}" 1>&2
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_error
#   DESCRIPTION:  show error messages | EL_DEBUG -ge 0
#    PARAMETERS:  optional (message)
#===============================================================================
el_error(){
    # error {{{
    local is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    if [[ "${EL_DEBUG}" -ge 0 ]] ; then
        echo -e "${el_c_r}Error: ${el_c_c}[${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO}${el_c_c}] ${el_c_c}$@${el_c_n}" 1>&2

    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_group_check
#   DESCRIPTION:  check if user is already on a specific group
#    PARAMETERS:  $1 = groupname
#===============================================================================
el_group_check(){
    # pre {{{
    local group is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    group="${1}"

    el_check_variables "group"

    # }}}

    if [[ " $(id -Gn "$USER") " = *" $group "* ]] ; then

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 0
    else

        ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
        return 1
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}

#===  FUNCTION  ================================================================
#          NAME:  el_group_add
#   DESCRIPTION:  verify and add an user to a group
#    PARAMETERS:  $1 = group to add
#===============================================================================
el_group_add(){
    # pre {{{
    local group is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    group="$1"

    el_check_variables "group"

    # }}}
    if ! el_group_check "${group}" ; then
        gksu "adduser ${USER} ${group}"
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
}

#===  FUNCTION  ================================================================
#          NAME:  el_security_function_loop
#   DESCRIPTION:  check for a possible infinite-loops, needs to be called as:
#                 el_security_function_loop || return
#                 from every function of your scripts
#    PARAMETERS:  $1 = number of recursivity's allowed
#       RETURNS:  1 if found a loop, 0 if not
#===============================================================================
el_security_function_loop(){
    # pre {{{
    local funclevels funclevel count_recursive is_loop_infinite is_loop_predetected is_flag_set_x
    [[ $- = *x* ]] && is_flag_set_x=1 && set +x || true

    # }}}
    # high value of count_recursive if we call a function recursively multiple times
    if [[ -n "$1" ]] ; then
        count_recursive="$(( 1 + $1 ))"
    else
        count_recursive="1"
    fi

    funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
    funclevel="${funclevels}"

    # walk around our parent functions
    while [[ $funclevel -gt 0 ]] ; do
        # ignore the last check, which is of course the same name
        if [[ "${count_recursive}" -lt "$funclevels" ]] ; then
            # check if we already come from our function-name in our parents
            if [[ "${FUNCNAME[$funclevel]}" = "${FUNCNAME[1]}" ]] ; then
                if ((is_loop_predetected)) ; then
                    # already entered loop, we should break the loop and continue gracefully
                    is_loop_infinite=1
                else
                    # give at least a chance to the infinite-loop, but we shouldn't
                    is_loop_predetected=1
                fi
            fi
        fi


        funclevel="$(( $funclevel - 1 ))"
        count_recursive="$(( $count_recursive + 1 ))"
    done


    # do action for our resulting checks
    if ((is_loop_predetected)) ; then
        if ((is_loop_infinite)) ; then
            # note: we set it as a warning instead of error because it is really a way that solves errors making the application working, at least for "smart" applications (no linear procedure but a set of tasks and where the application is meant to know what to do)
            if [[ "${EL_DEBUG}" -ge "1" ]] ; then
                el_warning "Entered in an Infinite Loop, let's jump it"
                el_explain 1 "__Note:__ Declarative programming requires this feature for work correctly, in short, if the application works correctly then everything is fine."

                # show the array of calls
                funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
                funclevel="${funclevels}"
                echo -en "${el_c_b}calls:${el_c_gr}"
                while [[ $funclevel -gt 0 ]] ; do
                    echo -en " -> ${FUNCNAME[$funclevel]}"
                    funclevel="$(( $funclevel - 1 ))"
                done
                echo -e "${el_c_n}"
            fi

            ((is_flag_set_x)) && set -x && unset is_flag_set_x || true
            return 1
        else
            if [[ "${EL_DEBUG}" -ge "2" ]] ; then
                el_warning "Detected a possible infinite loop"

                # show the array of calls
                funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
                funclevel="${funclevels}"
                echo -en "${el_c_gr}calls:"
                while [[ $funclevel -gt 0 ]] ; do
                    echo -en " -> ${FUNCNAME[$funclevel]}"
                    funclevel="$(( $funclevel - 1 ))"
                done
                echo -e "${el_c_n}"
            fi
        fi
    fi

    ((is_flag_set_x)) && set -x && unset is_flag_set_x || true

}







# FIXME: implement:
#
# - check same proceses
# - el_fixme_required -> report to the user that the feature is not implemented by some future userfriendly way
# - arrays ?
# - run web
# - confirm (shell)
# - trap signals (exit statuses, etc)
# - report, something for inform the user about something important, which interfaces and cases ?
# -
# -
# -
# -
# -
# -


# vim: set foldmethod=marker :

