#!/bin/bash
set -e
el_c_n="\033[0;39m" # Normal color  (orig: normal)
el_c_r="\033[1;31m" # Red color  (orig: red)
el_c_r2="\033[0;31m" # Red2 color  (orig: red)
el_c_g="\033[1;32m" # Green color  (orig: green)
el_c_g2="\033[0;32m" # Green2 color  (orig. green2)
el_c_y="\033[1;33m" # Yellow color  (orig. yellow)
el_c_y2="\033[0;33m" # Yellow2 color  (orig. yellow)
el_c_m="\033[1;35m" # Magenta color
el_c_m2="\033[0;35m" # Magenta2 color
el_c_c="\033[1;36m" # Cyan color
el_c_c2="\033[0;36m" # Cyan2 color
el_c_b="\033[1;34m" # Blue color
el_c_b2="\033[0;34m" # Blue2 color
el_c_gr="\033[1;30m" # Gray color
el_c_gr2="\033[0;30m" # Gray2 color

el_c_blink="\033[5m" # Blink 'color' effect  (orig. blink)
el_c_underline="\033[4m" # Underline 'color' effect  (orig. underline)
el_c_italic="\033[3m" # Italic 'color' effect
el_c_bold="\033[1m" # Bold 'color' effect

: ${EL_DEBUG:="0"} # debug default level


# TODO FIXME: if you remove these blocks, add NOREPORTS=1
#===  FUNCTION  ================================================================
#          NAME:  el_confirm
#   DESCRIPTION:  ask (console) for confirmation
#    PARAMETERS:  question
#       RETURNS:  true | false
#===============================================================================
el_confirm(){
    # pre {{{
    local reply question flag_glob

    if shopt extglob | grep -q "extglob.*off" ; then
        flag_glob=1
    fi

    shopt -s extglob
    question="$1"

    el_check_variables "question"


    # }}}
    # return answer {{{
    echo -en "$question [y/n]: "
    read -e reply

    case $reply in
        y|Y|Yes|YES|s|S)
            return  0
            ;;
        n|N|no|NO|nope)
            return  1
            ;;
        *)
            # repeat question until confirmation
            if el_confirm "$@" ; then
                return 0
            else
                return 1
            fi
            ;;
    esac

    if ((flag_glob)) ; then
        shopt -u extglob
    fi

    # }}}
}
#===  FUNCTION  ================================================================
#          NAME:  el_error
#   DESCRIPTION:  show error messages | EL_DEBUG -ge 0
#    PARAMETERS:  optional (message)
#===============================================================================
el_error(){
    # error {{{

    if [[ "${EL_DEBUG}" -ge 0 ]] ; then
        echo -e "${el_c_r}Error: ${el_c_c}[${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO}${el_c_c}] ${el_c_c}$@${el_c_n}" 1>&2

    fi

    # }}}
}
#===  FUNCTION  ================================================================
#          NAME:  el_warning
#   DESCRIPTION:  show warning messages | EL_DEBUG -ge 1
#    PARAMETERS:  optional (message)
#===============================================================================
el_warning(){
    # warning {{{

    if [[ "${EL_DEBUG}" -ge 1 ]] ; then
        echo -e "${el_c_y}Warning: ${el_c_c}[${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO}${el_c_c}] ${el_c_c}$@${el_c_n}" 1>&2
    fi

    # }}}
}
#===  FUNCTION  ================================================================
#          NAME:  el_explain
#   DESCRIPTION:  function to show the progress of the application
#    PARAMETERS:
# verbose_level:    $1 = any number, from $EL_DEBUG levels
#                        levels: 0 = always, 1 = info, 2 = debug
#       message:    $2 = can include: __hilight words__, XXsuper hilightXX
#===============================================================================
el_explain(){
    # pre {{{
    local funclevel spaced verbose_level message trace_message trace_col

    verbose_level="$1"
    shift
    message="$@"

    spaced="$verbose_level"
    funclevel="$(( ${#FUNCNAME[*]} - 2 ))"

    el_check_variables "spaced,verbose_level,message"
    # }}}
    # tabulate output {{{
    while [[ $spaced -gt 0 ]] ; do
        message="  $message"
        spaced="$(( $spaced - 1 ))"
    done

    # }}}
    # hilight words {{{
    message="${message/__/${el_c_b2}}"
    message="${message/__/${el_c_gr}}"
    message="${message/__/${el_c_b2}}"
    message="${message/__/${el_c_gr}}"
    message="${message/__/${el_c_b2}}"
    message="${message/__/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    # }}}
    # show {{{
    # this is a good example of levels of colors visualization for the user's eye

    # show only if we are on this verbose level
    if [[ "${EL_DEBUG}" -ge "$verbose_level" ]] ; then
        case $funclevel in
            1)
                echo -en "   ${el_c_gr}[${el_c_b2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            2)
                echo -en "   ${el_c_gr}[${el_c_b}${funclevel}${el_c_gr}] " 1>&2
                ;;
            3)
                echo -en "   ${el_c_gr}[${el_c_c2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            4)
                echo -en "   ${el_c_gr}[${el_c_c}${funclevel}${el_c_gr}] " 1>&2
                ;;
            5)
                echo -en "   ${el_c_gr}[${el_c_g2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            6)
                echo -en "   ${el_c_gr}[${el_c_g}${funclevel}${el_c_gr}] " 1>&2
                ;;
            7)
                echo -en "   ${el_c_gr}[${el_c_y2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            8)
                echo -en "   ${el_c_gr}[${el_c_y}${funclevel}${el_c_gr}] " 1>&2
                ;;
            9)
                echo -en "   ${el_c_gr}[${el_c_r2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            10)
                echo -en "   ${el_c_gr}[${el_c_r}${funclevel}${el_c_gr}] " 1>&2
                ;;
            11)
                echo -en "   ${el_c_gr}[${el_c_m2}${funclevel}${el_c_gr}] " 1>&2
                ;;
            *)
                echo -en "   ${el_c_gr}[${el_c_m}${funclevel}${el_c_gr}] " 1>&2
                ;;
        esac

        # continuation of the message
        echo -e "${message}${el_c_n}" 1>&2

    fi

    # }}}
}
#-------------------------------------------------------------------------------
#   Check if variable exists
#-------------------------------------------------------------------------------
el_check_variables(){
    # check if we have set these variables, if not, notify and exit {{{
    # example $0 foo,bar,we
    local found_no var

    while read -ru 3 var
    do
        if [[ ! -n "${!var}" ]] ; then
            #el_notify_user "E: Variable not exists" "E: the variable '$var' is not set"
            el_error "Variable '$var' is not set"
            found_no="yes"
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        return 1
    else

        return 0
    fi

    # }}}
}
#-------------------------------------------------------------------------------
#   Check if dir exists
#-------------------------------------------------------------------------------
el_check_dirs(){
    # check if we have these dirs (and non-zero), if not, notify and exit {{{
    # example $0 foo,bar,we
    local var found_no

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)" 1>&2

        return 1
    fi

    while read -ru 3 var
    do
        if [[ ! -d "${var}" ]] ; then
            #el_notify_user "E: Dir not exists" "E: the dir '$var' not exist"
            el_error "Directory '$var' not exist"
            found_no="yes"
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        return 1
    else

        return 0
    fi

    # }}}
}
#-------------------------------------------------------------------------------
#   Dependencies Check
#	example:  el_dependencies_check gmplayer,find,sed,etc
#-------------------------------------------------------------------------------
el_dependencies_check(){
    # check if we have these command dependencies, if not, notify and exit {{{
    local check found found_no dir

    while read -ru 3 check
    do
        unset found

        for dir in $(echo ${PATH}:/usr/local/sbin:/usr/sbin:/sbin | tr ':' ' ')
        do
            if test -x ${dir}/$check
            then
                found=yes
                break
            fi
        done

        if [[ "$found" != "yes" ]] ; then
            el_error "Command '$check' for $(basename $0) not found"
            found_no="yes"
        fi

    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        return 1
    else

        return 0
    fi
    # }}}
}
#-------------------------------------------------------------------------------
#   check if we have automatic sudo
#-------------------------------------------------------------------------------
el_check_sudo_automated(){
    # {{{

    if ! sudo -H -n echo 2>/dev/null 1>/dev/null ; then
        #el_notify_user "Automated sudo is required" "Your sudo requires a password, we need it to be configured for not request it"
        #el_explain 0 "Automated sudo is suggested (nopassword option): This tool requires it in case there's files without permissions"

        return 1
    else

        return 0
    fi

    # }}}
}
#-------------------------------------------------------------------------------
#   Set the DISPLAY variable
#-------------------------------------------------------------------------------
el_set_display_variables(){ # Set DISPLAY variables of our actual user
    # from enlightenment values {{{
    local display e_ipc_socket

    if [[ -z "${DISPLAY}" ]] || [[ -z "${E_IPC_SOCKET}" ]] ; then
        if command ls --color=none /tmp/e-${USER}@*/*-* 1>/dev/null 2>/dev/null ; then
            display="$( command find /tmp/e-${USER}@*/*-* -mindepth 0 -maxdepth 0 -type s | sort -g | tail -1 2>/dev/null )"

            e_ipc_socket="${display%|*}"

            #display="${display##*disp-}"
            display="$( basename ${display} )"
            display="${display%-*}"

            if [[ -z "${DISPLAY}" ]] ; then
                DISPLAY="${display}"
                export DISPLAY
            fi

            if [[ -z "${E_IPC_SOCKET}" ]] ; then
                E_IPC_SOCKET="${e_ipc_socket}"
                export E_IPC_SOCKET
            fi
        fi

    fi
    # END from enlightenment values }}}
    # xauthority {{{
    if [[ -z "$XAUTHORITY" ]] && [[ -e "$HOME/.Xauthority" ]] ; then
        XAUTHORITY="$HOME/.Xauthority"
        export XAUTHORITY
    fi

    if [[ "$TERM" != linux ]] && [[ "$UID" != 0 ]] ; then
        # only show the error if we have a graphical system running by the user
        if command ls --color=none /tmp/e-${USER}@*/*-* 1>/dev/null 2>/dev/null ; then
            if [[ -z "${DISPLAY}" ]] ; then
                el_explain 1 "Variable DISPLAY is not set, so we will not have access to the local graphical system"
            fi
            if [[ -z "${XAUTHORITY}" ]] ; then
                el_explain 1 "Variable XAUTHORITY is not set, so we may not have full access to the local graphical system"
            fi
            if [[ -z "${E_IPC_SOCKET}" ]] ; then
                if [[ "$UID" != 0 ]] ; then
                    el_explain 3 "Variable E_IPC_SOCKET is not set, we may be not the owner of this graphical session (Ignore this message)"
                fi
            fi
        fi
    fi

    # END xauthority }}}
}
#-------------------------------------------------------------------------------
#   Install required packages
#-------------------------------------------------------------------------------
el_dependencies_install(){
    # install required dependencies {{{
    local depends temp
    depends="$( echo "$@" | tr ',' ' ' )"
    el_set_display_variables

    # TODO:  even better: use a gui tool for install deps
    el_dependencies_check "urxvt,gksu"

    temp="/tmp/.$(basename $0)-${USER}-$$"
    cat > "${temp}" << EOF
#!/bin/bash

urxvt -e bash -c "echo -e 'Installing Dependencies...' ; sleep 1 ; apt-get update ; apt-get -f install ; apt-get install $depends ; echo ; echo ; echo ; echo ; echo 'Finished, you can close the terminal...' ; sleep 20 "

EOF

    chmod +x "${temp}"
    if [[ "$UID" = 0 ]] ; then
        bash "${temp}"
    else
        gksu "${temp}"
    fi

    rm -f "${temp}"

    # }}}
}


# if we have the original and updated functions, use them (so: we are in elive)
if [[ -s /usr/lib/elive-tools/functions ]] ; then
    source /usr/lib/elive-tools/functions
    el_make_environment
fi

check_files_owner_compatibility(){
    local dir
    # check for files that are not owned by you so it can cause problems using this tool
    for dir in "$@"
    do
        if [[ -d "$dir" ]] ; then
            el_debug "checking for files not owned by you in '$dir'"

            if [[ "$( find "$dir" ! -user "$USER" 2>/dev/null | wc -l )" -gt 0 ]] ; then
                echo ""
                echo ""
                el_error "These files can give problems:"
                find "$dir" ! -user "$USER" 2>/dev/null

                echo ""
                EL_DEBUG=2 el_warning "Files owned by someone else found"
                el_info "We suggest to configure your sudo to NOPASSWD so this tool can use it, this is important because you are trying to deal with a directory that has files owned not by you and this can cause problems like owners changed on these files when restoring it"
                el_info "Configuration example: add your user to the sudo group and an entry to your /etc/sudoers like:"
                #el_info "$USER ALL=NOPASSWD: /usr/bin/apt-get install"
                #el_info "$USER ALL=NOPASSWD: /usr/bin/apt-get*"
                el_info "$USER ALL=NOPASSWD: /usr/bin/bkp"
                echo ""

                # we have informed so we can finish here
                break
            fi
        fi
    done
}

do_sudo(){
    # run something as sudo, but if fails warn it
    if ! $SUDO_MODE "$@" ; then
        el_error "Unable to run \"$@\""
        el_info "this could be caused by lack of permissions in the files, a solution is to configured a NOPASSWD mode of sudo for your user and this will will use it"
        return 1
    else
        return 0
    fi
}



do_work(){
    # this feature does a temporal copy of the directory for work from it,
    # everything is erased after the logout
    local dir tmpdir

    dir="$(pwd)"
    tmpdir="${bkpdir_works}/${namedir}"

    do_sudo rm -rf "${tmpdir}"
    mkdir -p "${tmpdir}"
    rmdir "${tmpdir}" # remove last dir in order to really-copy here

    cp -aL "${dir}" "${tmpdir}"

    cd "${tmpdir}"

    echo -e "You are now in a safe place where modify your sources"
    echo -e "Your modifications will be merged or erased after you finish"
    el_explain 0 "Please logout from the shell for finish your working state"

    # entering in new shell
    $SHELL || true
    # go back
    cd "$target"

    if el_confirm "Delete the working state?" ; then
        do_sudo rm -rf "${tmpdir}"
    else
        if el_confirm "Do you want to run a meld with the original directory?" ; then
            if ! el_dependencies_check meld ; then
                if ! el_dependencies_install meld ; then
                    el_error "Please install required dependencies"
                fi
            fi
            meld "${tmpdir}" .
        fi
    fi

}

do_purge_olds(){
    local others_list_num

    others_list_num="$( ls -1 "${bkpdir_backups}" 2>/dev/null | wc -l )"

    # remove backups
    if [[ -d "${bkpdir_backups}" ]] ; then
        do_sudo rm -rf "${bkpdir_backups}/%"*
    fi
    # remove working states
    if [[ -d "${bkpdir_works}" ]] ; then
        do_sudo rm -rf "${bkpdir_works}/%"*
    fi


    echo -e "${el_c_y}All backups and workstates removed${el_c_n}  [${others_list_num}]"
}


do_save(){
    local version others_list_num ref

    mkdir -p "${bkpdir_backups}"

    # show old existing backups
    others_list_num="$( ls -1 "${bkpdir_backups}" 2>/dev/null | grep "\.rdiff$" | wc -l )"
    if [[ "$others_list_num" -gt 5 ]] ; then
        echo -e "Warning: other backups found:"
        while read -ru 3 line
        do
           ref="${line//%//}"
           ref="${ref%.rdiff*}"
           if [[ -d "${ref}" ]] ; then
               echo -e " * ref: ${el_c_c}${ref}${el_c_n}"
           else
               echo -e " * ref: ${el_c_r2}${ref}${el_c_n}"
           fi

        done 3<<< "$( ls -1 "${bkpdir_backups}" | grep "\.rdiff$" )"

        echo -e ""
        echo -e "To remove single entry's just enter in the dir and run: ${el_c_g}$(basename $0) ${el_c_m}remove${el_c_n}"
        echo -e "You can remove ALL in one shot with: ${el_c_g}$(basename $0) ${el_c_y}purge${el_c_n}\n"
    fi

    if ! [[ -d "$bkpdir_id" ]] ; then
        mkdir -p "$bkpdir_id"
    fi

    echo -ne "Saving..."

    #      rsync -av --delete "${target}/" "${bkpdir_id}/"
    check_files_owner_compatibility "${1}/"
    do_sudo rdiff-backup "${1}/" "${2}/"

    version="$( do_sudo rdiff-backup -l --parsable-output "$2" | wc -l )"

    echo -e "\r${el_c_g}Saved${el_c_n}  [${version}]"
    #echo -e "${el_c_g}Saved${el_c_n} $(du -hs ${2} | awk '{print $1}')"

}


do_get(){
    local version history_num

    if ! [[ -d "$bkpdir_id" ]] ; then
        echo -e "E: dir $bkpdir_id not exists, not backup saved yet ?"
        exit 1
    fi

    if [[ -n "$3" ]] ; then
        history_num="$3"
    else
        history_num="1"
    fi

    version="$( do_sudo rdiff-backup -l --parsable-output "$1" | awk '{print $1}' | tail -${history_num} | head -1 )"

    el_check_variables "version"

    do_sudo rm -rf "${1}.get"

    #check_files_owner_compatibility "${1}" # we don't need to check a dir to restore, so we have checked it at saving
    do_sudo rdiff-backup -r "$version" "${1}/" "${1}.get/"

    do_sudo rsync -av --delete "${1}.get/" "${2}/"

    cd "${2}"

}


do_list(){
    do_sudo rdiff-backup -l "${1}"
    echo ""
    do_sudo rdiff-backup --parsable-output -l "${1}"
}


do_meld(){
    local version history_num

    if ! [[ -d "$bkpdir_id" ]] ; then
        echo -e "E: dir $bkpdir_id not exists, not backup saved yet ?"
    fi

    if ! el_dependencies_check meld ; then
        if ! el_dependencies_install meld ; then
            el_error "Please install required dependencies"
        fi
    fi

    if [[ -n "$3" ]] ; then
        history_num="$3"
    else
        history_num="1"
    fi

    version="$( do_sudo rdiff-backup -l --parsable-output "$1" | awk '{print $1}' | tail -${history_num} | head -1 )"

    el_check_variables "version"

    do_sudo rm -rf "${1}.differ"
    do_sudo rdiff-backup -r "$version" "${1}/" "${1}.differ/"

    echo -e "\n\n${el_c_y}###############################################################${el_c_n}\n"

    do_sudo meld "${1}.differ/" "${2}/"

    do_sudo rm -rf "${1}.differ"

    cd "${2}"
}


do_diff(){
    local version history_num

    if ! [[ -d "$bkpdir_id" ]] ; then
        echo -e "E: dir $bkpdir_id not exists, not backup saved yet ?"
    fi

    if [[ -n "$3" ]] ; then
        history_num="$3"
    else
        history_num="1"
    fi

    version="$( do_sudo rdiff-backup -l --parsable-output "$1" | awk '{print $1}' | tail -${history_num} | head -1 )"

    el_check_variables "version"

    do_sudo rm -rf "${1}.differ"
    do_sudo rdiff-backup -r "$version" "${1}/" "${1}.differ/"

    #echo -e "\n\n${el_c_y}###############################################################${el_c_n}\n"

    diff -Naur "${1}.differ/" "${2}/" | strings | sed -e "s|--- ${1}.differ|--- a|g" -e "s|+++ ${2}|+++ b|g" | colordiff

    #if [[ -n "$( which lsdiff )" ]] ; then
        #echo -e "\n ${el_c_y}Total different files:${el_c_n} $( diff -Naur "${1}.differ/" "${2}/" | lsdiff | wc -l )"
        #diff -Naur "${1}.differ/" "${2}/" | lsdiff | sed 's|^.*rdiff\.differ/||g'
    #else
        local _different_files
        _different_files="$( diff -Naur "${1}.differ/" "${2}/" | sed -r -e "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" -e "s/\x0f//g" | grep '^\-\-\-\s' | wc -l )"
        echo -e "\n ${el_c_y}Total different files:${el_c_n} $_different_files"
        diff -Naur "${1}.differ/" "${2}/" | sed -r -e "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" -e "s/\x0f//g" | grep '^\-\-\-\s' | sed -r -e 's|^.*rdiff\.differ/||g' -e 's|([[:digit:]]{4})-([[:digit:]]{2})-([[:digit:]]{2}).*$||g'
    #fi

    do_sudo rm -rf "${1}.differ"

    cd "${2}"
}


do_diff_reverse(){
    local version history_num

    if ! [[ -d "$bkpdir_id" ]] ; then
        echo -e "E: dir $bkpdir_id not exists, not backup saved yet ?"
    fi

    if [[ -n "$3" ]] ; then
        history_num="$3"
    else
        history_num="1"
    fi

    version="$( do_sudo rdiff-backup -l --parsable-output "$1" | awk '{print $1}' | tail -${history_num} | head -1 )"

    el_check_variables "version"

    do_sudo rm -rf "${1}.differ"
    do_sudo rdiff-backup -r "$version" "${1}/" "${1}.differ/"

    #echo -e "\n\n${el_c_y}###############################################################${el_c_n}\n"

    diff -Naur "${2}/" "${1}.differ/" | strings | sed -e "s|+++ ${1}.differ|+++ a|g" -e "s|--- ${2}|--- b|g" | colordiff

    #if [[ -n "$( which lsdiff )" ]] ; then
        #echo -e "\n ${el_c_y}Total different files:${el_c_n} $( diff -Naur "${2}/" "${1}.differ/" | lsdiff | wc -l )"
        #diff -Naur "${2}/" "${1}.differ/" | lsdiff | sed 's|^.*rdiff\.differ/||g'
    #else
        local _different_files
        _different_files="$( diff -Naur "${2}/" "${1}.differ/" | sed -r -e "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" -e "s/\x0f//g" | grep '^\-\-\-\s' | wc -l )"
        echo -e "\n ${el_c_y}Total different files:${el_c_n} $_different_files"
        diff -Naur "${2}/" "${1}.differ/" | sed -r -e "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" -e "s/\x0f//g" | grep '^\-\-\-\s' | sed -r -e 's|^.*rdiff\.differ/||g' -e 's|([[:digit:]]{4})-([[:digit:]]{2})-([[:digit:]]{2}).*$||g'
    #fi

    do_sudo rm -rf "${1}.differ"

    cd "${2}"
}


do_remove(){
    if [[ -d "${1}" ]] ; then
        do_sudo rm -rf "${1}"
        do_sudo rm -rf "${1}."*

        echo -e "${el_c_r}Removed dir ${el_c_y}${1}${el_c_n}"
    else
        echo -e "${el_c_r}E: ${el_c_n}Already removed ?"
    fi
}



main(){
    # pre {{{
    local tool namedir bkpdir_id target history_num

    tool="$(basename $0)"
    namedir="${PWD//\//%}"
    if [[ -n $XDG_CACHE_HOME ]] ; then
        bkpdir_main="${XDG_CACHE_HOME}/${tool}"
    else
        bkpdir_main="${HOME}/.cache/${tool}"
    fi
    bkpdir_backups="${bkpdir_main}/backups"
    bkpdir_works="${bkpdir_main}/working"
    bkpdir_id="${bkpdir_backups}/${namedir}.rdiff"
    target="$PWD"

    # TODO: delete
    if [[ -d "${HOME}/.${tool}.backups" ]] ; then
        el_warning "you still having the old dir for backups, please remove it entirely: ${HOME}/.${tool}.backups"
    fi


    if [[ -L "$target" ]] ; then
        target="$( readlink -f "$target" )"
    fi

    # do we have automated access to sudo ? use sudo
    if el_check_sudo_automated 2>/dev/null ; then
        SUDO_MODE="sudo"
    else
        SUDO_MODE=""
    fi



    if ! el_dependencies_check "rsync,rdiff-backup,diff,colordiff" ; then
        if ! el_dependencies_install "rsync,rdiff-backup,diffutils,colordiff" ; then
            el_error "Please install required dependencies"
        fi
    fi

    el_check_variables "tool,namedir,bkpdir_id,target"
    el_check_dirs      "${target}"


    # }}}

    case $1 in
        work|w|-w)
            do_work
            ;;
        save|s|-s|--save)
            do_save "${target}" "${bkpdir_id}"
            ;;
        get|g|-g|--get)
            history_num="$2"
            do_get "${bkpdir_id}" "${target}" "$history_num"
            ;;
        list|l|-l|--list)
            do_list "${bkpdir_id}"
            ;;
        diff)
            do_diff "${bkpdir_id}" "${target}" "${history_num}"
            ;;
        diff-reverse)
            do_diff_reverse "${bkpdir_id}" "${target}" "${history_num}"
            ;;
        meld)
            do_meld "${bkpdir_id}" "${target}" "${history_num}"
            ;;
        remove|-r)
            do_remove "${bkpdir_id}"
            ;;
        forget)
            el_error "did you mean remove?"
            exit 1
            ;;
        purge)
            do_purge_olds "${bkpdir_backups}"
            ;;
    esac



}

# Usage
if [[ -z "${1}" ]] ; then
    echo -e "Usage: $(basename $BASH_SOURCE) save | get {n} | list | diff {n} | meld {n} | remove | purge | work"
    echo -e "               extra options: diff-reverse {n}"
    echo -e "  where [n] is the number of previously historied backup"
    exit 1
fi



#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
