#!/bin/bash

# gettext functions
if [[ -x "/usr/bin/gettext.sh" ]] ; then
    . gettext.sh
else
    # make it compatible
    eval_gettext(){
        echo "$@"
    }
fi

if [[ -n "$ZSH_VERSION" ]] ; then
    # Note: seems like if you put a ? just after a char, cannot be sourced correctly from zsh
    setopt nonomatch
    alias shopt=':'
    alias _expand=_bash_expand
    alias _complete=_bash_comp
    #emulate -L sh
    #setopt kshglob noshglob braceexpand

    # we cannot set parameters on this variable, so use it without icon:
    [[ -z "$guitool" ]] && guitool="/usr/bin/zenity"
else
    [[ -z "$guitool" ]] && guitool="/usr/bin/zenity --window-icon=/usr/share/icons/gnome/256x256/apps/logo-elive.png"
fi

# do we are in a terminal ? avoid interactive-in-terminal if not
if [[ -n "$TERM" ]] ; then
    if [[ "$TERM" = *rxvt* ]] || [[ "$TERM" = *xterm* ]] || [[ "$TERM" = terminology ]] || [[ "$TERM" = *gnome* ]] || [[ "$TERM" = *screen* ]] || [[ "$TERM" = *tmux* ]] ; then
        is_terminal=1
    fi
    if [[ "$TERM" = "linux" ]] ; then
        if [[ -n "$E_START" ]] ; then
            # launched from e17 itself
            is_terminal=0
        else
            is_terminal=1
            is_console=1
        fi
    fi
else
    is_terminal=0
fi

if [[ -n "$NOCOLOR" ]] || [[ -z "$LS_COLORS" ]] ; then
    el_c_n=""
    el_c_r=""
    el_c_r2=""
    el_c_g=""
    el_c_g2=""
    el_c_y=""
    el_c_y2=""
    el_c_m=""
    el_c_m2=""
    el_c_c=""
    el_c_c2=""
    el_c_b=""
    el_c_b2=""
    el_c_gr=""
    el_c_gr2=""

    el_c_blink=""
    el_c_underline=""
    el_c_italic=""
    el_c_bold=""
else
    el_c_n="\033[0;39m" # Normal color  (orig: normal)
    el_c_r="\033[1;31m" # Red color  (orig: red)
    el_c_r2="\033[0;31m" # Red2 color  (orig: red)
    el_c_g="\033[1;32m" # Green color  (orig: green)
    el_c_g2="\033[0;32m" # Green2 color  (orig. green2)
    el_c_y="\033[1;33m" # Yellow color  (orig. yellow)
    el_c_y2="\033[0;33m" # Yellow2 color  (orig. yellow)
    el_c_m="\033[1;35m" # Magenta color
    el_c_m2="\033[0;35m" # Magenta2 color
    el_c_c="\033[1;36m" # Cyan color
    el_c_c2="\033[0;36m" # Cyan2 color
    el_c_b="\033[1;34m" # Blue color
    el_c_b2="\033[0;34m" # Blue2 color

    if ((is_console)) ; then
        # gray's are not visible in console for any reason, use cyan's instead
        el_c_gr="\033[1;36m" # Gray color
        el_c_gr2="\033[0;36m" # Gray2 color
    else
        el_c_gr="\033[1;30m" # Gray color
        el_c_gr2="\033[0;30m" # Gray2 color
    fi

    el_c_blink="\033[5m" # Blink 'color' effect  (orig. blink)
    el_c_underline="\033[4m" # Underline 'color' effect  (orig. underline)
    el_c_italic="\033[3m" # Italic 'color' effect
    el_c_bold="\033[1m" # Bold 'color' effect
fi

# debug default level
if grep -qs thanatest /proc/cmdline ; then
    EL_DEBUG=${EL_DEBUG:-"3"}
else
    EL_DEBUG=${EL_DEBUG:-"0"}
fi

# extra vars
source /etc/adduser.conf
[[ -z "$DHOME" ]] && export DHOME=/home


#-------------------------------------------------------------------------------
#   Set the DISPLAY variable
#-------------------------------------------------------------------------------
el_set_display_variables(){ # Set DISPLAY variables of our actual user
    # from enlightenment values {{{
    local display e_ipc_socket

    # unset XAUTHORITY if is not from our user (bugs when we "su otheruser")
    # update: we should never unset the XAUTHORITY, verify that this was really wrong before..
    # more exactly: if we run a script from user, that sudo another script that runs a zenity, we will unset the XAUTHORITY and we will never be able to show the zenity message
    #if [[ -n "$XAUTHORITY" ]] && [[ "$XAUTHORITY" != "$HOME/"* ]] ; then
        #unset XAUTHORITY
    #fi

    # if we are in console (out of X) we should always exit
    if ((is_console)) ; then
        return
    fi

    if [[ -z "${DISPLAY}" ]] || [[ -z "${E_IPC_SOCKET}" ]] ; then
        if command ls --color=none /tmp/e-${USER}@*/*-* 1>/dev/null 2>/dev/null ; then
            display="$( command find /tmp/e-${USER}@*/*-* -mindepth 0 -maxdepth 0 -type s -print0 | xargs -r0 stat -c %y\ %n | sort -n | tail -1 2>/dev/null )"

            if [[ -z "$display" ]] ; then
                el_warning "unable to get display values from running enlightenment session"
            fi

            e_ipc_socket="${display%|*}"

            #display="${display##*disp-}"
            display="$( basename ${display} )"
            display="${display%-*}"

            if [[ -z "${DISPLAY}" ]] ; then
                DISPLAY="${display}"
                export DISPLAY
            fi

            if [[ -z "${E_IPC_SOCKET}" ]] ; then
                E_IPC_SOCKET="${e_ipc_socket}"
                export E_IPC_SOCKET
            fi
        fi

    fi
    # END from enlightenment values }}}
    # xauthority {{{
    if [[ -z "$XAUTHORITY" ]] && [[ -e "$HOME/.Xauthority" ]] ; then
        XAUTHORITY="$HOME/.Xauthority"
        export XAUTHORITY
    fi

    if ((is_terminal)) && [[ "$UID" != 0 ]] ; then
        # only show the error if we have a graphical system running by the user
        if command ls --color=none /tmp/e-${USER}@*/*-* 1>/dev/null 2>/dev/null ; then
            if [[ -z "${DISPLAY}" ]] ; then
                el_explain 1 "Variable DISPLAY is not set, so we will not have access to the local graphical system"
            fi
            if [[ -z "${XAUTHORITY}" ]] ; then
                el_explain 1 "Variable XAUTHORITY is not set, so we may not have full access to the local graphical system"
            fi
            if [[ -z "${E_IPC_SOCKET}" ]] ; then
                if [[ "$UID" != 0 ]] ; then
                    el_explain 3 "Variable E_IPC_SOCKET is not set, we may be not the user owner of this graphical session"
                fi
            fi
        fi
    fi

    # END xauthority }}}
}
#-------------------------------------------------------------------------------
#   Send a notification to the user
#-------------------------------------------------------------------------------
el_notify_user(){ # notify the user (desktop || email). "title" "text"

    el_set_display_variables

    if [[ "${DISPLAY}" = ":0.0" ]] ; then
        if el_dependencies_check notify-send ; then
            command notify-send -t 25000 "$@"
        else
            el_warning "notify-send not installed"
        fi
    fi

    if ((is_terminal)) ; then
        echo -e "${el_c_y}Info: ${el_c_c}$2${el_c_n}" 1>&2
    fi
}
#-------------------------------------------------------------------------------
#   Send an important notification to the user
#-------------------------------------------------------------------------------
el_notify_user_important(){ # notify the user (desktop || email). "title" "text" (no timeout mode)

    el_set_display_variables

    if [[ "${DISPLAY}" = ":0.0" ]] && ! ((is_terminal)) ; then
        if el_dependencies_check notify-send ; then
            command notify-send -t 240000 "$@"
        else
            el_warning "notify-send not installed"
        fi
    else
        echo -e "${el_c_y}Important: ${el_c_m}$2${el_c_n}" 1>&2
    fi

}

#-------------------------------------------------------------------------------
#   Verify if we have internet connection with a fast ping check
#-------------------------------------------------------------------------------
el_verify_internet_ping(){ # verify if we have internet connection using a ping (true or false, return value)
    # pre {{{
    local timeout
    timeout="$1"

    if [[ -z "$timeout" ]] ; then
        # default timeout if not set
        timeout=7
    fi

    # - pre }}}
    if timeout $timeout ping -c 1 www.google.com  2>/dev/null 1>&2 ; then
        return 0
    else
        # just do another small attemp, because we really want to use internet
        if [[ "$timeout" -gt 5 ]] ; then

            if timeout 1 ping -c 2 www.google.com  2>/dev/null 1>&2 ; then
                return 0
            fi
        fi

        # wanna debug more?
        if [[ "${EL_DEBUG}" -gt "2" ]] ; then
            el_debug "doing a ping to google don't respond: $( timeout 1 ping -c 1 www.google.com 2>&1 )"
            if timeout 1 ping -c 1 8.8.8.8 2>/dev/null 1>&2 ; then
                el_debug "by other side we can ping directly to an ip, please check your /etc/resolv.conf"
            else
                el_debug "we cannot even ping to the google dns (8.8.8.8)"
            fi
        fi

        # in any case if we reach here, is because we cannot ping to google, so return that
        return 1
    fi
}
#-------------------------------------------------------------------------------
#   Verify if we have internet connection (return value)
#-------------------------------------------------------------------------------
el_verify_internet(){ # verify if we have internet connection (true or false, return value)
    # pre {{{
    local stamp_hour_prev stamp_hour_prev_offline date_hour_now date_hour_prev date_hour_prev_offline returned OnLine i mode timeout

    stamp_hour_prev="/tmp/.stamps-${USER}/verify_internet-last_run_hour"
    stamp_hour_prev_offline="/tmp/.stamps-${USER}/verify_internet-last_run_hour_offline"
    mkdir -p "$(dirname "${stamp_hour_prev}" )"

    date_hour_now="$( date +%s )"
    date_hour_prev="$( tail -1 "${stamp_hour_prev}" 2>/dev/null )"
    date_hour_prev_offline="$( tail -1 "${stamp_hour_prev}" 2>/dev/null )"

    # remove extra leading blank chars
    read -r date_hour_prev <<< "$date_hour_prev"

    # note: we should not use delayed, we always want delayed, instead, we should use "fast" when we need a fast check
    mode="$1"

    if [[ "${mode}" = "fast" ]] ; then
        # bad network in house dont show anything before 4 seconds
        timeout=6
    else
        timeout=12
    fi

    # }}}

    # Test for network carrier first, and exit if we don't have it at all
    # we should have "something" connected somewhere
    unset OnLine
    #for interface in $(ls /sys/class/net/ | grep -v lo);
    for interface in /sys/class/net/*
    do
        interface="${interface##*/}"
        if [[ "${interface}" = "lo" ]] ; then
            continue
        fi

        if [[ $(cat /sys/class/net/$interface/carrier 2>/dev/null ) = 1 ]]; then
            el_debug "carrier for $interface marks that we are connected"

            OnLine=1;
            break
        fi
    done



    # cache online (20 min)
    if [[ -s "$stamp_hour_prev" ]] ; then
        if [[ "$( echo "$(date +%s) - $( stat -c %Y "${stamp_hour_prev}" )" | bc -l )" -lt 1200 ]] ; then

            # if anything tell us that we are connected and we was before, we should still be
            el_dependencies_check "route"
            if [[ -n "$OnLine" ]] || /sbin/route -n | grep -qsE "0\.0\.0\.0.*\s+UG\s+" || ip route | grep -qs "default via" ; then
                el_debug "seems like we still online, using cache + small checks"
                return 0
            fi
        fi
    fi

    # cache offline (20 min)
    if [[ -s "$stamp_hour_prev_offline" ]] ; then
        if [[ "$( echo "$(date +%s) - $( stat -c %Y "${stamp_hour_prev_offline}" )" | bc -l )" -lt 1200 ]] ; then

            # if all the other checks tell us that we really are not connected, say that we are not, in cache mode
            if el_verify_internet_ping 2 ; then
                echo "$date_hour_now" > "$stamp_hour_prev"
                el_debug "connection to internet found at ping level"
                return 0
            else
                el_debug "we was OFFline at least 20 minutes ago, ping dont answer in 2 seconds, we should still off"
                return 1
            fi
        fi
    fi

    # we have not jumped from the caches, so remove them so we will avoid the next check loops
    rm -f "$stamp_hour_prev_offline" "$stamp_hour_prev"


    # do a ping check
    if el_verify_internet_ping $timeout ; then
        echo "$date_hour_now" > "$stamp_hour_prev"
        el_debug "connection to internet found at ping level"
        return 0
    else
        if [[ "${mode}" = "fast" ]] ; then
            # we have no time for other checks, return
            return 1
        fi
    fi



    # still in fast check ? return
    if [[ "${mode}" = "fast" ]] ; then
        return 1
    fi


    # check for connection to internet using curl instead
    el_debug "let's do a last check using a curl to google"

    el_dependencies_check "curl"
    if timeout 9 curl --connect-timeout 8 www.google.com 2>/dev/null | grep -qsi 'html' ; then
        echo "$date_hour_now" > "$stamp_hour_prev"
        el_debug "connection to internet finally using curl"

        return 0
    else
        echo "$date_hour_now" > "$stamp_hour_prev_offline"
        el_debug "Connection to internet not found"

        return 1
    fi
}

#-------------------------------------------------------------------------------
#   Make ready the user's environment (bash variables, extra functions, etc)
#-------------------------------------------------------------------------------
el_make_environment(){ # make ready our environment (source variables and functions)
    if [[ -f "/etc/adduser.conf" ]] ; then
        source /etc/adduser.conf
    fi

    # set user
    if [[ -z "${USER}" ]] ; then
        USER="$(whoami)"
        export USER
    fi

    # set home
    if [[ -z "${HOME}" ]] ; then
        if [[ -n "${DHOME}" ]] ; then
            HOME="${DHOME}/$USER"
            export HOME
        else
            HOME="/home/$USER"
            export HOME
        fi
    fi

    # give display access
    el_set_display_variables

    #if [[ "$PATH" != *"$HOME/bin"* ]] ; then
        #PATH="$HOME/bin:$PATH"
    #fi

    if [[ -n "${BASH_SOURCE}" ]] ; then
        #export PS4='+ ($(basename ${BASH_SOURCE}):${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}():  }'
        #export PS4='+ [$(basename ${BASH_SOURCE})|${FUNCNAME[0]:+${FUNCNAME[0]}}|${LINENO}]  '
        export PS4='+ [$(basename ${BASH_SOURCE} 2>/dev/null )  ${FUNCNAME[0]:+${FUNCNAME[0]}} ${LINENO}]  '
    fi

}

#-------------------------------------------------------------------------------
#   Title Set: sets the title of a window
#-------------------------------------------------------------------------------
el_title_set(){ # set the Title on the actual Window

    el_set_display_variables
    echo -ne '\033]0;'$@'\007'

}

#-------------------------------------------------------------------------------
#   Resolutions, get the resolution values
#-------------------------------------------------------------------------------
el_resolution_get(){ # show our actual resolution

    el_dependencies_check xdpyinfo
    el_set_display_variables

    xdpyinfo | grep dimension | awk '{print $2}' | grep x | tail -1

}

#-------------------------------------------------------------------------------
#   Dependencies Check
#-------------------------------------------------------------------------------
el_check_dependencies(){
    # compatibility
    el_warning "$FUNCNAME is moved to 'el_dependencies_check', please update or report this code (full compatibility still working, don't worry)"
    el_dependencies_check "$@"
}
el_dependencies_check(){ # check if we have these command dependencies, if not, notify and exit
    # example:  el_dependencies_check gmplayer,find,sed,etc
    local check found found_no dir

    while read -ru 3 check
    do
        unset found

        for dir in $(echo ${PATH}:/usr/local/sbin:/usr/sbin:/sbin | tr ':' ' ')
        do
            if test -x ${dir}/$check
            then
                found=yes
                break
            fi
        done

        if [[ "$found" != "yes" ]] ; then
            #el_notify_user "Command Not Found" "Error: command '$check' for $(basename $0) not found"
            el_error "Command '$check' for $(basename $0) not found, func: ${FUNCNAME[1]}"
            found_no="yes"
        fi

    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        return 1
    else

        return 0
    fi

}


#-------------------------------------------------------------------------------
#   Install required packages
#-------------------------------------------------------------------------------
el_dependencies_install(){
    local depends temp
    depends="$( echo "$@" | tr ',' ' ' )"
    el_set_display_variables

    # TODO: move to terminology when compatibility will be implemented
    # TODO:  even better: use a gui tool for install deps
    el_dependencies_check urxvt

    temp="/tmp/.$(basename $0)-${USER}-$$"
    cat > "${temp}" << EOF
#!/bin/bash

urxvt -T 'Installing Packages' -e bash -c "source /usr/lib/elive-tools/functions ; el_aptget_update ; apt-get -f install ; echo ; echo ; if ! apt-get install -y $depends ; then el_aptget_update force ; if ! apt-get install -y $depends ; then apt-get -f install ; el_aptget_update force ; apt-get install $depends ; fi ; fi ; echo ; echo ; echo ; echo ; echo 'All Done' ; sleep 2 "

EOF

    chmod +x "${temp}"
    if [[ "$UID" = 0 ]] ; then
        bash "$temp"
    else
        if el_check_sudo_automated ; then
            for i in 1 2 3
            do
                if sudo -H bash "$temp" ; then
                    is_password_ok=1
                    break
                fi
            done
    else
        if ! el_dependencies_check gksu ; then
            urxvt -e bash -c "su -c 'apt-get update' root"
            urxvt -e bash -c "su -c 'apt-get install -y gksu' root"
        fi

        # multiple gksu attempts
        for i in 1 2 3
        do
            if gksu "$temp" ; then
                is_password_ok=1
                break
            fi
        done
        fi

        if ! ((is_password_ok)) && [[ -n "$DISPLAY" ]] ; then
            $guitool --error
        fi
    fi
    rm -f "${temp}"

}

#-------------------------------------------------------------------------------
#   Run apt-get update
#-------------------------------------------------------------------------------
el_aptget_update(){
    local message_updating force want_update
    force="$1"

    el_set_display_variables


    if [[ "$force" = "force" ]] ; then
        want_update=1
    fi

    if [[ -e "/var/lib/apt/periodic/update-success-stamp" ]] ; then
        if [[ "$( echo "$(date +%s) - $( stat -c %Y /var/lib/apt/periodic/update-success-stamp )" | bc -l )" -gt 14400 ]] ; then
            want_update=1
        fi
    else
        want_update=1
    fi

    if ((want_update)) ; then
        # only run update if we have not updated already 4 hours ago
        message_updating="$( printf "$( TEXTDOMAIN="elive-tools" eval_gettext "Updating list of packages" )" )"

        if ! el_verify_internet 2>/dev/null 1>&2 ; then
            el_error "We need to update the packages lists but we don't have internet? continuing anyways..."
        fi

        if [[ "$UID" = 0 ]] ; then
            if [[ -n "$DISPLAY" ]] ; then
                { apt-get update || apt-get update ; } | $guitool --progress --pulsate --percentage=0 --auto-close --text="$message_updating"
            else
                apt-get update || apt-get update
            fi
        else
            if el_check_sudo_automated ; then
                if [[ -n "$DISPLAY" ]] ; then
                    { sudo apt-get update || sudo apt-get update ; } | $guitool --progress --pulsate --percentage=0 --auto-close --text="$message_updating"
                else
                    sudo apt-get update || sudo apt-get update
                fi
            else
                if [[ -n "$DISPLAY" ]] ; then
                    if ! el_dependencies_check gksu ; then
                        el_dependencies_install "gksu"
                    fi
                    #gksu apt-get update | $guitool --progress --pulsate --percentage=0 --auto-close --text="$message_updating"
                    # multiple gksu attempts
                    for i in 1 2 3
                    do
                        if gksu "$temp" ; then
                            if gksu apt-get update | $guitool --progress --pulsate --percentage=0 --auto-close --text="$message_updating" ; then
                                is_password_ok=1
                                break
                            fi
                        fi
                    done

                    if ! ((is_password_ok)) && [[ -n "$DISPLAY" ]] ; then
                        $guitool --error
                    fi

                else
                    su -c "apt-get update || apt-get update" root
                fi
            fi
        fi

    else
        el_explain 2 "Packages lists already updated at least 4 hours ago, skipping update"
    fi
}
#-------------------------------------------------------------------------------
#   Check if a newer version of a package exists
#-------------------------------------------------------------------------------
el_package_newer_check(){
    local package installed candidate

    package="$1"

    if [[ -z "$package" ]] ; then
        return 2
    fi

    installed="$( LC_ALL=C apt-cache policy "$package" | grep "Installed:" | sed -e 's|^.*Installed: ||g' | head -1 | grep -E "^[[:digit:]]*" )"
    read -r installed <<< "$installed"

    candidate="$( LC_ALL=C apt-cache policy "$package" | grep "Candidate:" | sed -e 's|^.*Candidate: ||g' | head -1 | grep -E "^[[:digit:]]*" )"
    read -r candidate <<< "$candidate"


    if [[ -n "$installed" ]] && [[ -n "$candidate" ]] ; then
        if dpkg --compare-versions "${candidate}" gt "${installed}" ; then
            return 0
        else
            return 1
        fi
    else
        el_error "no versions get correctly for package ${package}, installed is '${installed}', candidate is '${candidate}', func: ${FUNCNAME[1]}"
        return 1
    fi
}

#-------------------------------------------------------------------------------
#   Check if variable exists
#-------------------------------------------------------------------------------
el_check_variables(){ # check if we have set these variables, if not, notify and exit
    # example $0 foo,bar,we
    local found_no var

    while read -ru 3 var
    do
        if [[ -n "$ZSH_VERSION" ]] ; then
            if [[ ! -n "${(P)var}" ]] ; then
                el_error "Variable '$var' is not set, func: ${FUNCNAME[1]}"
                found_no="yes"
            fi
        else
            if [[ ! -n "${!var}" ]] ; then
                el_error "Variable '$var' is not set, func: ${FUNCNAME[1]}"
                found_no="yes"
            fi
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        return 1
    else

        return 0
    fi

}


#-------------------------------------------------------------------------------
#   Check if files exists
#-------------------------------------------------------------------------------
el_check_files(){ # check if we have these files (and non-zero), if not, notify and exit
    # example $0 foo,bar,we
    local var found_no

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)"

        return 1
    fi

    while read -ru 3 var
    do
        if [[ ! -s "${var}" ]] ; then
            #el_notify_user "E: File not exists" "E: the file '$var' not exists"
            el_error "File '$var' not exist, func: ${FUNCNAME[1]}"
            found_no="yes"
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        return 1
    else

        return 0
    fi

}


#-------------------------------------------------------------------------------
#   Check if dir exists
#-------------------------------------------------------------------------------
el_check_dirs(){ # check if we have these dirs (and non-zero), if not, notify and exit
    # example $0 foo,bar,we
    local var found_no

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)" 1>&2

        return 1
    fi

    while read -ru 3 var
    do
        if [[ ! -d "${var}" ]] ; then
            #el_notify_user "E: Dir not exists" "E: the dir '$var' not exist"
            el_error "Directory '$var' not exist, func: ${FUNCNAME[1]}"
            found_no="yes"
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then

        return 1
    else

        return 0
    fi

}


#-------------------------------------------------------------------------------
#   check if dir has files
#-------------------------------------------------------------------------------
el_check_dir_has_files(){
    local dir f

    while read -ru 3 dir
    do
        if [[ -z "$1" ]] ; then
            echo -e "E: $FUNCNAME called without parameters (nothing to check?)"

            return 1
        fi

        if [[ ! -d "$dir" ]] && [[ ! -L "$dir" ]] ; then
            #el_notify_user "Dir not exist" "$dir"
            el_error "Directory '$dir' not exist, func: ${FUNCNAME[1]}"

            return 1
        else
            if [[ $SHELL = *bash ]] ; then
                if (shopt -s nullglob dotglob; f=(*); ((! ${#f[@]}))) 2>/dev/null 1>/dev/null ; then
                    el_error "Directory '$dir' doesn't contain any file, func: ${FUNCNAME[1]}"

                    return 1
                fi
            else
                if ! command ls "${dir}/"*  2>/dev/null 1>/dev/null ; then
                    el_error "Directory '$dir' doesn't contain any file, func: ${FUNCNAME[1]}"

                    return 1
                fi
            fi
        fi
    done 3<<< "$( echo "$@" | tr ',' '\n' )"

}

#-------------------------------------------------------------------------------
#   check if we have automatic sudo
#-------------------------------------------------------------------------------
el_check_sudo_automated(){

    if ! sudo -H -n echo 2>/dev/null 1>/dev/null ; then
        #el_notify_user "Automated sudo is required" "Your sudo requires a password, we need it to be configured for not request it"
        el_error "Automated sudo is required: Your sudo requires a password, we need it to be configured for not request it, func: ${FUNCNAME[1]}"

        return 1
    else

        return 0
    fi

}
#===  FUNCTION  ================================================================
#          NAME:  el_sudo
#   DESCRIPTION:  run a command from root, as much as possible
#    PARAMETERS:  args/command
#       RETURNS:  -
#===============================================================================
el_sudo(){
    # pre {{{
    local args
    el_security_function_loop || return

    args="$@"
    el_check_variables "args"

    el_set_display_variables

    # }}}
    if el_check_sudo_automated 2>/dev/null 1>&2 ; then
        sudo -H "$@"
    else
        if [[ -n "$DISPLAY" ]] ; then
            if ! el_dependencies_check gksu ; then
                el_dependencies_install "gksu"
            fi

            # multiple gksu attempts
            for i in 1 2 3
            do
                if gksu "$@" ; then
                    is_password_ok=1
                    break
                fi
            done

            if ! ((is_password_ok)) && [[ -n "$DISPLAY" ]] ; then
                $guitool --error
            fi
        else
            su -c "$@" root
        fi
    fi

}
#===  FUNCTION  ================================================================
#          NAME:  el_check_translations_required_notify
#   DESCRIPTION:  check the amount of translations made for actual application,
#		  telling the user that he can help improving them
#    PARAMETERS:  -
#===============================================================================
el_check_translations_required_notify(){
    # pre {{{
    local textdomaindir stat percentage_untranslated is_translation_required


    if [[ -n "$TEXTDOMAINDIR" ]] ; then
        textdomaindir="$TEXTDOMAINDIR"
    else
        textdomaindir="/usr/share/locale"
    fi

    # dont annoy users in the stable released
    if ! el_check_version_development ; then
        return
    fi

    # }}}

    if [[ -n "$TEXTDOMAIN" ]] ; then
        # we already said it ?
        if el_flag check "translation_required_${TEXTDOMAIN}" ; then
            return
        fi
        el_flag add "translation_required_${TEXTDOMAIN}"

        # deprecated location
        #stat="${textdomaindir}/${LANG%%_*}/statistics/${TEXTDOMAIN}.txt"
        stat="/var/cache/elive-translations/statistics/${LANG%%_*}/${TEXTDOMAIN}.txt"

        if [[ -s "${stat}" ]] ; then
            percentage_untranslated="$(cat "${stat}" | grep messages_untranslated_percentage | awk '{print $2}' | tail -1 )"

            if [[ -n "${percentage_untranslated}" ]] && [[ "${percentage_untranslated}" -gt 20 ]] ; then
                is_translation_required=1
            else
                return
            fi
        fi
    fi

    if ((is_translation_required)) ; then
        el_notify_user "Translations Improvements" "This application is not fully translated to your language, you can help us translating Elive directly from the 'eltrans' application.\n\nThank you"
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  el_check_version_development
#   DESCRIPTION:  checks if we are in a development version
#    PARAMETERS:  -
#       RETURNS:  true if we are development state, false if we are stable
#===============================================================================
el_check_version_development(){
    if [[ -e "/etc/elive-version" ]] ; then
        if [[ "$( grep stable-release /etc/elive-version | awk '{print $2}' )" = yes ]] ; then
            return 1
        else
            return 0
        fi
    else
        el_error "File /etc/elive-version not found, func: ${FUNCNAME[1]}"
        return 0
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_elive_version_get
#   DESCRIPTION:  Get the version number of the HOST (installed) elive system
#    PARAMETERS:  -
#       RETURNS:  version number
#===============================================================================
el_elive_version_get(){
    # pre {{{
    local version
    el_debug
    el_security_function_loop || return

    # }}}
    version="$(cat "/etc/elive-version" | grep elive-version | sed 's/^.*version:\ //' )"

    if [[ -n "$version" ]] ; then
        echo "$version"
    else
        el_error "Unable to get this version of Elive ID number"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_check_version_development_is_days_recent
#   DESCRIPTION:  check if this development version is less than $1 ~days old
#    PARAMETERS:  $1 = days old to check
#       RETURNS:  true if is less than $1 old, false if we are older than it
#===============================================================================
el_check_version_development_is_days_recent(){
    # pre {{{
    local date_builded_y date_builded_m date_builded_d date_today_y date_today_m date_today_d days_required date_builded date_today date_builded_total_days days_difference
    el_debug
    el_security_function_loop || return

    days_required="$1"

    if ! el_check_version_development ; then
        # stable versions should be not considered recent dev versions
        return 1
    fi

    # }}}

    # calculate date builded {{{

    date_builded="$( grep date-builded /etc/elive-version | sed -e 's|date-builded: ||g' )"

    date_builded_y="${date_builded%%-*}"

    date_builded_m="${date_builded%-*}"
    date_builded_m="${date_builded_m#*-}"
    date_builded_m="${date_builded_m#0}"

    date_builded_d="${date_builded##*-}"
    date_builded_d="${date_builded_d#0}"

    date_builded_total_days="$(( ${date_builded_m} * 30 + ${date_builded_d} ))"
    date_builded_total_days="$(( ${date_builded_y} * 365 + ${date_builded_total_days} ))"

    # - calculate date builded }}}
    # calculate date today {{{

    date_today="$( date +%F )"

    date_today_y="${date_today%%-*}"

    date_today_m="${date_today%-*}"
    date_today_m="${date_today_m#*-}"
    date_today_m="${date_today_m#0}"

    date_today_d="${date_today##*-}"
    date_today_d="${date_today_d#0}"

    date_today_total_days="$(( ${date_today_m} * 30 + ${date_today_d} ))"
    date_today_total_days="$(( ${date_today_y} * 365 + ${date_today_total_days} ))"

    # - calculate date today }}}
    el_check_variables "date_builded,date_today,date_builded_total_days,date_today_total_days"
    days_difference="$(( ${date_today_total_days} - ${date_builded_total_days} ))"

    if [[ "$days_difference" -le "$days_required" ]] ; then
        return 0
    else
        return 1
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_explain
#   DESCRIPTION:  function to show the progress of the application
#    PARAMETERS:
# verbose_level:    $1 = any number, from $EL_DEBUG levels
#                        levels: 0 = always|error, 1 = warning, 2 = info, 3 = debug
#       message:    $2 = can include: __hilight words__, XXsuper hilightXX
#===============================================================================
el_explain(){
    # pre {{{
    if ! ((is_terminal)) ; then
        return
    fi
    local funclevel spaced verbose_level message trace_message trace_col

    verbose_level="$1"
    shift
    message="$@"

    #spaced="$verbose_level"
    funclevel="$(( ${#FUNCNAME[*]} - 2 ))"

    el_check_variables "verbose_level,message"
    # }}}
    # tabulate output {{{
    #while [[ $spaced -gt 0 ]] ; do
        #message="  $message"
        #spaced="$(( $spaced - 1 ))"
    #done

    # }}}
    # hilight words {{{
    message="${message/__/${el_c_b}}"
    message="${message/__/${el_c_gr}}"
    message="${message/__/${el_c_b}}"
    message="${message/__/${el_c_gr}}"
    message="${message/__/${el_c_b}}"
    message="${message/__/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    # }}}
    # show {{{
    # this is a good example of levels of colors visualization for the user's eye

    # show only if we are on this verbose level
    if [[ "${EL_DEBUG}" -ge "$verbose_level" ]] ; then

        # show normal message unless we are at a debugging level
        if [[ "${EL_DEBUG}" -ge 3 ]] ; then
            case $funclevel in
                1)
                    echo -en " ${el_c_gr}[${el_c_b2}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                2)
                    echo -en " ${el_c_gr}[${el_c_b}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                3)
                    echo -en " ${el_c_gr}[${el_c_c2}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                4)
                    echo -en " ${el_c_gr}[${el_c_c}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                5)
                    echo -en " ${el_c_gr}[${el_c_g2}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                6)
                    echo -en " ${el_c_gr}[${el_c_g}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                7)
                    echo -en " ${el_c_gr}[${el_c_y2}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                8)
                    echo -en " ${el_c_gr}[${el_c_y}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                9)
                    echo -en " ${el_c_gr}[${el_c_r2}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                10)
                    echo -en " ${el_c_gr}[${el_c_r}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                11)
                    echo -en " ${el_c_gr}[${el_c_m2}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
                *)
                    echo -en " ${el_c_gr}[${el_c_m}${verbose_level}${el_c_gr}] " 1>&2
                    ;;
            esac
        else
            echo -en "${el_c_gr}  " 1>&2
        fi

        # continuation of the message
        echo -e "${message}${el_c_n}" 1>&2

    fi

    # }}}
}
#===  FUNCTION  ================================================================
#          NAME:  el_debug
#   DESCRIPTION:  show debug messages | EL_DEBUG -ge 3|4
#    PARAMETERS:  optional (message)
#===============================================================================
el_debug(){
    # pre {{{
    if ! ((is_terminal)) ; then
        return
    fi
    # }}}
    # debug {{{
    local funclevel

    funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
    funclevel="$funclevels"

    # level 3 is debug
    if [[ "${EL_DEBUG}" -ge 3 ]] ; then
        if [[ -n "$1" ]] ; then
            echo -e "${el_c_gr}D:     ${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO} ${el_c_c}$@${el_c_n}" 1>&2
        else
            # function showing only
            # show {{{

            case $funclevel in
                1)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_b2}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                2)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_b}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                3)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_c2}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                4)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_c}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                5)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_g2}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                6)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_g}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                7)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_y2}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                8)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_y}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                9)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_r2}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                10)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_r}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                11)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_m2}${funclevel}${el_c_gr}] " 1>&2
                    ;;
                *)
                    echo -en "${el_c_gr}F: ${el_c_gr}[${el_c_m}${funclevel}${el_c_gr}] " 1>&2
                    ;;
            esac

            # continuation of the message
            echo -e "${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO} ${el_c_c}$@${el_c_n}" 1>&2

            # }}}
        fi


    fi

    # more debug, show function-call array
    if [[ "${EL_DEBUG}" -ge 4 ]] ; then
        # show the array of calls
        funclevel="${funclevels}"
        echo -en "${el_c_gr}calls:" 1>&2
        while [[ $funclevel -gt 0 ]] ; do
            echo -en " -> ${FUNCNAME[$funclevel]}" 1>&2
            funclevel="$(( $funclevel - 1 ))"
        done
        echo -e "${el_c_n}" 1>&2
    fi

    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_info
#   DESCRIPTION:  show info messages | (always)
#    PARAMETERS:  message
#===============================================================================
el_info(){
    # pre {{{
    if ! ((is_terminal)) ; then
        return
    fi
    # }}}
    # warning {{{

    if [[ -n "$1" ]] ; then
        # note: info messages are not errors so we don't want them in the stderr
        if [[ "${EL_DEBUG}" -ge 3 ]] ; then
            echo -e "${el_c_c}[${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO}${el_c_c}] ${el_c_c}$@${el_c_n}" # 1>&2
        else
            echo -e "${el_c_c}$@${el_c_n}" # 1>&2
        fi
    fi

    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_warning
#   DESCRIPTION:  show warning messages | EL_DEBUG -ge 1
#    PARAMETERS:  optional (message)
#===============================================================================
el_warning(){
    # pre {{{
    if ! ((is_terminal)) ; then
        return
    fi
    # }}}
    # warning {{{

    if [[ "${EL_DEBUG}" -ge 1 ]] ; then
        if ((is_terminal)) ; then
            if [[ "${EL_DEBUG}" -ge 3 ]] ; then
                echo -e "${el_c_y}Warning: ${el_c_c}[${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO}${el_c_c}] ${el_c_c}$@${el_c_n}" 1>&2
            else
                echo -e "${el_c_y}Warning: ${el_c_c}$@${el_c_n}" 1>&2
            fi
        else
            if [[ "$DISPLAY" = ":0.0" ]] && el_check_version_development ; then
                $guitool --warning "$@"
            fi
        fi
    fi

    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_error
#   DESCRIPTION:  show error messages | EL_DEBUG -ge 0
#    PARAMETERS:  optional (message)
#===============================================================================
el_error(){
    # pre {{{
    if ! ((is_terminal)) ; then
        return
    fi
    # }}}
    # error {{{

    if [[ "${EL_DEBUG}" -ge 0 ]] ; then
        if ((is_terminal)) ; then
            if [[ "${EL_DEBUG}" -ge 3 ]] ; then
                echo -e "${el_c_r}Error: ${el_c_c}[${el_c_b2}${FUNCNAME[1]}${el_c_c}:${el_c_b2}${BASH_LINENO}${el_c_c}] ${el_c_c}$@${el_c_n}" 1>&2
            else
                echo -e "${el_c_r}Error: ${el_c_c}$@${el_c_n}" 1>&2
            fi
        else
            if [[ "$DISPLAY" = ":0.0" ]] && el_check_version_development ; then
                $guitool --error "$@"
            fi
        fi
    fi

    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_group_check
#   DESCRIPTION:  check if user is already on a specific group
#    PARAMETERS:  $1 = groupname
#===============================================================================
el_group_check(){
    # pre {{{
    local group

    group="${1}"

    el_check_variables "group"

    # }}}

    if [[ " $(id -Gn "$USER") " = *" $group "* ]] ; then

        return 0
    else

        return 1
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  el_group_add
#   DESCRIPTION:  verify and add an user to a group
#    PARAMETERS:  $1 = group to add
#===============================================================================
el_group_add(){
    # pre {{{
    local group

    group="$1"

    el_check_variables "group"

    # }}}
    if ! el_group_check "${group}" ; then
        if ! el_dependencies_check gksu ; then
            el_dependencies_install "gksu"
        fi
        # multiple gksu attempts
        for i in 1 2 3
        do
            if gksu "adduser $USER $group" ; then
                is_password_ok=1
                break
            fi
        done

        if ! ((is_password_ok)) && [[ -n "$DISPLAY" ]] ; then
            $guitool --error --text="$( eval_gettext "Wrong password" )"
        fi


        # try again if not reached
        if ! el_group_check "${group}" ; then
            if ! el_dependencies_check gksu ; then
                el_dependencies_install "gksu"
            fi
            # multiple gksu attempts
            for i in 1 2 3
            do
                if gksu "adduser $USER $group" ; then
                    is_password_ok=1
                    break
                fi
            done

            if ! ((is_password_ok)) && [[ -n "$DISPLAY" ]] ; then
                $guitool --error
            fi
        fi

        # inform that a reboot is needed
        if el_group_check "$group" ; then
            el_notify_user "Your user is now added to the new group ${group}, please reboot your computer for use it correctly"
        fi
    fi


}

#===  FUNCTION  ================================================================
#          NAME:  el_confirm
#   DESCRIPTION:  ask (console) for confirmation
#    PARAMETERS:  question
#       RETURNS:  true | false
#===============================================================================
el_confirm(){
    # pre {{{
    local reply question flag_glob

    if [[ -n "$BASH_VERSION" ]] ; then
        if shopt extglob | grep -q "extglob.*off" ; then
            flag_glob=1
        fi

        shopt -s extglob
    fi
    question="$1"

    el_check_variables "question"


    # }}}
    # return answer {{{
    if ((is_terminal)) ; then
        echo -en "$question [y/n]: "
        if [[ -n $ZSH_VERSION ]] ; then
            read reply
        else
            read -e reply
        fi

        case $reply in
            y|Y|Yes|YES|s|S)
                return  0
                ;;
            n|N|no|NO|nope)
                return  1
                ;;
            *)
                # repeat question until confirmation
                if el_confirm "$@" ; then
                    return 0
                else
                    return 1
                fi
                ;;
        esac
    else
        el_set_display_variables

        if [[ -n "$DISPLAY" ]] ; then
            if $guitool --question --text="$question" ; then
                return 0
            else
                return 1
            fi
        fi
    fi

    if ((flag_glob)) ; then
        shopt -u extglob
    fi

    # }}}

}

#===  FUNCTION  ================================================================
#          NAME:  el_security_function_loop
#   DESCRIPTION:  check for a possible infinite-loops, needs to be called as:
#                 el_security_function_loop || return
#                 from every function of your scripts
#    PARAMETERS:  $1 = number of recursivity's allowed
#       RETURNS:  1 if found a loop, 0 if not
#===============================================================================
el_security_function_loop(){
    # pre {{{
    local funclevels funclevel count_recursive recursives_allowed is_loop_infinite is_loop_predetected

    # }}}
    # high value of count_recursive if we call a function recursively multiple times
    if [[ -n "$1" ]] ; then
        recursives_allowed="$1"
    fi

    funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
    funclevel="${funclevels}"

    if [[ -n "$recursives_allowed" ]] ; then
        count_recursive="$(( 1 + $recursives_allowed ))"
    else
        count_recursive="4"
    fi


    # walk around our parent functions
    while [[ $funclevel -gt 0 ]] ; do
        # ignore the last check, which is of course the same name
        if [[ "${count_recursive}" -lt "$funclevels" ]] ; then
            # check if we already come from our function-name in our parents
            if [[ "${FUNCNAME[$funclevel]}" = "${FUNCNAME[1]}" ]] ; then
                if ((is_loop_predetected)) ; then
                    # already entered loop, we should break the loop and continue gracefully
                    is_loop_infinite=1
                else
                    # give at least a chance to the infinite-loop, but we shouldn't
                    is_loop_predetected=1
                fi
            fi
        fi


        funclevel="$(( $funclevel - 1 ))"
        count_recursive="$(( $count_recursive + 1 ))"
    done


    # do action for our resulting checks
    if ((is_loop_predetected)) ; then
        if ((is_loop_infinite)) ; then
            # note: we set it as a warning instead of error because it is really a way that solves errors making the application working, at least for "smart" applications (no linear procedure but a set of tasks and where the application is meant to know what to do)
            if [[ "${EL_DEBUG}" -ge "1" ]] ; then
                el_warning "Entered in an Infinite Loop, let's jump it"
                el_explain 1 "__Note:__ Declarative programming requires this feature for work correctly, in short, if the application works correctly then everything is fine."

                # show the array of calls
                funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
                funclevel="${funclevels}"
                echo -en "${el_c_b}calls:${el_c_gr}" 1>&2
                while [[ $funclevel -gt 0 ]] ; do
                    echo -en " -> ${FUNCNAME[$funclevel]}" 1>&2
                    funclevel="$(( $funclevel - 1 ))"
                done
                echo -e "${el_c_n}" 1>&2
            fi

            return 1
        else
            if [[ "${EL_DEBUG}" -ge "2" ]] ; then
                if [[ -z "$recursives_allowed" ]] ; then
                    el_warning "Detected a possible infinite loop"
                fi

                # show the array of calls
                funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
                funclevel="${funclevels}"
                echo -en "${el_c_gr}calls:" 1>&2
                while [[ $funclevel -gt 0 ]] ; do
                    echo -en " -> ${FUNCNAME[$funclevel]}" 1>&2
                    funclevel="$(( $funclevel - 1 ))"
                done
                echo -e "${el_c_n}" 1>&2
            fi
        fi
    fi


}

#===  FUNCTION  ================================================================
#          NAME:  el_array_member_check
#   DESCRIPTION:  check if an element exists in an array
#    PARAMETERS:  $1 = match, $2 = array (list of words)
#       RETURNS:  true if found, false if not
#===============================================================================
el_array_member_check(){
    local match list i
    match="$1"
    shift
    list=("$@")

    if [[ -n $ZSH_VERSION ]] ; then
        for i in "${(P)list[@]}"
        do
            if [[ "${list[i]}" = "$match" ]] ; then
                return 0
            fi
        done
    else
        for i in "${!list[@]}"
        do
            if [[ "${list[i]}" = "$match" ]] ; then
                return 0
            fi
        done
    fi

    return 1
}

#===  FUNCTION  ================================================================
#          NAME:  el_array_member_unset
#   DESCRIPTION:  unset members in an array
#    PARAMETERS:  $1 = match, $2 = array contents
#                 XXX needs to be used later with!:  arr=("${_out[@]}")
#===============================================================================
el_array_member_unset(){
    _out=()
    local i item=$1
    shift

    for i in "$@"; do
        if [[ $item != "$i" ]]; then
            _out+=("$i")
        fi
    done

    # note: this is a bit hacky but it works until newer versions of bash, the common alternative is: for i in "${!list_requires_update[@]}"; do [[ ${list_requires_update[i]} = "$package" ]] && unset 'list_requires_update[i]'; done
}

#===  FUNCTION  ================================================================
#          NAME:  el_array_member_add
#   DESCRIPTION:  add a member in the array if not exist
#    PARAMETERS:  $1 = element, $2 = array contents
#                 XXX needs to be used later with!:  arr=("${_out[@]}")
#===============================================================================
el_array_member_add(){
    _out=()
    local i item=$1 match
    shift


    for i in "$@"; do
        if [[ $item = "$i" ]]; then
            match=1
        fi

        # add elements to the new array
        _out+=("$i")
    done

    if ! ((match)) ; then
        _out+=("$item")
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_step_requires_fixme
#   DESCRIPTION:  temporal "step" to put in experimental/development code, only
#    PARAMETERS:  $1 = dir to login (optional)
#		  $2 = message (optional)
#===============================================================================
el_step_requires_fixme(){
    # pre {{{
    local dir prev_dir

    dir="$1"
    shift
    message="$1"
    shift

    prev_dir="$(pwd)"

    : ${dir:="$prev_dir"}

    el_set_display_variables

    # }}}
    el_check_dirs "${dir}"
    cd "$dir"

    if ((is_terminal)) ; then
        echo -e "\n"
        el_warning "Experimental or uncomplete code:"
        echo -e "We have set a breakpoint here, please report to Elive this message if needed:"
        echo -e "${FUNCNAME} for $0"
        echo -e "Function: ${FUNCNAME[1]}  |  Line: $LINENO"
        if [[ -n "$message" ]] ; then
            el_explain 0 "message: XX${message}XX"
            echo -e ""
        fi
        echo -e "$(tput setaf 3)$(tput blink)New SHELL Started$(tput op)"
        el_explain 0 "Type '__exit__' for continue..."
        $SHELL -l
    else
        cd "${prev_dir}"
        el_set_display_variables
        $guitool --warning --text="$( TEXTDOMAIN="elive-tools" eval_gettext "Experimental or uncomplete code found, report this if you found it neccessary. Exiting..." )"
        exit 1
    fi

    cd "${prev_dir}"

}

#===  FUNCTION  ================================================================
#          NAME:  el_flag
#   DESCRIPTION:  control states with marks and locks
#    PARAMETERS:  $2 = action (add|del|check), $3 = name
#       RETURNS:  true or false for check actions
#===============================================================================
el_flag(){
    # pre {{{
    local action name
    el_security_function_loop || return

    action="${1}"
    name="${2}"

    #el_debug "$action - $name"

    TMP_FLAGS_d="${TMP_FLAGS_d:-"/tmp/.$(basename $0)-flags-$USER"}"

    if [[ ! -d "${TMP_FLAGS_d}" ]] ; then
        mkdir -p "$TMP_FLAGS_d"
    fi

    el_check_variables "action,name"

    # }}}
    case $action in
        add|set|put)
            el_explain 2 "added $name flag"
            touch "${TMP_FLAGS_d}/$name"
            ;;
        del|remove|delete|rm)
            rm -f "${TMP_FLAGS_d}/$name"

            if ! el_check_dir_has_files "${TMP_FLAGS_d}" 2>/dev/null ; then
                rmdir "${TMP_FLAGS_d}"
            fi
            el_debug "removed flag $name"
            ;;
        check|test|verify)
            if [[ -e "${TMP_FLAGS_d}/$name" ]]; then
                el_debug "$action $name -> [flag found]"
                return 0
            else
                el_debug "$action $name -> [no flag]"
                return 1
            fi
            ;;
        *)
            el_error "unkown action ${action}, func: ${FUNCNAME[1]}"
            ;;
    esac

}

#===  FUNCTION  ================================================================
#          NAME:  el_add_on_exit
#   DESCRIPTION:  add commands that will be run on exit of the application
#    PARAMETERS:  command to run
#       RETURNS:  -
#===============================================================================
el_add_on_exit(){
    if [[ -z "$1" ]] ; then
        return
    fi
    local n=${#on_exit_items[*]}
    on_exit_items[$n]="$*"

    # add the trap if is not added
    if [[ $n -eq 0 ]]; then
        #echo "Setting trap"
        trap on_exit EXIT
    fi
}
on_exit(){
    local i
    # create empty variable of array type if not exist
    if [[ -z "$on_exit_items" ]] ; then
        declare -a on_exit_items
    fi

    # run each appended command
    for i in "${on_exit_items[@]}"
    do
        #echo "on_exit: $i"
        eval $i
    done
}

#===  FUNCTION  ================================================================
#          NAME:  el_request_report_bug
#   DESCRIPTION:  Request the user to report a bug
#    PARAMETERS:  Message to tell to the user (optional)
#       RETURNS:  -
#===============================================================================
el_request_report_bug(){
    # pre {{{
    local message url
    el_debug
    el_security_function_loop || return

    message="$@"
    el_check_variables "message"

    el_set_display_variables

    # }}}
    # task list sorted by created time
    url='http://bugs.elivecd.org/index.php?do=index&project=2&project=2&do=index&order=dateopened&sort=desc'
    # check if we should ignore this function
    if el_check_version_development_is_days_recent 30 ; then

        if [[ -n "$DISPLAY" ]] ; then
            local message_report_bug
            message_report_bug="$( printf "$( TEXTDOMAIN="elive-tools" eval_gettext "We found something that we want to be informed about its details, it may be a problem in Elive or a simple state that we want to know, since it happened to you it can happen to anybody and we want to make Elive as much stable as possible, please take 1 minute to report this message to our developers:<b>\n\n%s\n\n(file: %s, function: %s, line: %s)</b>\n\nCan you please send us now about your recent problem found ?" )" "$message" "${BASH_SOURCE[1]}" "${FUNCNAME[1]}" "$BASH_LINENO" )"

            if $guitool --question --text="$message_report_bug" ; then
                if [[ -x /usr/bin/firefox ]] ; then
                    firefox "$url" &
                fi
                if [[ -x /usr/bin/iceweasel ]] ; then
                    iceweasel "$url" &
                fi
                if [[ -x /usr/bin/chromium ]] ; then
                    chromium --temp-profile "$url" &
                fi

                # explain some details while reporting it
                local message_instructions
                message_instructions="$( TEXTDOMAIN="elive-tools" eval_gettext "Make sure that the report doesn't already exist first, then click where it says to add a new task. You must be registered for create a task first. Close this dialog when you have finished. Thank you." )"
                sleep 6
                $guitool --info --text="$message_instructions"

            fi
        else
            el_warning "$message_report_bug --> http://bugs.elivecd.org"
        fi
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  el_processes_using_mountpoint
#   DESCRIPTION:  show the name of the processes that is using a mountpoint
#    PARAMETERS:  $1 mountpoint-dir, $2 mode [kill]
#       RETURNS:  -
#===============================================================================
el_processes_using_mountpoint(){
    # pre {{{
    local dir mode pid commands pids_mountpoint
    el_debug
    el_security_function_loop || return

    dir="$1"
    mode="$2"

    el_check_variables "dir"
    el_check_dirs "$dir"

    if [[ -b "$dir" ]] ; then
        el_error "$dir is not a directory but a block device, try to use mounts-manager --get-mountpoint"
        return 1
    fi

    # }}}

    for pid in $( fuser -m "$dir" 2>/dev/null | tr ' ' '\n' | grep -v "$dir" | grep -v "$$" )
    do
        pid="${pid//[^[:digit:]]}"
        commands="$( ps axo pid,comm 2>/dev/null | awk -v pid="$pid" '{if ($1 == pid) { $1="" ; print $0 }}' | sed 's| $||g' )"
        if [[ -n "$commands" ]] ; then
            echo "Mountpoint busy by process $pid: $commands"
            el_array_member_add "$pid" "${pids_mountpoint[@]}" ; pids_mountpoint=("${_out[@]}")
        fi
    done

    if [[ "${mode}" = "kill" ]] ; then
        el_debug "Killing processes in reverse mode until the mountpoints is freed"
        # reverse loop of array
        for (( pid=${#pids_mountpoint[@]}-1 ; pid>=0 ; pid-- ))
        do
            el_debug "Killing process: ${pids_mountpoint[pid]}"
            kill "${pids_mountpoint[pid]}" || kill -9 "${pids_mountpoint[pid]}"
            sleep 1
        done
    fi

    unset pids_mountpoint
}

#===  FUNCTION  ================================================================
#          NAME:  el_user_email_get
#   DESCRIPTION:  determine which is the email of the user and return it
#       RETURNS:  email string
#===============================================================================
el_user_email_get(){
    # pre {{{
    local user_email

    # }}}

    # user has configured it for elive
    user_email="$( grep "^email_acount=" "$HOME/.config/email-sender" 2>/dev/null | sed -e 's|^.*="||g' -e 's|".*$||g' | grep "@" | tail -1 )"

    # get the email from his git/github account
    if ! echo "$user_email" | grep -qs "[[:alpha:]]" ; then
        user_email="$( git config --get user.email 2>/dev/null | grep "@" | tail -1 )"
    fi

    if echo "$user_email" | grep -qs "[[:alpha:]]" ; then
        echo "$user_email"
    else
        el_error "unable to get user's email"
    fi
}


###################################################################
#  Always run:
###################################################################
# Generic checks
if [[ "${EL_DEBUG}" -ge "2" ]] ; then
    if [[ "$@" != "bash" ]] && [[ -e "$@" ]] && grep -q el_step_requires_fixme "$0" ; then
        el_warning "Missing features, please report this to Elive"
    fi
fi





# FIXME: implement:
#
# - check same proceses
# - el_fixme_required -> report to the user that the feature is not implemented by some future userfriendly way
# - arrays ?
# - run web
# - trap signals (exit statuses, etc)
# - report, something for inform the user about something important, which interfaces and cases ?
# -
# -
# -
# -
# -
# -


# vim: set foldmethod=marker filetype=sh :

