#!/bin/bash
source /usr/lib/elive-tools/functions

#===  FUNCTION  ================================================================
#          NAME:  chroot_layers_mount
#   DESCRIPTION:  mount the layers needed for a working chroot
#    PARAMETERS:  $1 directory, $2 name-id-to-use
#       RETURNS:  -
#===============================================================================
chroot_layers_mount(){
    # pre {{{
    local dir name
    el_debug
    el_security_function_loop 10 || return

    dir="$1"
    id="$2"
    el_check_variables "dir,name"
    el_check_dirs "$dir"

    if [[ "${UID}" != "0" ]] && ! el_check_sudo_automated ; then
        el_error "must require root privileges"
    fi

    # }}}

    if el_flag check "chroot_layer_prepared" ; then
        el_explain 0 "chroot layers already mounted"
        return
    fi

    # devpts
    mkdir -p "$dir/dev/pts"
    mount devpts-$id -t devpts "${dir}/dev/pts" || true

    # proc
    mkdir -p "$dir/proc"
    mount proc-$id -t proc "${dir}/proc" || true

    # selinux
    if [[ -e "/selinux/enforce" ]] && [[ "$(cat /selinux/enforce)" = "1" ]] ; then
        mkdir -p "$dir/selinux"
        mount selinuxfs-$id -t selinuxfs "${dir}/selinux" || true
    fi

    # sysfs
    mkdir -p "$dir/sys"
    mount sysfs-$id -t sysfs "${dir}/sys" || true

    # debian chroot mark
    mkdir -p "$dir/etc"
    echo "live" > "${dir}/etc/debian_chroot"

    # custom start-stop-daemon
    if [[ -e "$dir/sbin/start-stop-daemon" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /sbin/start-stop-daemon
        echo -e "#!/bin/sh\nexit 0" > "${dir}/sbin/start-stop-daemon"
        chmod 755 "${dir}/sbin/start-stop-daemon"
    fi

    # disable dpkg syncin
    mkdir -p "$dir/etc/dpkg/dpkg.cfg.d"
    echo -e "force-unsafe-io" > "${dir}/etc/dpkg/dpkg.cfg.d/live-build"

    # flash-kernel
    if [[ -e "$dir/usr/sbin/flash-kernel" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /usr/sbin/flash-kernel
        ln -s /bin/true "${dir}/usr/sbin/flash-kernel"
    fi

    # sysv-rc
    mkdir -p "$dir/usr/sbin"
    if [[ -e "$dir/usr/sbin/policy-rc.d" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /usr/sbin/policy-rc.d
        echo -e "#!/bin/sh\necho 'All runlevel operations denied by policy, made by elive modifications' >&2 \nexit 101" > "${dir}/usr/sbin/policy-rc.d"
        chmod 0755 "${dir}/usr/sbin/policy-rc.d"
    fi

    # upstart
    if [[ -e "$dir/sbin/initctl" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /sbin/initctl
        echo -e "#!/bin/sh\necho 'All runlevel operations denied by policy, made by elive modifications' >&2 \nexit 101" > "${dir}/sbin/initctl"
        chmod 0755 "${dir}/sbin/initctl"
    fi

    # hosts file
    mkdir -p "$dir/etc"
    if [[ -f "$dir/etc/hosts" ]] ; then
        mv "$dir/etc/hosts" "$dir/etc/hosts.orig"
    fi
    echo -e "127.0.0.1\tlocalhost localhost.localdomain\n127.0.1.1\tdebian" > "$dir/etc/hosts"
    cat /etc/hosts >> "$dir/etc/hosts"

    # resolv.conf
    mkdir -p "$dir/etc"
    if [[ -e "$dir/etc/resolv.conf" ]] ; then
        mv "$dir/etc/resolv.conf" "$dir/etc/resolv.conf.orig"
        : > "$dir/etc/resolv.conf"
    elif [[ -L "$dir/etc/resolv.conf" ]] ; then
        mv "$dir/etc/resolv.conf" "$dir/etc/resolv.conf.orig"
    fi
    cp /etc/resolv.conf "$dir/etc/resolv.conf"

    # hostname
    mkdir -p "$dir/etc" "$dir/bin"
    if [[ -e "$dir/etc/hostname" ]] ; then
        mv "$dir/etc/hostname" "$dir/etc/hostname.orig"
    fi
    echo "localhost.localdomain" > "$dir/etc/hostname"
    if [[ -x "$dir/usr/bin/dpkg-divert" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /bin/hostname
        echo -e "#!/bin/sh\necho 'localhost.localdomain'" > "$dir/bin/hostname"
        chmod 755 "$dir/bin/hostname"
    fi

    echo "Layers for chroot $dir are now ready"

    # add a flag
    el_flag add "chroot_layer_prepared"


}
#===  FUNCTION  ================================================================
#          NAME:  chroot_layers_umount
#   DESCRIPTION:  umount the layers of a chroot
#    PARAMETERS:  $1 dir , $2 name-id-to-use
#       RETURNS:  -
#===============================================================================
chroot_layers_umount(){
    # pre {{{
    local dir id
    el_debug
    el_security_function_loop 10 || return

    dir="$1"
    id="$2"
    el_check_variables "dir"
    el_check_dirs "$dir"

    if [[ "${UID}" != "0" ]] && ! el_check_sudo_automated ; then
        el_error "must require root privileges"
    fi


    # }}}

    if ! el_flag check "chroot_layer_prepared" ; then
        el_explain 0 "chroot layers already umounted"
        return
    fi

    # devpts
    if check_is_mounted "$dir/dev/pts" 1>/dev/null ; then
        if grep -qs "$dir/dev/pts" /proc/mounts || el_check_dir_has_files "$dir/"dev/pts/* ; then
            umount "$dir/dev/pts"
        else
            umount -f "$dir/dev/pts" 2>/dev/null 1>&2 || true
        fi
    fi

    # proc
    if check_is_mounted "$dir/proc" 1>/dev/null ; then
        if [[ -e "${dir}/proc/sys/fs/binfmt_misc/status" ]] ; then
            umount "$dir/proc/sys/fs/binfmt_misc"
        fi
        if [[ -e "${dir}/proc/version" ]] ; then
            umount "$dir/proc"
        fi
    fi

    # selinux
    if check_is_mounted "$dir/selinux" 1>/dev/null || [[ -e "$dir/selinux/enforce" ]] ; then
        umount "$dir/selinux"
    fi

    # sysfs
    if check_is_mounted "$dir/sys" 1>/dev/null ; then
        umount "$dir/sys"
    fi

    # debian chroot mark
    rm -f "${dir}/etc/debian_chroot"

    # flash-kernel
    rm -f "${dir}/usr/sbin/flash-kernel"
    if [[ -e "$dir/usr/sbin/flash-kernel.distrib" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --remove /usr/sbin/flash-kernel
    fi
    # custom start-stop-daemon
    rm -f "${dir}/sbin/start-stop-daemon"
    if [[ -e "$dir/sbin/start-stop-daemon.distrib" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --remove /sbin/start-stop-daemon
    fi
    # disable dpkg syncin
    rm -f "${dir}/etc/dpkg/dpkg.cfg.d/live-build"

    # sysv-rc
    rm -f "${dir}/usr/sbin/policy-rc.d"
    if [[ -e "$dir/usr/sbin/policy-rc.d.distrib" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --remove /usr/sbin/policy-rc.d
    fi

    # upstart
    rm -f "${dir}/sbin/initctl"
    if [[ -e "$dir/sbin/initctl.distrib" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --remove /sbin/initctl
    fi

    # hosts file
    if [[ -f "$dir/etc/hosts.orig" ]] ; then
        mv "$dir/etc/hosts.orig" "$dir/etc/hosts"
    else
        : > "$dir/etc/hosts"
    fi

    # resolv.conf
    if [[ -f "$dir/etc/resolv.conf.orig" ]] ; then
        mv "$dir/etc/resolv.conf.orig" "$dir/etc/resolv.conf"
    else
        : > "$dir/etc/resolv.conf"
    fi
    if [[ -e "$dir/etc/resolv.conf.d" ]] ; then
        rm -f "$dir/etc/resolv.conf.d/original"
        rm -f "$dir/etc/resolv.conf.d/tail"
    fi

    # hostname
    rm -f "$dir/etc/hostname"
    if [[ -e "$dir/etc/hostname.orig" ]] ; then
        mv "$dir/etc/hostname.orig" "$dir/etc/hostname"
    fi
    if [[ -e "$dir/bin/hostname.distrib" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --remove /bin/hostname
    fi

    echo "Layers for chroot $dir are umounted"

    # remove the flag
    el_flag del "chroot_layer_prepared"

}

#===  FUNCTION  ================================================================
#          NAME:  get_mountpoint
#   DESCRIPTION:  get the mountpoint of a device
#    PARAMETERS:  $1 = device
#       RETURNS:  -
#===============================================================================
get_mountpoint(){
    # pre {{{
    local dev is_mounted mountpoint is_temporally_mounted
    el_debug
    el_security_function_loop 10 || return

    dev="$1"
    el_check_variables "dev"
    el_dependencies_check "udisks"

    # }}}

    if [[ ! -b "$dev" ]] ; then
        el_explain 1 "$dev is not a device, skipping"
        return 1
    fi


    mountpoint="$( LC_ALL=C udisks --show-info "$dev" | grep "mount paths:" | sed -e 's|^.*mount paths:||g' )"
    read -r mountpoint <<< "$mountpoint"

    # not mounted ? mount it first
    if [[ -z "$mountpoint" ]] && ! check_is_mounted "$dev" 1>/dev/null ; then
        #if LC_ALL=C udisks --show-info "$dev" | grep -qs "is mounted:.*0" ; then

        #udisks --mount "$dev" 1>/dev/null
        #sync
        # TODO: if i use el_mount here it fails by some strange reason, why ? get_mountpoint not gets the mountpoint correctly?
        if el_mount "$dev" 1>/dev/null ; then

            # get data again
            mountpoint="$( LC_ALL=C udisks --show-info "$dev" | grep "mount paths:" | sed -e 's|^.*mount paths:||g' )"
            # remove extra leading blank chars
            read -r mountpoint <<< "$mountpoint"
            # umount it
            if [[ -n "$mountpoint" ]] ; then
                el_umount "$mountpoint" 1>/dev/null
            fi
        fi
    fi


    # get the mountpoint
    if [[ -n "$mountpoint" ]] ; then
        if [[ "$(echo "$mountpoint" | wc -w )" -gt 1 ]] ; then
            el_warning "More than one mountpoint assigned to ${dev}: ${mountpoint}, using the last one"
            mountpoint="$(echo "$mountpoint" |tr ' ' '\n' | tail -1)"
        fi

        # and so, show the result
        echo "$mountpoint"
        return 0
    else
        # nothing get, return an error
        el_warning "unable to get mountpoint for $dev"
        return 1
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  check_is_mounted
#   DESCRIPTION:  returns true if a device or mountpoint is mounted
#    PARAMETERS:  $1 dev or mountpoint
#       RETURNS:  true if is mounted, false if not
#===============================================================================
check_is_mounted(){
    # pre {{{
    local arg device mountpoint is_device is_mountpoint
    el_security_function_loop 10 || return

    arg="$1"
    el_check_variables "arg"

    # }}}

    sync

    if [[ "$arg" = /dev/* ]] ; then
        is_device=1
        device="$arg"
    else
        is_mountpoint=1
        mountpoint="${arg%/}"
    fi


    if ((is_mountpoint)) ; then
        if LC_ALL=C mount | grep -qs "on ${mountpoint} type" ; then
            el_debug "Mountpoint $mountpoint mounted"
            echo "Mounted"
            return 0
        else
            el_debug "Mountpoint $mountpoint not mounted"
            echo "Not mounted"
            return 1
        fi
    fi

    if ((is_device)) ; then
        # mounted
        if LC_ALL=C udisks --show-info "$device" | grep -qs "is mounted:.*1" ; then
            el_debug "Device $device mounted"
            echo "Mounted"
            return 0
        fi
        # not mounted
        if LC_ALL=C udisks --show-info "$device" | grep -qs "is mounted:.*0" ; then
            el_debug "Device $device not mounted"
            echo "Not mounted"
            return 1
        fi
        # well, maybe not working?
        if LC_ALL=C udisks --show-info "$device" | grep -qs "Cannot find device with major:minor" ; then
            el_sudo service udev restart
            el_request_report_bug "UDEV needed to be restarted in 'check_is_mounted from mounts-manager', what caused this need? this restart has broke anything to the user side like (thunar) partitions-panel or shared-folders ?"
            $FUNCNAME "$arg"
            return $?
        fi
    fi

}
#===  FUNCTION  ================================================================
#          NAME:  el_umount
#   DESCRIPTION:  overwrite layer for a real umount feature
#    PARAMETERS:  $1 dev or mountpoint that we want to umount
#       RETURNS:  true if successfull, false if not
#===============================================================================
el_umount(){
    # pre {{{
    local arg device mountpoint is_device is_mountpoint
    el_debug "Umounting: $@"
    el_security_function_loop 10 || return

    # }}}
    for arg in "$@"
    do
        sync

        unset device mountpoint is_device is_mountpoint
        if [[ ! -b "$arg" ]] && [[ ! -d "$arg" ]] && [[ ! -L "$arg" ]] && [[ ! -e "$arg" ]] ; then
            el_warning "What $arg is ? skipping.."
        fi
        if [[ "$arg" = /dev/* ]] ; then
            is_device=1
            device="$arg"
        else
            is_mountpoint=1
            mountpoint="${arg%/}"
        fi


        if ((is_mountpoint)) && ! check_is_mounted "$mountpoint" 1>/dev/null ; then
            # if we are not mounted, nothing more to do
            return 0
        fi

        if ((is_device)) ; then
            # if we are not mounted, nothing more to do
            if ! check_is_mounted "$device" 1>/dev/null ; then
                return 0
            fi

            #otherwise get the needed data
            mountpoint="$( get_mountpoint "$device" )"

            if [[ -z "$mountpoint" ]] ; then
                el_warning "unable to get mountpoint for $device, which means that is not mounted, although this function should have not been called, everything is fine, continuing..."
                # return that is not mounted
                return 0
            fi
        fi


        # try with gvfs-mount first, since seems like it is unable to umount with the other ones
        if [[ "$EL_DEBUG" -ge 3 ]] ; then
            gvfs-mount -u "$mountpoint"
        else
            gvfs-mount -u "$mountpoint" 2>/dev/null 1>&2
        fi
        if check_is_mounted "$mountpoint" 1>/dev/null ; then
            el_warning "unable to umount (gvfs-mount) $dev for ${mountpoint}, trying with udisks..."
        else
            return 0
        fi

        # try with udisks maybe
        if [[ "$EL_DEBUG" -ge 3 ]] ; then
            udisks --unmount "$mountpoint"
        else
            udisks --unmount "$mountpoint" 2>/dev/null 1>&2
        fi
        if check_is_mounted "$mountpoint" 1>/dev/null ; then
            el_warning "unable to umount (udisks) $dev for ${mountpoint}, trying with umount..."
        else
            return 0
        fi

        if [[ "$EL_DEBUG" -ge 3 ]] ; then
            command umount "$mountpoint" || command umount "$device"
        else
            command umount "$mountpoint" 2>/dev/null 1>&2 || command umount "$device" 2>/dev/null 1>&2
        fi
        if check_is_mounted "$mountpoint" 1>/dev/null ; then
            el_warning "unable to umount (umount) $dev for ${mountpoint}, so hum... let me think"
        else
            return 0
        fi

        # try to know why we cannot umount it
        el_processes_using_mountpoint "$mountpoint"

        # force ? we should never do this
        if ((is_forced)) ; then
            # kill all the children processes used on this mountpoint:
            el_processes_using_mountpoint "$mountpoint" kill 1>/dev/null

            gvfs-mount -u "$mountpoint" 2>/dev/null 1>&2
            if check_is_mounted "$mountpoint" 1>/dev/null ; then
                el_warning "unable to umount (gvfs-mount) $dev for ${mountpoint}, trying with udisks..."
            else
                return 0
            fi

            # try with udisks maybe
            udisks --unmount "$mountpoint" 2>/dev/null 1>&2
            if check_is_mounted "$mountpoint" 1>/dev/null ; then
                el_warning "unable to umount (udisks) $dev for ${mountpoint}, trying with umount..."
            else
                return 0
            fi

            command umount "$mountpoint" 2>/dev/null 1>&2 || command umount "$device" 2>/dev/null 1>&2

            if check_is_mounted "$mountpoint" 1>/dev/null ; then
                el_warning "ok, bruteforce time"
                # supercow powers
                command umount -l "$mountpoint" || command umount -l "$device" || command umount -f "$mountpoint" || command umount -f "$device"
            else
                return 0
            fi
        fi

        if check_is_mounted "$mountpoint" 1>/dev/null ; then
            el_error "unable to umount $dev for ${mountpoint}, I'm upset now"
            return 1
        else
            el_warning "well, finally umounted"
            return 0
        fi
    done
}
#===  FUNCTION  ================================================================
#          NAME:  el_mount
#   DESCRIPTION:  overwrite layer for a real mount feature
#    PARAMETERS:  $1 = device
#       RETURNS:  true if success, false if not
#===============================================================================
el_mount(){
    # pre {{{
    local dev args
    el_debug
    el_security_function_loop 10 || return

    dev="$1"
    shift
    args="$@"

    el_check_variables "dev"

    # }}}

    if [[ "$dev" != /dev/* ]] ; then
        el_error "Argument passed to $FUNCNAME is not a device: $dev"
        return 1
    fi

    if [[ "$EL_DEBUG" -ge 3 ]] ; then
        timeout 60 udisks --mount "$dev" "$args"
    else
        timeout 60 udisks --mount "$dev" "$args" 1>/dev/null
    fi

    # previous check
    sync
    if check_is_mounted "$dev" 1>/dev/null ; then
        echo "$dev mounted in: $(get_mountpoint "$dev" )"
        return 0
    else
        if LC_ALL=C udisks --mount "$dev" "$args" 2>&1 | grep -qs "Cannot find device with major:minor" ; then
            el_sudo service udev restart
            timeout 60 udisks --mount "$dev" "$args" 1>/dev/null

            el_request_report_bug "UDEV needed to be restarted in 'el_mount' from 'mounts-manager', what caused this need? this restart has broke anything to the user side like (thunar) partitions-panel or shared-folders ?"
        fi
    fi

    sync
    if check_is_mounted "$dev" 1>/dev/null ; then
        echo "$dev mounted in: $(get_mountpoint "$dev" )"
        return 0
    else
        return 1
    fi
}


main(){
    # pre {{{
    local arg

    # }}}
    # Usage
    if [[ -z "${1}" ]] ; then
        echo -e "Usage: $(basename $BASH_SOURCE) options:"
        echo -e "Basic partitions / mountpoins features:"
        echo -e "--get-mountpoint dev  : get the mountpoint of a device address"
        echo -e "--check-is-mounted [dev|mountpoint]  : returns true|false if the argument is mounted"
        echo -e "--mount dev [args]  : mount a device, args must be in udisks format:"
        echo -e "                    (--mount-fstype reiserX --mount-options foo,bar)"
        echo -e "--umount [dev|mountpoint]  : umounts a device|mountpoint"
        echo -e "--umount-force [dev|mountpoint]  : umounts a device|mountpoint in a forced mode, NEVER do this"
        echo -e ""
        echo -e "Chroots related:"
        echo -e "--chroot-layers-mount directory idname  : mount the layers needed for a full-working chroot (proc, sysfs, etc)"
        echo -e "--chroot-layers-umount directory [idname]  : umount the layers"
        exit 1
    fi

    case "$1" in
        --get-mountpoint)
            get_mountpoint "$2"
            ;;
        --check-is-mounted)
            check_is_mounted "$2"
            ;;
        --mount)
            shift
            el_mount "$@"
            ;;
        --umount)
            el_umount "$2"
            ;;
        --umount-force)
            is_forced=1
            el_umount "$2"
            ;;
        --chroot-layers-mount)
            chroot_layers_mount "$2" "$3"
            ;;
        --chroot-layers-umount)
            chroot_layers_umount "$2" "$3"
            ;;
    esac


}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
