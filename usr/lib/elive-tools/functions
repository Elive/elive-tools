#!/bin/bash
##TEXTDOMAIN="elive-tools" # disabled on purpose for compatibility, do not enable

if [[ -n "$ZSH_VERSION" ]] ; then
    # Note: if you use ZSH, you must set the SOURCE var name from the main script
    if [[ -n "$SOURCE" ]]; then
        SOURCE="$( readlink -f "$0" || true )"
    else
        SOURCE="$ZSH_SCRIPT"
    fi
fi

# The rest of the definitions are moved to the end of the file, functions must be declared before

#-------------------------------------------------------------------------------
#   Set the DISPLAY variable
#-------------------------------------------------------------------------------
el_set_display_variables(){ # Set DISPLAY variables of our actual user
    local is_debug
    if [[ "$1" = "debug" ]] ; then
        is_debug=1
    fi
    # if we are in console (out of X) we should always exit
    if ((is_console)) ; then
        if ((is_debug)) ; then
            echo -e "we are NOT in console, exiting '$FUNCNAME' ..." 1>&2
        fi
        return 0
    fi

    # from enlightenment values {{{
    local display e_ipc_socket pid

    # unset XAUTHORITY if is not from our user (bugs when we "su otheruser")
    # update: we should never unset the XAUTHORITY, verify that this was really wrong before..
    # more exactly: if we run a script from user, that sudo another script that runs a zenity, we will unset the XAUTHORITY and we will never be able to show the zenity message
    #if [[ -n "$XAUTHORITY" ]] && [[ "$XAUTHORITY" != "$HOME/"* ]] ; then
        #unset XAUTHORITY
    #fi

    if [[ -z "${DISPLAY}" ]] ; then
        if command ls --color=none /tmp/e-${USER}@*/*-* 1>/dev/null 2>/dev/null ; then
            display="$( command find /tmp/e-${USER}@*/*-* -mindepth 0 -maxdepth 0 -type s -print0 | xargs -r0 stat -c %y\ %n 2>/dev/null | sort -n | tail -1 2>/dev/null )"

            # cleanups
            display="/tmp/${display##* /tmp/}"
            display="${display%|*}"

            if [[ -z "$display" ]] ; then
                el_warning "unable to get display values from running enlightenment session"
            fi

            e_ipc_socket="${display}"

            #display="${display##*disp-}"
            display="$( basename ${display} )"
            display="${display%-*}"

            if [[ -z "${DISPLAY}" ]] ; then
                DISPLAY="${display}"
                export DISPLAY
            fi
        fi
    fi

    # e17 not running or not fetch, let's try an alternative to fetch the display value
    if [[ -z "${DISPLAY}" ]] ; then
        display="$( ps -u $(id -u) -o pid= | \
            while read pid; do
                cat /proc/$pid/environ 2>/dev/null | LC_ALL=C tr '\0' '\n' | LC_ALL=C grep '^DISPLAY=:'
            done | LC_ALL=C grep -o ':[0-9]*' | sort -u | tail -1 )"

        DISPLAY="${display}"
        export DISPLAY
    fi

    # fetch dbus address to we can use things like notify-send or dbus-send
    if [[ -z "$DBUS_SESSION_BUS_ADDRESS" ]] && [[ -e "$HOME/.cache/dbus-session-address-last.txt" ]] ; then
        export DBUS_SESSION_BUS_ADDRESS="$( cat "$HOME/.cache/dbus-session-address-last.txt" )"
    fi

    if [[ -z "${E_IPC_SOCKET}" ]] && [[ -n "${e_ipc_socket}" ]] ; then
        E_IPC_SOCKET="${e_ipc_socket}"
        export E_IPC_SOCKET
    fi
    # END from enlightenment values }}}
    # xauthority {{{
    if [[ -n "$DISPLAY" ]] && [[ -z "$XAUTHORITY" ]] && [[ -e "$HOME/.Xauthority" ]] ; then
        XAUTHORITY="$HOME/.Xauthority"
        export XAUTHORITY
    fi

    if ((is_terminal)) && [[ "$UID" != 0 ]] && [[ -z "$SSH_CONNECTION" ]] ; then
        # only show the error if we have a graphical system running by the user
        if command ls --color=none /tmp/e-${USER}@*/*-* 1>/dev/null 2>/dev/null || pidof e16 1>/dev/null 2>&1 ; then
            if [[ -z "${DISPLAY}" ]] ; then
                el_warning "Variable DISPLAY is not set, so we will not have access to the local graphical system"
            fi
            if [[ -z "${XAUTHORITY}" ]] ; then
                el_warning "Variable XAUTHORITY is not set, so we may not have full access to the local graphical system"
            fi
            # only e17+
            if command ls --color=none /tmp/e-${USER}@*/*-* 1>/dev/null 2>/dev/null ; then
                if [[ -z "${E_IPC_SOCKET}" ]] ; then
                    if [[ "$UID" != 0 ]] ; then
                        el_warning "Variable E_IPC_SOCKET is not set, we may be not the user owner of this graphical session"
                    fi
                fi
            fi
        fi
    fi

    # END xauthority }}}

    if ((is_debug)) ; then
        echo -e "DISPLAY '$DISPLAY' DBUS_SESSION_BUS_ADDRESS '$DBUS_SESSION_BUS_ADDRESS' E_IPC_SOCKET '$E_IPC_SOCKET' XAUTHORITY '$XAUTHORITY' UID '$UID' USER '$USER' " 1>&2
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  el_notify
#   DESCRIPTION:  send a notification to the user in a nice way
#    PARAMETERS:  $1 = mode (normal|important|critical), $2 = title, $3 = message, $4 = icon
#       RETURNS:  -
#===============================================================================
el_notify(){
    # pre {{{
    local time title message icon words mode extra_args

    if [[ -z "$4" ]] ; then
        el_error "Function usage: $FUNCNAME (soft|nor|imp|crit) 'icon' 'title' 'message'  - (icon example: 'logo-elive')"
        return 1
    fi

    mode="$1"
    shift
    icon="$1"
    shift
    title="$1"
    shift
    message="$1"
    shift

    # }}}
    # defaults {{{
    #if [[ -z "$icon" ]] ; then
        #icon="logo-elive"
    #fi

    # count amount of seconds
    words="$( echo "$title $message" | wc -w )"
    time="$( echo "$words / 2.6" | LC_NUMERIC=C bc -l | sed -e 's|\..*$||g' )"
    time="${time%.*}"
    time="$(( $time + 3 ))"

    # add extra time if we require an action
    if echo "$@" | grep -qsE -- "(-w|--action|-A)" ; then
        time="$(( $time + 10 ))"
    fi


    case "$mode" in
        soft)
            time="$(( $time - 1 ))"
            extra_args="$extra_args -u low"
            ;;
        nor*)
            time="$(( $time + 4 ))"
            extra_args="$extra_args -u normal"
            ;;
        imp*)
            # 1 minute more
            time="$(( $time + 60 ))"
            extra_args="$extra_args -u critical"
            ;;
        crit*)
            # 15 minutes more
            time="$(( $time + 900 ))"
            extra_args="$extra_args -u critical"
            ;;
        wait)
            # wait 30 minutes more for user input
            time="$(( $time + 1800 ))"
            extra_args="$extra_args -u normal"
            ;;
    esac

    # convert time to milliseconds
    time="$(( $time * 1000 ))"

    # always make it transient mode, because is so annoying to have notifications kept in a widget
    extra_args="${extra_args} -e"

    # }}}

    el_set_display_variables

    if [[ "${DISPLAY}" = ":0.0" ]] ; then
        if ! el_dependencies_check notify-send ; then
            el_dependencies_install "libnotify-bin"
        fi

        # run notification daemon if not running already
        if ! [[ -n "$E_START" ]] ; then
            if ! pidof "notification-daemon" 1>/dev/null 2>&1 ; then
                ( /usr/lib/notification-daemon/notification-daemon & )
                sleep 2
            fi
        fi

        # check that it working otherwise restart daemon, this is needed otherwise "action" based notifications will block the application being stuck
        if ! timeout 5 notify-send -e -t 1 "." 2>/dev/null ; then
            notification-daemon-restarter
        fi

        notify-send ${extra_args} -t "$time" -i "$icon" "$title" "$message" "$@"
    else
        el_info "${title}: ${message}"
    fi
}


#-------------------------------------------------------------------------------
#   Verify if we have internet connection with a fast ping check
#-------------------------------------------------------------------------------
el_verify_internet_ping(){ # verify if we have internet connection using a ping (true or false, return value)
    # pre {{{
    local timeout count target mode
    timeout="$1"
    mode="$2"
    # note: this code contains commented lines used for debug (to simulate a full lag)

    # note: dns resolving can be very slow if we are for example using torrents
    #target="www.google.com"
    target="8.8.8.8"

    if [[ -z "$timeout" ]] ; then
        # default timeout if not set
        timeout=7
    fi

    # - pre }}}

    # do we are using servcies that slows down our dns resolving? just make sure and test it..
    #if ps aux | grep -v grep | grep -qsiE "(transmission|torrent|deluge|amule|nicotine)" ; then
        ## special ping modes in case we have a lag (because we don't want to lose time resolving dns)
        #target="8.8.8.8"
        ##if timeout 3 sleep 100000 2>/dev/null 1>&2 ; then
        #if timeout 4 ping -c 1 "$target"  2>/dev/null 1>&2 ; then
            #return 0
        #fi
    #else
        ## this is the normal ping mode
        ##if timeout $timeout sleep 100000 2>/dev/null 1>&2 ; then
        #if timeout $timeout ping -c 1 "$target"  2>/dev/null 1>&2 ; then
            #return 0
        #fi
    #fi

    # normal ping mode, we don't need to use the previous code so we use it by default
    # we only need to know if we can ping to outside, not dns resolving
    if timeout $timeout ping -c 1 "$target"  2>/dev/null 1>&2 ; then
        return 0
    fi


    # wanna debug more?
    if [[ "${EL_DEBUG}" -gt "3" ]] ; then
        el_debug "doing a ping to google don't respond: $( timeout 1 ping -c 1 "$target" 2>&1 )"
        if timeout 1 ping -c 1 "$target" 2>/dev/null 1>&2 ; then
            el_debug "by other side we can ping directly to an ip, check your /etc/resolv.conf"
        else
            el_debug "we cannot even ping to the google dns ($target)"
        fi
    fi

    # in any case if we reach here, is because we cannot ping to google, so return that
    return 1
}
#-------------------------------------------------------------------------------
#   Verify if we have internet connection (return value)
#-------------------------------------------------------------------------------
el_verify_internet(){ # verify if we have internet connection (true or false, return value)
    # pre {{{
    local stamp_hour_prev date_hour_now date_hour_prev returned OnLine i mode timeout buf target interface

    stamp_hour_prev="/tmp/.stamps-${USER}/verify_internet_connection"
    mkdir -p "$( dirname "${stamp_hour_prev}" )"

    date_hour_now="$( date +%s )"
    #date_hour_prev="$( tail -1 "${stamp_hour_prev}" 2>/dev/null )"
    #read -r date_hour_prev <<< "$date_hour_prev"

    # note: we should not use delayed, we always want delayed, instead, we should use "fast" when we need a fast check
    mode="$1"

    if [[ "${mode}" = "fast" ]] ; then
        # bad network in house dont show anything before 4 seconds
        timeout=8
    else
        timeout=16
    fi

    target="8.8.8.8"

    # }}}

    # Test for network carrier first, and exit if we don't have it at all
    # we should have "something" connected somewhere
    unset OnLine
    #for interface in $(ls /sys/class/net/ | grep -Fv lo);
    for interface in /sys/class/net/*
    do
        interface="${interface##*/}"
        if [[ "${interface}" = "lo" ]] ; then
            continue
        fi

        if [[ $(cat /sys/class/net/$interface/carrier 2>/dev/null ) = 1 ]]; then
            if [[ "${EL_DEBUG}" -gt "3" ]] ; then
                el_debug "carrier for $interface marks that we are connected"
            fi

            OnLine=1;
            break
        fi
    done


    # cache online (10 min)
    if [[ -n "$OnLine" ]] ; then
        if [[ -s "$stamp_hour_prev" ]] ; then
            buf="$( echo "$(date +%s) - $( stat -c %Y "${stamp_hour_prev}" )" 2>/dev/null | LC_ALL="$EL_LC_EN" bc -l | sed -e 's|\..*$||g' )"
            if [[ -n "$buf" ]] && [[ "$buf" -lt 600 ]] ; then

                # if anything tell us that we are connected and we was before, we should still be
                el_dependencies_check "route"
                if /sbin/route -n | LC_ALL=C grep -qsE "0\.0\.0\.0.*\s+UG\s+" || ip route | LC_ALL=C grep -Fqs "default via" ; then
                    if [[ "${EL_DEBUG}" -gt "3" ]] ; then
                        el_debug "seems like we still online, using cache + small checks"
                    fi
                    return 0
                fi
            fi
        fi
    fi


    # we have not finished from the caches, so remove them so we will avoid the next check loops
    rm -f "$stamp_hour_prev"

    # do we have booted the computer recently? (and so no internet yet), needed for things like geolocation in live
    if ! LC_ALL=C grep -Fqs "boot=live" /proc/cmdline ; then
        if [[ "$( cat "/proc/uptime" | awk '{print $1}' | sed -e 's|\..*$||g' )" -lt 300 ]] ; then

            # we just booted the system, wait for real 40 secons
            for i in $( seq 30 )
            do
                if timeout 2 ping -c 1 "$target"  2>/dev/null 1>&2 ; then
                    return 0
                fi
                sleep 1
            done
        fi
    fi


    # do a ping check
    if el_verify_internet_ping $timeout $mode ; then
        echo "$date_hour_now" > "$stamp_hour_prev"
        if [[ "${EL_DEBUG}" -gt "3" ]] ; then
            el_debug "connection to internet found at ping level"
        fi
        return 0
    fi



    # still in fast check ? return 0
    if [[ "${mode}" = "fast" ]] ; then
        return 1
    fi


    # check for connection to internet using curl instead
    if [[ "${EL_DEBUG}" -gt "3" ]] ; then
        el_debug "let's do a last check using a curl to google"
    fi

    el_dependencies_check "curl"
    if timeout 9 curl --connect-timeout 8 www.google.com 2>/dev/null | LC_ALL=C grep -qsi 'html' ; then
        echo "$date_hour_now" > "$stamp_hour_prev"
        if [[ "${EL_DEBUG}" -gt "3" ]] ; then
            el_debug "connection to internet finally using curl"
        fi

        return 0
    else
        if [[ "${EL_DEBUG}" -gt "3" ]] ; then
            el_debug "Connection to internet not found"
        fi

        return 1
    fi
}

#-------------------------------------------------------------------------------
#   Make ready the user's environment (bash variables, extra functions, etc)
#-------------------------------------------------------------------------------
el_make_environment(){ # make ready our environment (source variables and functions)
    local is_debug
    if [[ "$1" = "debug" ]] ; then
        is_debug=1
    fi

    if [[ -f "/etc/adduser.conf" ]] ; then
        source /etc/adduser.conf
    fi

    # set user
    if [[ -z "${USER}" ]] ; then
        USER="$(whoami)"
        export USER
    fi

    # set home
    if [[ -z "${HOME}" ]] ; then
        if [[ -n "${DHOME}" ]] ; then
            HOME="${DHOME}/$USER"
            export HOME
        else
            HOME="/home/$USER"
            export HOME
        fi
    fi

    # give display access
    el_set_display_variables $1

    #if [[ "$PATH" != *"$HOME/bin"* ]] ; then
        #PATH="$HOME/bin:$PATH"
    #fi

    if [[ -n "${SOURCE}" ]] ; then
        #export PS4='+ ($(basename ${0}):${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}():  }'
        #export PS4='+ [$(basename ${0})|${FUNCNAME[0]:+${FUNCNAME[0]}}|${LINENO}]  '
        export PS4='+ [$(basename ${SOURCE} 2>/dev/null )  ${FUNCNAME[0]:+${FUNCNAME[0]}} ${LINENO}]  '
    fi

    # XDG default directories
    if [[ -z "${XDG_CONFIG_HOME}" ]] || [[ ! -d "$XDG_CONFIG_HOME" ]] ; then
        XDG_CONFIG_HOME="${HOME}/.config"
        if [[ ! -d "$XDG_CONFIG_HOME" ]] ; then
            mkdir -p "$XDG_CONFIG_HOME"
        fi
    fi

    if [[ -z "${XDG_CACHE_HOME}" ]] || [[ ! -d "$XDG_CACHE_HOME" ]] ; then
        XDG_CACHE_HOME="${HOME}/.cache"
        if [[ ! -d "$XDG_CACHE_HOME" ]] ; then
            mkdir -p "$XDG_CACHE_HOME"
        fi
    fi

    if ((is_debug)) ; then
        echo -e "USER '$USER' UID '$UID' HOME '$HOME' TERM '$TERM' XDG_CACHE_HOME '$XDG_CACHE_HOME' XDG_CONFIG_HOME '$XDG_CONFIG_HOME'" 1>&2
    fi
}

#-------------------------------------------------------------------------------
#   Title Set: sets the title of a window
#-------------------------------------------------------------------------------
el_title_set(){ # set the Title on the actual Window

    el_set_display_variables
    echo -ne '\033]0;'$@'\007'

}

#-------------------------------------------------------------------------------
#   Resolutions, get the resolution values
#-------------------------------------------------------------------------------
el_resolution_get(){ # show our actual resolution
    local buf resolution_h resolution_v resolution

    el_set_display_variables

    # xrandr: more reliable based on the primary screen:
    if [[ -z "$resolution" ]] ; then
        if [[ -x "$( which xrandr )" ]] ; then
            buf="$( LC_ALL=C xrandr -q | grep -F connected | psort -- -p "primary" | head -1 | tr ' ' '\n' )"

            resolution_h="$( echo "$buf" | grep "[[:digit:]]x[[:digit:]]" | sed -e 's|x.*$||g' )"
            read -r resolution_h <<< "$resolution_h"
            resolution_v="$( echo "$buf" | grep "[[:digit:]]x[[:digit:]]" | sed -e 's|^.*x||g' -e 's|\+.*$||g' )"
            read -r resolution_v <<< "$resolution_v"

            resolution="${resolution_h}x${resolution_v}"
        else
            el_warning "suggested missing dependency: xrandr"
        fi
    fi

    # faster default fallback
    if [[ -z "$resolution" ]] ; then
        if [[ -x "$( which xdpyinfo )" ]] ; then
            resolution="$( LC_ALL=C xdpyinfo | LC_ALL=C grep "dimensions:.*x" | awk '{print $2}' | tail -1 )"
        fi
    fi

    if [[ -n "$resolution" ]] ; then
        echo "$resolution"
    else
        el_error "problem obtaining primary screen resolution, missing dependencies? xdpyinfo | xrandr"
    fi
}

#-------------------------------------------------------------------------------
#   Get the DPI of the primary screen connected
#-------------------------------------------------------------------------------
el_dpi_get(){
    local resolution_h resolution_v screen_size_v screen_size_h buf dpi_v dpi_h dpi_lowered

    if el_dependencies_check "xrandr" ; then

        buf="$( LC_ALL=C xrandr -q | grep -F connected | psort -- -p "primary" | head -1 | tr ' ' '\n' )"

        resolution_h="$( echo "$buf" | grep "[[:digit:]]x[[:digit:]]" | sed -e 's|x.*$||g' )"
        read -r resolution_h <<< "$resolution_h"
        resolution_v="$( echo "$buf" | grep "[[:digit:]]x[[:digit:]]" | sed -e 's|^.*x||g' -e 's|\+.*$||g' )"
        read -r resolution_v <<< "$resolution_v"

        screen_size_h="$( echo "$buf" | grep "[[:digit:]]mm" | head -1 | sed -e 's|mm||g' )"
        screen_size_v="$( echo "$buf" | grep "[[:digit:]]mm" | tail -1 | sed -e 's|mm||g' )"

        if [[ -n "$screen_size_v" ]] && [[ -n "$screen_size_h" ]] && [[ "${screen_size_v%.*}" -gt 0 ]] && [[ "${screen_size_h%.*}" -gt 0 ]] ; then
            screen_size_h="$( echo "$screen_size_h / 25.4" | LC_ALL=C  bc -l )"
            screen_size_v="$( echo "$screen_size_v / 25.4" | LC_ALL=C  bc -l )"
        fi
    else
        NOREPORTS=1 el_error "missing dependency: xrandr"
    fi

    if [[ -n "$screen_size_v" ]] && [[ -n "$screen_size_h" ]] && [[ "${screen_size_v%.*}" -gt 0 ]] && [[ "${screen_size_h%.*}" -gt 0 ]] && [[ -n "$resolution_v" ]] && [[ -n "$resolution_h" ]] ; then
        dpi_h="$( echo "$resolution_h / $screen_size_h" | LC_ALL=C  bc -l | sed -e 's|\..*$||g' )"
        dpi_v="$( echo "$resolution_v / $screen_size_v" | LC_ALL=C  bc -l | sed -e 's|\..*$||g' )"
        # round it into steps of 10?
        #dpi_rounded="$((m=dpi_h%10, d=dpi_h-m, m >= 10/2 ? d+10 : d))"


        if [[ -n "$dpi_h" ]] && [[ -n "$dpi_v" ]] ; then

            case "$1" in
                lowered)
                    # reduce dpi by 3 / 4 which looks better
                    dpi_lowered="$( echo "((( ${dpi_h} / 4 ) * 3 ) / 96 ) * 100" | LC_ALL=C  bc -l | sed -e 's|\..*$||g' )"
                    if [[ -n "$dpi_lowered" ]] ; then
                        if [[ "$dpi_lowered" -le 98 ]] ; then
                            # 96 should be the min default
                            echo "96x96"
                        else
                            echo "${dpi_lowered}x${dpi_lowered}"
                        fi
                    else
                        echo "${dpi_h}x${dpi_v}"
                        el_warning "unable to lower the dpi calculation, used the original values instead: ${dpi_h}x${dpi_v}"
                    fi
                    ;;

                rounded)
                    if [[ "${dpi_h}" -le 80 ]] ; then
                        echo "96x96"
                        # temporal debug: this value should be correct?
                        el_error "wrong dpi fetch? ${dpi_h}x${dpi_v}"
                        return 0

                    elif [[ "${dpi_h}" -le 120 ]] ; then
                        echo "96x96"
                        return 0
                    elif [[ "${dpi_h}" -le 165 ]] ; then
                        # 96 x 1.5
                        echo "144x144"
                        return 0
                    elif [[ "${dpi_h}" -le 200 ]] ; then
                        # 96 x 2
                        echo "192x192"
                        return 0
                    #elif [[ "${dpi_h}" -le 300 ]] ; then
                    elif [[ "${dpi_h}" -le 300 ]] ; then
                        # 96 x 2.5
                        echo "240x240"
                        return 0
                    else
                        # 96 x 3 | this should be the maximum default value for now
                        echo "288x288"
                        if [[ "${dpi_h}" -ge 400 ]] ; then
                            el_error "wrong dpi fetch? ${dpi_h}x${dpi_v}"
                        fi
                        return 0
                    fi
                    ;;

                *)
                    echo "${dpi_h}x${dpi_v}"
                    return 0
                    ;;
            esac
        else
            el_error "problem fetching DPI sizes - $resolution_v - $resolution_h | $screen_size_v - $screen_size_h | $dpi_v - $dpi_h | $buf"
        fi

    else
        # fallback value when we don't have screen sizes and similar
        echo "96x96"
        return 0
    fi
}


#-------------------------------------------------------------------------------
#   Dependencies Check
#-------------------------------------------------------------------------------
el_dependencies_check(){ # check if we have these command dependencies, if not, notify and exit
    # example:  el_dependencies_check gmplayer|find|sed|etc
    local check found found_no dir

    while read -ru 3 check
    do
        unset found

        for dir in ${PATH//:/ } /usr/local/sbin /usr/sbin /sbin
        do
            if test -x "${dir}/$check"
            then
                found=yes
                break
            fi
        done

        if [[ "$found" != "yes" ]] ; then
            NOREPORTS=1 el_error "Command '$check' for $(basename $0) not found, func: ${FUNCNAME[1]}"
            found_no="yes"
        fi
    done 3<<< "$( echo "${@}" | tr '|' '\n' )"


    if [[ "$found_no" = "yes" ]] ; then
        return 1
    else
        return 0
    fi
}


#-------------------------------------------------------------------------------
#   Install required packages
#-------------------------------------------------------------------------------
el_dependencies_install(){
    local depends temp is_password_ok

    depends="$( echo "$@" | tr '|' ' ' )"
    el_set_display_variables

    # TODO: move to terminology when compatibility will be implemented
    # TODO:  even better: use a gui tool for install deps
    el_dependencies_check urxvt

    temp="/tmp/.$(basename $0)-${USER}-$$"
    cat > "${temp}" << EOF
#!/bin/bash
SOURCE=dummy

echo -e "Installing Dependencies"

if [[ -x "\$( which urxvt )" ]] ; then
    urxvt -T 'Installing Packages' -e bash -c "
source /usr/lib/elive-tools/functions
export TERM=screen-256color ; export DEBIAN_FRONTEND=noninteractive ; export DEBIAN_PRIORITY=critical ; export DEBCONF_NONINTERACTIVE_SEEN=true ; export DEBCONF_NOWARNINGS=true

if ! apt-get install -y $depends ; then
    el_aptget_update force
    apt-get -f install

    if ! apt-get install -y $depends ; then
        apt-get -f install ; el_aptget_update force ; apt-get install $depends
    fi
fi
echo ; echo ; echo ; echo ; echo 'All Done' ; sleep 2
"


else
    if [[ -n "\$TERM" ]] ; then
        su -c "
source /usr/lib/elive-tools/functions
export TERM=screen-256color ; export DEBIAN_FRONTEND=noninteractive ; export DEBIAN_PRIORITY=critical ; export DEBCONF_NONINTERACTIVE_SEEN=true ; export DEBCONF_NOWARNINGS=true

if ! apt-get install -y $depends ; then
    el_aptget_update force
    apt-get -f install
    if ! apt-get install -y $depends ; then
        apt-get -f install ; el_aptget_update force ; apt-get install $depends
    fi
fi
echo ; echo ; echo ; echo ; echo 'All Done' ; sleep 2
" root

    else
        el_error "unable to intall dependencies, we don't have access to urxvt or a terminal to do it"
        sleep 6
    fi
fi

EOF

    chmod +x "${temp}"

    if [[ "$UID" = 0 ]] ; then
        bash "$temp"
    else
        if el_check_sudo_automated ; then
            for i in 1 2
            do
                if sudo -H bash "$temp" ; then
                    is_password_ok=1
                    break
                fi
            done
        else
            # deps
            if ! el_dependencies_check gksu ; then
                if [[ -x "$( which urxvt )" ]] ; then
                    urxvt -e bash -c "echo -e 'Installing Dependencies' ; su -c 'TERM=screen-256color DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true apt-get update ; apt-get install -y gksu ; ' root"
                else
                    if ((is_interactive)) ; then
                        su -c 'apt-get update ; TERM=screen-256color DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true apt-get update ; apt-get install -y gksu ; ' root
                    fi
                fi
            fi

            if [[ -x "$( which gksu )" ]] ; then
                # multiple gksu attempts
                for i in 1 2
                do
                    if gksu "$temp" ; then
                        is_password_ok=1
                        break
                    fi
                done
            else
                if ((is_interactive)) ; then
                    el_info "Installing Dependencies"

                    if su -c "$temp" root ; then
                        break
                    fi
                else
                    el_error "unable to run $temp, we don't have gksu, graphical system, or even a terminal where to do it"
                fi
            fi
        fi
    fi

    #if ! ((is_password_ok)) && [[ "${DISPLAY}" = ":0.0" ]] ; then
        #timeout 40 $guitool --error --text="${SOURCE}: "$( eval_gettext "Wrong password" )""
    #fi

    rm -f "${temp}"

}

#-------------------------------------------------------------------------------
#   Run apt-get update
#-------------------------------------------------------------------------------
el_aptget_update(){
    local message_updating force want_update buf is_password_ok
    force="$1"

    el_set_display_variables


    if [[ "$force" = "force" ]] ; then
        want_update=1
    fi

    if [[ -e "/var/lib/apt/periodic/update-success-stamp" ]] ; then
        buf="$( echo "$(date +%s) - $( stat -c %Y /var/lib/apt/periodic/update-success-stamp 2>/dev/null )" | LC_ALL="$EL_LC_EN" bc -l | sed -e 's|\..*$||g' )"
        if [[ -n "$buf" ]] && [[ "$buf" -gt 14400 ]] ; then
            want_update=1
        fi
    else
        want_update=1
    fi

    if ((want_update)) ; then
        # only run update if we have not updated already 4 hours ago
        local _dummy
        _dummy="$( printf "$( eval_gettext "Updating list of packages" )" )"
        # note: to have translated the next message we need a different declaration ^ so that the string is considered into the including for translate (without TEXTDOMAIN)
        message_updating="$( printf "$( TEXTDOMAIN="elive-tools" eval_gettext "Updating list of packages" )" )"

        if ! el_verify_internet 2>/dev/null 1>&2 ; then
            sleep 5
            if ! el_verify_internet 2>/dev/null 1>&2 ; then
                el_error "We need to update the packages lists but we don't have internet? ignoring update..."
                return 1
            fi
        fi

        # wait for unlock
        el_aptget check 1>/dev/null

        if [[ "$UID" = 0 ]] ; then
            if [[ "${DISPLAY}" = ":0.0" ]] && ! ((is_quiet)) && [[ -n "$guitool" ]]  ; then
                { apt-get update || apt-get update ; } | $guitool --progress --pulsate --percentage=0 --auto-close --text="$message_updating"
            else
                el_aptget update || el_aptget update
            fi
        else
            if el_check_sudo_automated ; then
                if [[ "${DISPLAY}" = ":0.0" ]] && ! ((is_quiet)) && [[ -n "$guitool" ]] ; then
                    { sudo apt-get update || sudo apt-get update ; } | $guitool --progress --pulsate --percentage=0 --auto-close --text="$message_updating"
                else
                    sudo apt-get update || sudo apt-get update
                fi
            else
                if [[ "${DISPLAY}" = ":0.0" ]] ; then
                    if ! el_dependencies_check gksu ; then
                        el_dependencies_install "gksu"
                    fi
                    #gksu apt-get update | $guitool --progress --pulsate --percentage=0 --auto-close --text="$message_updating"
                    # multiple gksu attempts
                    for i in 1 2
                    do
                        if gksu "$temp" ; then
                            if gksu apt-get update | $guitool --progress --pulsate --percentage=0 --auto-close --text="$message_updating" ; then
                                is_password_ok=1
                                break
                            fi
                        fi
                    done

                    if ! ((is_password_ok)) && [[ "${DISPLAY}" = ":0.0" ]] ; then
                        timeout 40 $guitool --error --text="${SOURCE}: "$( eval_gettext "Wrong password" )""
                    fi

                else
                    su -c "echo 'Updating Package Lists' ; apt-get update || apt-get update" root
                fi
            fi
        fi

    else
        el_explain 3 "Packages lists already updated at least 4 hours ago, skipping update"
    fi
}
#-------------------------------------------------------------------------------
#   Check if a newer version of a package exists
#-------------------------------------------------------------------------------
el_package_newer_check(){
    local package installed candidate
    # XXX important: this uses apt caches, doesn't check for online version

    package="$1"

    if [[ -z "$package" ]] ; then
        return 2
    fi

    installed="$( el_apt_package_version_get "$package" installed full )"
    candidate="$( el_apt_package_version_get "$package" candidate full )"

    if [[ -n "$installed" ]] && [[ -n "$candidate" ]] ; then
        if dpkg --compare-versions "${candidate}" gt "${installed}" ; then
            return 0
        else
            return 1
        fi
    else
        el_error "no versions get correctly for package ${package}, installed is '${installed}', candidate is '${candidate}', func: ${FUNCNAME[1]}"
        return 1
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_package_upgrade_fast
#   DESCRIPTION:  update and install a package in a very fast and light way
#                 WARNING: this is not a reliable tool, use with caution
#                 notes:
#                   - packages should include DATESTAMP in their version, so then the "normal" mode will work without problems and not neededing the "force" one (not needed to allow downgrades)
#                   - packages should include DISTRO in the version, in order to not install a candidate from a different distro
#    PARAMETERS:  $1 = timeout for each package to download, $2 = force|normal, $@ = packages
#                 normal means that only newer packages will be installed, force will allow downgrades
#       RETURNS:  true if something was installed, false if failed or nothing found to install
#===============================================================================
el_package_upgrade_fast(){
    # pre {{{
    local tmpdir timeout package installed url_subdir url distro package_url candidate mode dirprev failed arch is_download

    timeout="$1"
    shift
    mode="$1"
    shift

    tmpdir="/tmp/.$(basename $0)_${FUNCNAME}_${USER}"
    failed=0

    if [[ -z "$@" ]] ; then
        NOREPORTS=1 el_error "Wrong parameters given, should be: $FUNCNAME timeout mode packages"
        return 1
    fi

    # }}}
    dirprev="$(pwd)"
    mkdir -p "$tmpdir"
    cd "$tmpdir"

    if ! el_verify_internet 2>/dev/null 1>&2 ; then
        el_debug "no internet found, ignoring"
        return 1
    fi

    # checks
    if ! ls /var/lib/apt/lists/*Packages 1>/dev/null 2>&1 ; then
        # wait for unlock
        el_aptget check 1>/dev/null

        el_aptget_update force

        if ! ls /var/lib/apt/lists/*Packages 1>/dev/null 2>&1 ; then
            el_error "we don't have an ending *Packages file in our apt lists available"
        fi
    fi

    for package in "$@"
    do
        unset is_download installed arch url_subdir url distro candidate package_url failed
        [[ -z "$package" ]] && continue

        # example:  3.8.9+0.0.1+git3118fc936-6buster11
        installed="$( el_apt_package_version_get "$package" installed full )"
        if [[ -z "$installed" ]] ; then
            el_error "unable to get the version of installed package '${package}': $installed:\n$( LC_ALL=C apt-cache policy $package )"
            continue
        fi

        # example:  all
        arch="$( LC_ALL=C dpkg -l | grep -E "^(ii|hi)\s+${package}(:.*\s+)?\s+" | awk '{print $4}' )"
        case "$arch" in
            amd64|i386)
                arch="_${arch}"
                ;;
            all)
                arch="_all"
                ;;
            *)
                el_error "unable to get the arch value for package '${package}': $arch"
                continue
                ;;
        esac

        # example:  pool/main/e/elive-tools/
        url_subdir="$( LC_ALL=C grep -h "^Filename: .*/${package}/" /var/lib/apt/lists/*Packages | sed -e "s|/${package}_.*$|/|g" -e 's|^Filename: ||g' | sort -u | head -1  )"
        if [[ -z "$url_subdir" ]] ; then
            # force update if is not found:
            el_aptget_update force

            url_subdir="$( LC_ALL=C grep -h "^Filename: .*/${package}/" /var/lib/apt/lists/*Packages | sed -e "s|/${package}_.*$|/|g" -e 's|^Filename: ||g' | sort -u | head -1  )"
            if [[ -z "$url_subdir" ]] ; then
                el_error "unable to get the url_subdir for package '${package}': $url_subdir"
                continue
            fi
        fi

        # example:  file:///home/thana/packages/mirror-elive/elive/
        # example:  http://repo.buster.elive.elivecd.org/
        url="$( grep -hE "^deb (http.*elivecd.org|file:///)" /etc/apt/sources.list.d/*elive.list | awk '{print $2}' | tail -1 )"
        if [[ -n "$url" ]] ; then
            #make sure we end on slash
            url="${url%/}/"
        else
            el_error "unable to get the 'url' for package '${package}': $(grep -h "^deb " /etc/apt/sources.list.d/*elive.list )\nthis feature only works for now with packages from the Elive repository"
            continue
        fi

        # example:  buster
        distro="$( grep -hE "^deb (http.*elivecd.org|file:///)" /etc/apt/sources.list.d/*elive.list | awk '{print $3}' | tail -1 )"
        if [[ -z "$distro" ]] ; then
            el_error "unable to get the 'distro' for package '${package}': $(grep -h "^deb " /etc/apt/sources.list.d/*elive.list )"
            continue
        fi

        # example:  http://repo.buster.elive.elivecd.org/pool/main/e/elive-tools/elive-tools_3.8.9+0.0.1+git3118fc936-6buster11_all.deb
        # example:  /home/thana/packages/mirror-elive/elive/pool/main/e/elive-tools/elive-tools_3.8.9+0.0.1+git3118fc936-6buster11_all.deb
        case "$url" in
            "file:///"*)
                package_url="${url#file://}${url_subdir}$( ls -1 "${url#file://}${url_subdir}" | grep "${package_}_.*${distro}.*${arch}\.deb" | sort -uV | tail -1 )"
                if ! [[ -s "$package_url" ]] ; then
                    el_error "unable to get the 'package_url' for package '${package}' in file:/// mode:\n$( ls "${url#file://}${url_subdir}" | grep "${package}.*\.deb" )"
                    continue
                fi
                ;;
            "http"*)
                package_url="$( lynx -read_timeout 12 -connect_timeout 12 -dump "${url}${url_subdir}" | grep "http.*/${package}_.*${distro}.*${arch}\.deb" | sed -e 's|^.* http|http|g' | tail -1 )"
                # try again, sometimes fails
                if [[ -z "$package_url" ]] ; then
                    for i in $(seq 3)
                    do
                        sleep 5
                        package_url="$( COLUMNS=800 LC_ALL=$EL_LC_EN  lynx -read_timeout 30 -connect_timeout 30 -dump "${url}${url_subdir}" | grep "http.*/${package}_.*${distro}.*${arch}\.deb" | sed -e 's|^.* http|http|g' | tail -1 )"
                        [[ -n "$package_url" ]] && break
                    done
                fi
                if [[ -z "$package_url" ]] ; then
                    el_error "unable to get the 'package_url' for package '${package}' distro '${distro}' arch '${arch}' :\n$( lynx -read_timeout 20 -connect_timeout 20 -dump "${url}${url_subdir}" | grep "${package}.*\.deb" )"
                    continue
                fi

                ;;
        esac

        # example:  3.8.9+0.0.1+git3118fc936-6buster11
        candidate="$( echo "$package_url" | sed -e "s|^.*/${package}_||g" -e 's|_.*$||g' )"
        if [[ -z "$candidate" ]] ; then
            el_error "unable to get the 'candidate' for package '${package}': $(echo "$package_url" )"
            continue
        fi

        # install dependencies if needed
        if ! el_dependencies_check wget ; then
            el_dependencies_install "wget"
        fi

        # update: if force, we don't care now about the specific version, because we allow downgrades:
        case "$mode" in
            force)
                # different version
                if [[ "$installed" != "$candidate" ]] ; then
                    el_debug "downloading candidate for ${package}, installed '$installed' vs candidate '${candidate}': ${package_url} "
                    is_download=1
                fi
                ;;
            normal)
                if dpkg --compare-versions "$installed" lt "$candidate" ; then
                    el_debug "new version for ${package}, installed '$installed' vs candidate '${candidate}': ${package_url}"
                    is_download=1
                fi
                ;;
            *)
                el_warning "unknown mode $mode for $FUNCNAME"
                ;;
        esac

        if ((is_download)) ; then
            case "$package_url" in
                "/"*)     cp -f "$package_url" .  ; ;;
                "http"*)  timeout ${timeout} wget -qc "$package_url"  ; ;;
            esac
        fi
    done

    # install all downloaded packages
    if ls *deb  1>/dev/null 2>&1 ; then
        el_debug "going to install:\n$( ls -1 *deb )"

        # wait for unlock
        el_aptget check 1>/dev/null

        if [[ "$UID" = 0 ]] ; then
            TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  dpkg -i *deb 1>/dev/null
            TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  dpkg --configure -a

            if TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  el_aptget -f install -q=2 -y ; then
                el_debug "updated packages successfully: $@"
                failed=0
            else
                sleep 10
                # check for good state
                el_aptget check 1>/dev/null

                TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  dpkg --configure -a
                TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  el_aptget -f install -q=2 -y


                # try to install again
                TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  dpkg -i *deb 1>/dev/null
                TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  dpkg --configure -a

                if TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  el_aptget -f install -q=2 -y ; then
                    el_debug "updated packages successfully: $@"
                    failed=0
                else
                    failed=1
                fi
            fi
        else
            el_sudo dpkg -i *deb
            el_sudo dpkg --configure -a

            if el_aptget -f install -q=2 -y ; then
                el_debug "updated packages successfully: $@"
                failed=0
            else
                el_sudo dpkg --configure -a
                el_sudo apt-get -f install -q=2 -y
                # try again
                el_sudo dpkg -i *deb
                el_sudo dpkg --configure -a

                if el_aptget -f install -q=2 -y ; then
                    el_debug "updated packages successfully: $@"
                    failed=0
                else
                    failed=1
                fi
            fi
        fi
    else
        return 1
    fi

    cd "$dirprev"
    rm -rf "$tmpdir"

    # exit with the validated status
    if ((failed)) ; then
        return 1
    else
        return 0
    fi
}

#-------------------------------------------------------------------------------
#   Check if variable exists
#-------------------------------------------------------------------------------
el_check_variables(){ # check if we have set these variables, if not, notify and exit
    # example $0 foo,bar,we
    # note: if you get an error from this function, note that the function needs to be called with the varname, not its $value
    local found_no _var

    while read -ru 3 _var
    do
        if [[ -n "$ZSH_VERSION" ]] ; then
            if [[ ! -n "${(P)_var}" ]] ; then
                NOREPORTS=1 el_error "Variable '$_var' is not set, func: ${FUNCNAME[1]}"
                found_no="yes"
            fi
        else
            if [[ ! -n "${!_var}" ]] ; then
                NOREPORTS=1 el_error "Variable '$_var' is not set, func: ${FUNCNAME[1]}"
                found_no="yes"
            fi
        fi
    done 3<<< "$( echo "${@}" | tr '|' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then
        return 1
    else
        return 0
    fi
}


#-------------------------------------------------------------------------------
#   Check if files exists
#-------------------------------------------------------------------------------
el_check_files(){ # check if we have these files (and non-zero), if not, notify and exit
    # example $0 foo,bar,we
    local _var found_no

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)" 1>&2

        return 1
    fi

    while read -ru 3 _var
    do
        if [[ ! -s "${_var}" ]] ; then
            NOREPORTS=1 el_error "File '$_var' not exist, func: ${FUNCNAME[1]}"
            found_no="yes"
        fi
    done 3<<< "$( echo "${@}" | tr '|' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then
        return 1
    else
        return 0
    fi

}


#-------------------------------------------------------------------------------
#   Check if dir exists
#-------------------------------------------------------------------------------
el_check_dirs(){ # check if we have these dirs (and non-zero), if not, notify and exit
    # example $0 foo,bar,we
    local found_no line

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)" 1>&2

        return 1
    fi

    while read -ru 3 line
    do
        if [[ ! -d "${line}" ]] ; then
            NOREPORTS=1 el_error "Directory '$line' not exist, func: ${FUNCNAME[1]}"
            found_no="yes"
        fi
    done 3<<< "$( echo "${@}" | tr '|' '\n' )"

    if [[ "$found_no" = "yes" ]] ; then
        return 1
    else
        return 0
    fi
}


#-------------------------------------------------------------------------------
#   check if dir has files
#-------------------------------------------------------------------------------
el_check_dir_has_files(){
    local dir f files

    if [[ -z "$1" ]] ; then
        echo -e "E: $FUNCNAME called without parameters (nothing to check?)" 1>&2
        return 1
    fi

    while read -ru 3 dir
    do
        if [[ ! -d "$dir" ]] && [[ ! -L "$dir" ]] ; then
            el_debug "Directory '$dir' not exist, func: ${FUNCNAME[1]}"

            return 1
        else
            files="$( command ls -1 "${dir%/}/"* 2>/dev/null | wc -l )"
            if ! [[ "$files" -gt 0 ]] ; then
                el_debug "Directory '$dir' doesn't contain any file, func: ${FUNCNAME[1]}"

                return 1
            fi
        fi
    done 3<<< "$( echo "${@}" | tr '|' '\n' )"
}

#-------------------------------------------------------------------------------
#   check if we have automatic sudo
#-------------------------------------------------------------------------------
el_check_sudo_automated(){
    if sudo -H -n echo 2>/dev/null 1>/dev/null ; then
        return 0
    else
        el_debug "Automated sudo is required: Your sudo requires a password, we need it to be configured for not request it, func: ${FUNCNAME[1]}"
        return 1
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  el_sudo
#   DESCRIPTION:  run a command from root, as much as possible
#    PARAMETERS:  args/command
#       RETURNS:  -
#===============================================================================
el_sudo(){
    # pre {{{
    local args is_password_ok
    el_security_function_loop || return 0

    args="$@"
    el_check_variables "args"

    el_set_display_variables

    # }}}
    if el_check_sudo_automated 2>/dev/null 1>&2 ; then
        sudo -H -n "$@"
    else
        # check if we have direct access to this sudo command without prompt:
        if ! sudo -H "$@" ; then

            if [[ "${DISPLAY}" = ":0.0" ]] ; then
                if ! el_dependencies_check gksu ; then
                    el_dependencies_install "gksu"
                fi

                # multiple gksu attempts
                for i in 1 2
                do
                    if gksu "$@" ; then
                        is_password_ok=1
                        break
                    fi
                done

                if ! ((is_password_ok)) && [[ "${DISPLAY}" = ":0.0" ]] ; then
                    timeout 40 $guitool --error --text="${SOURCE}: "$( eval_gettext "Wrong password" )""
                fi
            else
                el_info "Insert Admin Password to run: $@"
                su -c "$@" root
            fi
        fi
    fi

}
#===  FUNCTION  ================================================================
#          NAME:  el_check_translations_required
#   DESCRIPTION:  check the amount of translations made for actual application
#    PARAMETERS:  -
#   RETURNS:      true or false
#===============================================================================
el_check_translations_required(){
    # pre {{{
    local textdomaindir stat percentage_untranslated is_translation_required mode


    if [[ -n "$TEXTDOMAINDIR" ]] ; then
        textdomaindir="$TEXTDOMAINDIR"
    else
        textdomaindir="/usr/share/locale"
    fi

    # dont annoy users in the stable released
    if ! el_check_version_development ; then
        return 1
    fi

    mode="$1"
    if [[ -z "$mode" ]] ; then
        el_warning "deprecated use of $FUNCNAME from ${FUNCNAME[1]} without the \$mode var set"
    fi

    # }}}

    if [[ -n "$TEXTDOMAIN" ]] ; then
        # we already said it ?
        if el_flag check "translation_required_${TEXTDOMAIN}" ; then
            return 1
        fi
        el_flag add "translation_required_${TEXTDOMAIN}"

        # deprecated location
        #stat="${textdomaindir}/${LANG%%_*}/statistics/${TEXTDOMAIN}.txt"
        stat="/var/cache/elive-translations/statistics/${LANG%%_*}/${TEXTDOMAIN}.txt"

        if [[ -s "${stat}" ]] ; then
            percentage_untranslated="$(cat "${stat}" | LC_ALL=C grep -F "messages_untranslated_percentage" | awk '{print $2}' | tail -1 )"

            if [[ -n "${percentage_untranslated}" ]] && [[ "${percentage_untranslated}" -gt 6 ]] ; then
                is_translation_required=1
            fi
        fi
    fi


    if ((is_translation_required)) ; then

        case "$mode" in
            report)
                el_notify normal gtranslator "$( eval_gettext "Elive Translations" )" "$( eval_gettext "This application is not fully translated to your language. You can use Eltrans to help to improve the Elive translations. Everybody will enjoy Elive correctly translated into your language too!" )"
                ;;
        esac

        return 0
    else
        return 1
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  el_check_version_development
#   DESCRIPTION:  checks if we are in a development version
#    PARAMETERS:  -
#       RETURNS:  true if we are development state, false if we are stable
#===============================================================================
el_check_version_development(){
    if [[ -e "/etc/elive-version" ]] ; then
        if [[ "$( LC_ALL=C grep "^stable-release" /etc/elive-version | awk '{print $2}' )" = yes ]] ; then
            return 1
        else
            return 0
        fi
    else
        NOREPORTS=1 el_error "File /etc/elive-version not found, func: ${FUNCNAME[1]}"
        return 0
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_elive_version_get
#   DESCRIPTION:  Get the version number of the HOST (installed) elive system
#    PARAMETERS:  -
#       RETURNS:  version number
#===============================================================================
el_elive_version_get(){
    # pre {{{
    local version
    el_debug
    el_security_function_loop || return 0

    # }}}
    version="$( LC_ALL=C grep "^elive-version: " "/etc/elive-version" )"
    version="${version#elive-version: }"

    if [[ -z "$version" ]] ; then
        version="2.9.99"
    fi

    if [[ -n "$version" ]] ; then
        echo "$version"
    else
        el_error "Unable to get this version of Elive ID number"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_check_version_is_days_recent
#   DESCRIPTION:  check if this version is less than $1 ~days old
#    PARAMETERS:  $1 = days old to check
#       RETURNS:  true if is less than $1 old, false if we are older than it
#===============================================================================
el_check_version_is_days_recent(){
    # pre {{{
    local date_builded_y date_builded_m date_builded_d date_today_y date_today_m date_today_d days_required date_builded date_today date_builded_total_days days_difference date_today_total_days
    el_debug
    el_security_function_loop || return 0

    days_required="$1"

    # }}}

    # calculate date builded {{{

    date_builded="$( LC_ALL=C grep "^date-builded" /etc/elive-version | sed -e 's|date-builded: ||g' )"
    if [[ -z "$date_builded" ]] ; then
        date_builded="2018-05-00"
    fi

    date_builded_y="${date_builded%%-*}"

    date_builded_m="${date_builded%-*}"
    date_builded_m="${date_builded_m#*-}"
    date_builded_m="${date_builded_m#0}"

    date_builded_d="${date_builded##*-}"
    date_builded_d="${date_builded_d#0}"

    date_builded_total_days="$(( ${date_builded_m} * 30 + ${date_builded_d} ))"
    date_builded_total_days="$(( ${date_builded_y} * 365 + ${date_builded_total_days} ))"

    # - calculate date builded }}}
    # calculate date today {{{

    date_today="$( date +%F )"

    date_today_y="${date_today%%-*}"

    date_today_m="${date_today%-*}"
    date_today_m="${date_today_m#*-}"
    date_today_m="${date_today_m#0}"

    date_today_d="${date_today##*-}"
    date_today_d="${date_today_d#0}"

    date_today_total_days="$(( ${date_today_m} * 30 + ${date_today_d} ))"
    date_today_total_days="$(( ${date_today_y} * 365 + ${date_today_total_days} ))"

    # - calculate date today }}}
    #el_check_variables "date_builded|date_today|date_builded_total_days|date_today_total_days"
    days_difference="$(( ${date_today_total_days} - ${date_builded_total_days} ))"

    # retrun false if we have any error calculating it
    if [[ -z "$days_difference" ]] || [[ -z "$days_required" ]] ; then
        return 1
    fi

    if [[ "$days_difference" -le "$days_required" ]] ; then
        return 0
    else
        return 1
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  el_check_version_development_is_days_recent
#   DESCRIPTION:  check if this development version is less than $1 ~days old
#    PARAMETERS:  $1 = days old to check
#       RETURNS:  true if is less than $1 old, false if we are older than it
#===============================================================================
el_check_version_development_is_days_recent(){
    # pre {{{
    local date_builded_y date_builded_m date_builded_d date_today_y date_today_m date_today_d days_required date_builded date_today date_builded_total_days days_difference date_today_total_days
    el_debug
    el_security_function_loop || return 0

    days_required="$1"

    if ! el_check_version_development ; then
        # stable versions should be not considered recent dev versions
        return 1
    fi

    # }}}

    # calculate date builded {{{

    date_builded="$( LC_ALL=C grep "^date-builded" /etc/elive-version | sed -e 's|date-builded: ||g' )"
    if [[ -z "$date_builded" ]] ; then
        date_builded="2018-05-00"
    fi

    date_builded_y="${date_builded%%-*}"

    date_builded_m="${date_builded%-*}"
    date_builded_m="${date_builded_m#*-}"
    date_builded_m="${date_builded_m#0}"

    date_builded_d="${date_builded##*-}"
    date_builded_d="${date_builded_d#0}"

    date_builded_total_days="$(( ${date_builded_m} * 30 + ${date_builded_d} ))"
    date_builded_total_days="$(( ${date_builded_y} * 365 + ${date_builded_total_days} ))"

    # - calculate date builded }}}
    # calculate date today {{{

    date_today="$( date +%F )"

    date_today_y="${date_today%%-*}"

    date_today_m="${date_today%-*}"
    date_today_m="${date_today_m#*-}"
    date_today_m="${date_today_m#0}"

    date_today_d="${date_today##*-}"
    date_today_d="${date_today_d#0}"

    date_today_total_days="$(( ${date_today_m} * 30 + ${date_today_d} ))"
    date_today_total_days="$(( ${date_today_y} * 365 + ${date_today_total_days} ))"

    # - calculate date today }}}
    #el_check_variables "date_builded|date_today|date_builded_total_days|date_today_total_days"
    days_difference="$(( ${date_today_total_days} - ${date_builded_total_days} ))"

    # retrun false if we have any error calculating it
    if [[ -z "$days_difference" ]] || [[ -z "$days_required" ]] ; then
        return 1
    fi


    if [[ "$days_difference" -le "$days_required" ]] ; then
        return 0
    else
        return 1
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  el_check_is_shell
#   DESCRIPTION:  check if we are running from a shell
#    PARAMETERS:  -
#       RETURNS:  true if we are a shell, false if we are not
#===============================================================================
el_check_is_shell(){
    # pre {{{
    #el_security_function_loop || return 0

    # }}}
    # check when in bash
    if [[ "$0" = "bash" ]] ; then
        return 0
    fi

    # check when in zsh
    if [[ -n "$ZSH_VERSION" ]] && [[ -z "$ZSH_SCRIPT" ]] ; then
        return 0
    fi

    # anything else is a script
    return 1
}

#===  FUNCTION  ================================================================
#          NAME:  el_explain
#   DESCRIPTION:  function to show the progress of the application
#    PARAMETERS:
# verbose_level:    $1 = any number, from $EL_DEBUG levels
#                        levels: 0 = always|error, 1 = warning, 2 = info, 3 = debug
#       message:    $2 = can include: __hilight words__, XXsuper hilightXX
#===============================================================================
el_explain(){
    # pre {{{
    if ! ((is_interactive)) || [[ "${EL_DEBUG}" -eq 0 ]] ; then
        return 0
    fi

    local funclevel spaced verbose_level message trace_message trace_col

    verbose_level="$1"
    shift
    message="$@"

    # show only if we are on this verbose level
    if ! [[ "${EL_DEBUG}" -ge "$verbose_level" ]] ; then
        return 0
    fi

    #spaced="$verbose_level"
    funclevel="$(( ${#FUNCNAME[*]} - 2 ))"

    el_check_variables "verbose_level|message"
    # }}}
    # tabulate output {{{
    #while [[ $spaced -gt 0 ]] ; do
        #message="  $message"
        #spaced="$(( $spaced - 1 ))"
    #done

    # }}}
    # hilight words {{{
    message="${message/__/${el_c_b}}"
    message="${message/__/${el_c_gr}}"
    message="${message/__/${el_c_b}}"
    message="${message/__/${el_c_gr}}"
    message="${message/__/${el_c_b}}"
    message="${message/__/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    message="${message/XX/${el_c_r}}"
    message="${message/XX/${el_c_gr}}"
    # }}}
    # show {{{
    # this is a good example of levels of colors visualization for the user's eye
    # show normal message unless we are at a debugging level
    if [[ "${EL_DEBUG}" -ge 3 ]] ; then
        case $funclevel in
            1)
                echo -en " ${el_c_gr}[${el_c_b2}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            2)
                echo -en " ${el_c_gr}[${el_c_b}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            3)
                echo -en " ${el_c_gr}[${el_c_c2}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            4)
                echo -en " ${el_c_gr}[${el_c_c}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            5)
                echo -en " ${el_c_gr}[${el_c_g2}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            6)
                echo -en " ${el_c_gr}[${el_c_g}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            7)
                echo -en " ${el_c_gr}[${el_c_y2}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            8)
                echo -en " ${el_c_gr}[${el_c_y}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            9)
                echo -en " ${el_c_gr}[${el_c_r2}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            10)
                echo -en " ${el_c_gr}[${el_c_r}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            11)
                echo -en " ${el_c_gr}[${el_c_m2}${verbose_level}${el_c_gr}] " 1>&2
                ;;
            *)
                echo -en " ${el_c_gr}[${el_c_m}${verbose_level}${el_c_gr}] " 1>&2
                ;;
        esac
    else
        echo -en "${el_c_gr}  " 1>&2
    fi

    # continuation of the message
    echo -e "${message}${el_c_n}" 1>&2

    # }}}
}
#===  FUNCTION  ================================================================
#          NAME:  el_debug
#   DESCRIPTION:  show debug messages | EL_DEBUG -ge 3|4
#    PARAMETERS:  optional (message)
#===============================================================================
el_debug(){
    # pre {{{
    if ! [[ "${EL_DEBUG}" -ge 3 ]] || ! ((is_interactive)) ; then
        return 0
    fi
    # don't show debug messages from this own tool (like if we are in a shell and the functions calls themselves)
    # check if we have the variable set, because we need to use it (so this may not work in ZSH)
    if [[ -z "${BASH_SOURCE[@]}" ]] && ! el_check_is_shell ; then
        return 0
    fi

    local count counter funcnames sourcenames_arr arg sourcename message
    message="$@"

    # }}}
    # get the list of function names array {{{
    if [[ -n "${BASH_SOURCE[@]}" ]] && [[ "${EL_DEBUG}" -ge 3 ]] ; then
        counter="${#FUNCNAME[*]}"
        count=0
        for arg in "${FUNCNAME[@]}"
        do
            count="$(( $count + 1 ))"
            if [[ "$count" -gt 1 ]] && [[ "$count" -lt "$counter" ]] ; then
                if [[ "$arg" != "source" ]] && [[ "$arg" != "main" ]] ; then
                    funcnames="$arg > $funcnames"
                fi
            fi
        done
        funcnames="${funcnames% >*}"

        counter="${#BASH_SOURCE[*]}"
        count=0
        for arg in "${BASH_SOURCE[@]}"
        do
            count="$(( $count + 1 ))"
            if [[ "$count" -gt 1 ]] && [[ "$count" -lt "$counter" ]] ; then
                if [[ -n "$arg" ]] ; then
                    arg="$( readlink -f "$arg" || true )"
                    el_array_member_add "$arg >" "${sourcenames_arr[@]}" ; sourcenames_arr=("${_out[@]}")
                fi
            fi
        done

        sourcename="$( readlink -f "$0" || true )"
        if [[ -n "$sourcenames_arr" ]] ; then
            if [[ "${sourcenames_arr[@]}" = "$sourcename >"* ]] ; then
                sourcenames_arr="$( echo "${sourcenames_arr[@]}" | tr ' ' '\n' | tac | tr '\n' ' ' )"
            else
                sourcenames_arr="$sourcename $( echo "${sourcenames_arr[@]}" | tr ' ' '\n' | tac | tr '\n' ' ' )"
            fi
            sourcenames_arr="${sourcenames_arr% }"
            sourcenames_arr="${sourcenames_arr#> }"
            #read -r sourcenames_arr <<< "$sourcenames_arr"
        else
            sourcenames_arr="$sourcename"
        fi
    fi

    # }}}
    # show debug {{{

    if [[ -n "${BASH_SOURCE[@]}" ]] && [[ "${EL_DEBUG}" -ge 3 ]] ; then
        if [[ -n "$message" ]] ; then
            echo -e "${el_c_c}D: ${el_c_gr}[ ${sourcenames_arr} +${el_c_c2}${BASH_LINENO} ${el_c_gr}${funcnames}] ${el_c_c}$message${el_c_n}" 1>&2
        else
            echo -e "${el_c_gr}C: ${el_c_gr}[ ${sourcenames_arr} +${el_c_c2}${BASH_LINENO} ${el_c_gr}${funcnames}]${el_c_n}" 1>&2
        fi
    else
        if [[ -n "$message" ]] ; then
            echo -e "${el_c_c}D: ${el_c_c}$message${el_c_n}" 1>&2
        fi
    fi

    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_info
#   DESCRIPTION:  show info messages | (always)
#    PARAMETERS:  message
#===============================================================================
el_info(){
    # pre {{{
    if ! ((is_interactive)) || [[ "${EL_DEBUG}" -eq 0 ]] ; then
        return 0
    fi

    local count counter funcnames sourcenames_arr arg sourcename message
    message="$@"

    # }}}
    # get the list of function names array {{{
    if [[ -n "${BASH_SOURCE[@]}" ]] && [[ "${EL_DEBUG}" -ge 3 ]] ; then
        counter="${#FUNCNAME[*]}"
        count=0
        for arg in "${FUNCNAME[@]}"
        do
            count="$(( $count + 1 ))"
            if [[ "$count" -gt 1 ]] && [[ "$count" -lt "$counter" ]] ; then
                if [[ "$arg" != "source" ]] && [[ "$arg" != "main" ]] ; then
                    funcnames="$arg > $funcnames"
                fi
            fi
        done

        funcnames="${funcnames% >*}"

        counter="${#BASH_SOURCE[*]}"
        count=0
        for arg in "${BASH_SOURCE[@]}"
        do
            count="$(( $count + 1 ))"
            if [[ "$count" -gt 1 ]] && [[ "$count" -lt "$counter" ]] ; then
                if [[ -n "$arg" ]] ; then
                    arg="$( readlink -f "$arg" || true )"
                    el_array_member_add "$arg >" "${sourcenames_arr[@]}" ; sourcenames_arr=("${_out[@]}")
                fi
            fi
        done

        sourcename="$( readlink -f "$0" || true )"
        if [[ -n "$sourcenames_arr" ]] ; then
            if [[ "${sourcenames_arr[@]}" = "$sourcename >"* ]] ; then
                sourcenames_arr="$( echo "${sourcenames_arr[@]}" | tr ' ' '\n' | tac | tr '\n' ' ' )"
            else
                sourcenames_arr="$sourcename $( echo "${sourcenames_arr[@]}" | tr ' ' '\n' | tac | tr '\n' ' ' )"
            fi
            sourcenames_arr="${sourcenames_arr% }"
            sourcenames_arr="${sourcenames_arr#> }"
            #read -r sourcenames_arr <<< "$sourcenames_arr"
        else
            sourcenames_arr="$sourcename"
        fi
    fi

    # }}}
    # show info {{{

    if [[ -n "${BASH_SOURCE[@]}" ]] && [[ "${EL_DEBUG}" -ge 3 ]] ; then
        echo -e "${el_c_c2}I: ${el_c_gr}[ ${sourcenames_arr} +${el_c_c2}${BASH_LINENO} ${el_c_gr}${funcnames}] ${el_c_c2}$message${el_c_n}" 1>&2
    else
        echo -e "${el_c_c2}I: ${el_c_c2}$message${el_c_n}" 1>&2
    fi

    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_warning
#   DESCRIPTION:  show warning messages | EL_DEBUG -ge 1
#    PARAMETERS:  optional (message)
#===============================================================================
el_warning(){
    # pre {{{
    local count counter funcnames sourcenames_arr arg message is_noreports
    message="$@"

    # }}}
    # get the list of function names array {{{
    if { [[ ! -n "$NOREPORTS" ]] && [[ ! -n "$NOREPORT" ]] && [[ ! -n "$NO_ELIVETOOLS_REPORTS" ]] && { [[ -n "$REPORTS" ]] || [[ -n "$EL_REPORTS" ]] || [[ -n "$FORCE_REPORTS" ]] ; } ; }    || { [[ -n "$is_interactive" ]] && [[ -n "${BASH_SOURCE[@]}" ]] && [[ "${EL_DEBUG}" -ge 3 ]] ; } ; then

        counter="${#FUNCNAME[*]}"
        count=0
        for arg in "${FUNCNAME[@]}"
        do
            count="$(( $count + 1 ))"
            if [[ "$count" -gt 1 ]] && [[ "$count" -lt "$counter" ]] ; then
                if [[ "$arg" != "source" ]] && [[ "$arg" != "main" ]] ; then
                    funcnames="$arg > $funcnames"
                fi
            fi
        done
        funcnames="${funcnames% >*}"

        counter="${#BASH_SOURCE[*]}"
        count=0
        for arg in "${BASH_SOURCE[@]}"
        do
            count="$(( $count + 1 ))"
            if [[ "$count" -gt 1 ]] && [[ "$count" -lt "$counter" ]] ; then
                if [[ -n "$arg" ]] ; then
                    el_array_member_add "$arg >" "${sourcenames_arr[@]}" ; sourcenames_arr=("${_out[@]}")
                fi
            fi
        done
        if [[ -n "$sourcenames_arr" ]] ; then
            if [[ "${sourcenames_arr[@]}" = "$0 >"* ]] ; then
                sourcenames_arr="$( echo "${sourcenames_arr[@]}" | tr ' ' '\n' | tac | tr '\n' ' ' )"
            else
                sourcenames_arr="$0 $( echo "${sourcenames_arr[@]}" | tr ' ' '\n' | tac | tr '\n' ' ' )"
            fi
            sourcenames_arr="${sourcenames_arr% }"
            sourcenames_arr="${sourcenames_arr#> }"
            #read -r sourcenames_arr <<< "$sourcenames_arr"
        else
            sourcenames_arr="$0"
        fi
    fi

    # }}}
    # show warning {{{

    if ((is_interactive)) ; then
        if [[ "${EL_DEBUG}" -ge 1 ]] ; then
            if [[ -n "${BASH_SOURCE[@]}" ]] && [[ "${EL_DEBUG}" -ge 3 ]] ; then
                echo -e "${el_c_y2}W: ${el_c_gr}[ ${sourcenames_arr} +${el_c_c2}${BASH_LINENO} ${el_c_gr}${funcnames}] ${el_c_y2}$message${el_c_n}" 1>&2
            else
                echo -e "${el_c_y2}W: ${el_c_y2}$message${el_c_n}" 1>&2
            fi
        fi
    fi

    if [[ -n "${BASH_SOURCE[@]}" ]] ; then
        # set colors for our reports
        local el_c_n el_c_r el_c_r2 el_c_g el_c_g2 el_c_y el_c_y2 el_c_m el_c_m2 el_c_c el_c_c2 el_c_b el_c_b2
        el_c_gr="\033[1;30m" # Gray color
        el_c_gr2="\033[0;30m" # Gray2 color
        el_c_r="\033[1;31m" # Red color  (orig: red)
        el_c_r2="\033[0;31m" # Red2 color  (orig: red)
        el_c_g="\033[1;32m" # Green color  (orig: green)
        el_c_g2="\033[0;32m" # Green2 color  (orig. green2)
        el_c_y="\033[1;33m" # Yellow color  (orig. yellow)
        el_c_y2="\033[0;33m" # Yellow2 color  (orig. yellow)
        el_c_b="\033[1;34m" # Blue color
        el_c_b2="\033[0;34m" # Blue2 color
        el_c_m="\033[1;35m" # Magenta color
        el_c_m2="\033[0;35m" # Magenta2 color
        el_c_c="\033[1;36m" # Cyan color
        el_c_c2="\033[0;36m" # Cyan2 color
        el_c_w="\033[1;37m" # White
        el_c_w2="\033[0;37m" # White strong
        el_c_n="\033[0;39m" # Normal color  (orig: normal)

        el_report_to_elive "${el_c_y2}W: ${el_c_gr}[ ${sourcenames_arr} +${el_c_c2}${BASH_LINENO} ${el_c_gr}${funcnames} ] ${el_c_y2}$message${el_c_n}"
    fi

    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_error
#   DESCRIPTION:  show error messages | EL_DEBUG -ge 0
#    PARAMETERS:  optional (message)
#===============================================================================
el_error(){
    # pre {{{
    local count counter funcnames sourcenames_arr arg message
    message="$@"

    # }}}
    # get the list of function names array {{{
    if { [[ ! -n "$NOREPORTS" ]] && [[ ! -n "$NOREPORT" ]] && [[ ! -n "$NO_ELIVETOOLS_REPORTS" ]] && { [[ -n "$REPORTS" ]] || [[ -n "$EL_REPORTS" ]] || [[ -n "$FORCE_REPORTS" ]] ; } ; }    || { [[ -n "$is_interactive" ]] && [[ -n "${BASH_SOURCE[@]}" ]] && [[ "${EL_DEBUG}" -ge 3 ]] ; } ; then
        counter="${#FUNCNAME[*]}"
        count=0
        for arg in "${FUNCNAME[@]}"
        do
            count="$(( $count + 1 ))"
            if [[ "$count" -gt 1 ]] && [[ "$count" -lt "$counter" ]] ; then
                if [[ "$arg" != "source" ]] && [[ "$arg" != "main" ]] ; then
                    funcnames="$arg > $funcnames"
                fi
            fi
        done
        funcnames="${funcnames% >*}"

        counter="${#BASH_SOURCE[*]}"
        count=0
        for arg in "${BASH_SOURCE[@]}"
        do
            count="$(( $count + 1 ))"
            if [[ "$count" -gt 1 ]] && [[ "$count" -lt "$counter" ]] ; then
                if [[ -n "$arg" ]] ; then
                    el_array_member_add "$arg >" "${sourcenames_arr[@]}" ; sourcenames_arr=("${_out[@]}")
                fi
            fi
        done
        if [[ -n "$sourcenames_arr" ]] ; then
            if [[ "${sourcenames_arr[@]}" = "$0 >"* ]] ; then
                sourcenames_arr="$( echo "${sourcenames_arr[@]}" | tr ' ' '\n' | tac | tr '\n' ' ' )"
            else
                sourcenames_arr="$0 $( echo "${sourcenames_arr[@]}" | tr ' ' '\n' | tac | tr '\n' ' ' )"
            fi
            sourcenames_arr="${sourcenames_arr% }"
            sourcenames_arr="${sourcenames_arr#> }"
            #read -r sourcenames_arr <<< "$sourcenames_arr"
        else
            sourcenames_arr="$0"
        fi
    fi

    # }}}
    # show error {{{


    if ((is_interactive)) ; then
        if [[ "${EL_DEBUG}" -ge 0 ]] ; then
            if [[ -n "${BASH_SOURCE[@]}" ]] && [[ "${EL_DEBUG}" -ge 3 ]] ; then
                echo -e "${el_c_r}E: ${el_c_gr}[ ${sourcenames_arr} +${el_c_c2}${BASH_LINENO} ${el_c_gr}${funcnames}] ${el_c_r}$message${el_c_n}" 1>&2
            else
                echo -e "${el_c_r}E: ${el_c_r}$message${el_c_n}" 1>&2
            fi
        #else
            #if [[ "$DISPLAY" = ":0.0" ]] && el_check_version_development ; then
                #timeout 120 $guitool --error --text="${SOURCE}: $message"
            #fi
        fi
    fi

    if [[ -n "${BASH_SOURCE[@]}" ]] ; then
        # set colors for our reports
        local el_c_n el_c_r el_c_r2 el_c_g el_c_g2 el_c_y el_c_y2 el_c_m el_c_m2 el_c_c el_c_c2 el_c_b el_c_b2 el_c_gr el_c_gr2
        el_c_gr="\033[1;30m" # Gray color
        el_c_gr2="\033[0;30m" # Gray2 color
        el_c_r="\033[1;31m" # Red color  (orig: red)
        el_c_r2="\033[0;31m" # Red2 color  (orig: red)
        el_c_g="\033[1;32m" # Green color  (orig: green)
        el_c_g2="\033[0;32m" # Green2 color  (orig. green2)
        el_c_y="\033[1;33m" # Yellow color  (orig. yellow)
        el_c_y2="\033[0;33m" # Yellow2 color  (orig. yellow)
        el_c_b="\033[1;34m" # Blue color
        el_c_b2="\033[0;34m" # Blue2 color
        el_c_m="\033[1;35m" # Magenta color
        el_c_m2="\033[0;35m" # Magenta2 color
        el_c_c="\033[1;36m" # Cyan color
        el_c_c2="\033[0;36m" # Cyan2 color
        el_c_w="\033[1;37m" # White
        el_c_w2="\033[0;37m" # White strong
        el_c_n="\033[0;39m" # Normal color  (orig: normal)

        # always report warnings with debug (function calls)
        el_report_to_elive "${el_c_r}E: ${el_c_gr}[ ${sourcenames_arr} +${el_c_c2}${BASH_LINENO} ${el_c_gr}${funcnames} ] ${el_c_r}$message${el_c_n}"
    fi

    # }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_group_check
#   DESCRIPTION:  check if user is already on a specific group
#    PARAMETERS:  $1 = groupname
#===============================================================================
el_group_check(){
    # pre {{{
    local group

    group="${1}"

    el_check_variables "group"

    # }}}

    if [[ " $(id -Gn "$USER") " = *" $group "* ]] ; then
        return 0
    else
        return 1
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  el_group_add
#   DESCRIPTION:  verify and add an user to a group
#    PARAMETERS:  $1 = group to add
#===============================================================================
el_group_add(){
    # pre {{{
    local group is_password_ok

    group="$1"

    el_check_variables "group"

    # }}}
    if ! el_group_check "${group}" ; then
        if ! el_dependencies_check gksu ; then
            el_dependencies_install "gksu"
        fi
        # multiple gksu attempts
        for i in 1 2
        do
            if gksu "adduser $USER $group" ; then
                is_password_ok=1
                break
            fi
        done

        if ! ((is_password_ok)) && [[ "${DISPLAY}" = ":0.0" ]] ; then
            local message_wrong_password
            message_wrong_password="$( printf "$( eval_gettext "Wrong password" )" "" )"

            timeout 40 $guitool --error --text="$( TEXTDOMAIN="elive-tools" eval_gettext "$message_wrong_password" )"
        fi


        # try again if not reached
        if ! el_group_check "${group}" ; then
            if ! el_dependencies_check gksu ; then
                el_dependencies_install "gksu"
            fi
            # multiple gksu attempts
            for i in 1 2
            do
                if gksu "adduser $USER $group" ; then
                    is_password_ok=1
                    break
                fi
            done

            if ! ((is_password_ok)) && [[ "${DISPLAY}" = ":0.0" ]] ; then
                local message_wrong_password
                message_wrong_password="$( printf "$( eval_gettext "Wrong password" )" "" )"

                timeout 40 $guitool --error --text="$( TEXTDOMAIN="elive-tools" eval_gettext "$message_wrong_password" )"
            fi
        fi

        # inform that a reboot is needed
        if el_group_check "$group" ; then
            el_notify normal logo-elive "Your user is now added to the new group ${group}, reboot your computer for use it correctly"
        fi
    fi


}

#===  FUNCTION  ================================================================
#          NAME:  el_confirm
#   DESCRIPTION:  ask (console) for confirmation
#    PARAMETERS:  question
#       RETURNS:  true | false
#===============================================================================
el_confirm(){
    # pre {{{
    local reply question flag_glob

    if [[ -n "$BASH_VERSION" ]] ; then
        if shopt extglob | LC_ALL=C grep -q "extglob.*off" ; then
            flag_glob=1
        fi

        shopt -s extglob
    fi
    question="$1"

    el_check_variables "question"


    # }}}
    # return answer {{{
    if ((is_interactive)) ; then
        echo -en "$question [y/n]: "
        if [[ -n $ZSH_VERSION ]] ; then
            read reply
        else
            read -e -N1 reply
        fi

        case $reply in
            y|Y|yes|Yes|YES|s|S)
                return  0
                ;;
            n|N|no|No|NO|nope)
                return  1
                ;;
            *)
                # repeat question until confirmation
                if el_confirm "$@" ; then
                    return 0
                else
                    return 1
                fi
                ;;
        esac
    else
        el_set_display_variables

        if [[ "${DISPLAY}" = ":0.0" ]] ; then
            if $guitool --question --text="$question" ; then
                return 0
            else
                return 1
            fi
        fi
    fi

    if ((flag_glob)) ; then
        shopt -u extglob
    fi

    # }}}

}

#===  FUNCTION  ================================================================
#          NAME:  el_security_function_loop
#   DESCRIPTION:  check for a possible infinite-loops, needs to be called as:
#                 el_security_function_loop || return 0
#                 from every function of your scripts
#    PARAMETERS:  $1 = number of recursivity's allowed
#       RETURNS:  1 if found a loop, 0 if not
#===============================================================================
el_security_function_loop(){
    # pre {{{
    local funclevels funclevel count_recursive recursives_allowed is_loop_infinite is_loop_predetected

    # }}}
    # high value of count_recursive if we call a function recursively multiple times
    if [[ -n "$1" ]] ; then
        recursives_allowed="$1"
    fi

    funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
    funclevel="${funclevels}"

    if [[ -n "$recursives_allowed" ]] ; then
        count_recursive="$(( 1 + $recursives_allowed ))"
    else
        count_recursive="4"
    fi


    # walk around our parent functions
    while [[ $funclevel -gt 0 ]] ; do
        # ignore the last check, which is of course the same name
        if [[ "${count_recursive}" -lt "$funclevels" ]] ; then
            # check if we already come from our function-name in our parents
            if [[ "${FUNCNAME[$funclevel]}" = "${FUNCNAME[1]}" ]] ; then
                if ((is_loop_predetected)) ; then
                    # already entered loop, we should break the loop and continue gracefully
                    is_loop_infinite=1
                else
                    # give at least a chance to the infinite-loop, but we shouldn't
                    is_loop_predetected=1
                fi
            fi
        fi


        funclevel="$(( $funclevel - 1 ))"
        count_recursive="$(( $count_recursive + 1 ))"
    done


    # do action for our resulting checks
    if ((is_loop_predetected)) ; then
        if ((is_loop_infinite)) ; then
            # note: we set it as a warning instead of error because it is really a way that solves errors making the application working, at least for "smart" applications (no linear procedure but a set of tasks and where the application is meant to know what to do)
            if [[ "${EL_DEBUG}" -ge "1" ]] ; then
                echo -e "${el_c_y}W: Entered in an Infinite Loop, let's jump it${el_c_n}" 1>&2
                #echo -e "Note: Declarative type of programming requires this feature for work correctly, in short, if the application works correctly then everything is fine." 1>&2

                # show the array of calls
                funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
                funclevel="${funclevels}"
                echo -en "${el_c_b}calls:${el_c_gr}" 1>&2
                while [[ $funclevel -gt 0 ]] ; do
                    echo -en " -> ${FUNCNAME[$funclevel]}" 1>&2
                    funclevel="$(( $funclevel - 1 ))"
                done
                echo -e "${el_c_n}" 1>&2
            fi

            return 1
        else
            if [[ "${EL_DEBUG}" -ge "2" ]] ; then
                if [[ -z "$recursives_allowed" ]] ; then
                    echo -e "${el_c_y}W: Detected a possible infinite loop${el_c_n}" 1>&2
                fi

                # show the array of calls
                funclevels="$(( ${#FUNCNAME[*]} - 2 ))"
                funclevel="${funclevels}"
                echo -en "${el_c_gr}calls:" 1>&2
                while [[ $funclevel -gt 0 ]] ; do
                    echo -en " -> ${FUNCNAME[$funclevel]}" 1>&2
                    funclevel="$(( $funclevel - 1 ))"
                done
                echo -e "${el_c_n}" 1>&2
            fi
        fi
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_array_member_check
#   DESCRIPTION:  check if an element exists in an array
#    PARAMETERS:  $1 = match, $2 = array (list of words)
#       RETURNS:  true if found, false if not
#===============================================================================
el_array_member_check(){
    local match list i
    match="$1"
    shift
    list=("$@")

    if [[ -n $ZSH_VERSION ]] ; then
        for i in "${(P)list[@]}"
        do
            [[ -z "$i" ]] && continue
            if [[ "${list[i]}" = "$match" ]] ; then
                return 0
            fi
        done
    else
        for i in "${!list[@]}"
        do
            [[ -z "$i" ]] && continue
            if [[ "${list[i]}" = "$match" ]] ; then
                return 0
            fi
        done
    fi

    return 1
}

#===  FUNCTION  ================================================================
#          NAME:  el_array_member_unset
#   DESCRIPTION:  unset members in an array
#    PARAMETERS:  $1 = match, $2 = array contents
#                 XXX needs to be used later with!:  arr=("${_out[@]}")
#===============================================================================
el_array_member_unset(){
    _out=()
    local i item=$1
    shift

    for i in "$@"; do
        [[ -z "$i" ]] && continue
        if [[ $item != "$i" ]]; then
            _out+=("$i")
        fi
    done

    # note: this is a bit hacky but it works until newer versions of bash, the common alternative is: for i in "${!list_requires_update[@]}"; do [[ ${list_requires_update[i]} = "$package" ]] && unset 'list_requires_update[i]'; done
}

#===  FUNCTION  ================================================================
#          NAME:  el_array_member_add
#   DESCRIPTION:  add a member in the array if not exist
#    PARAMETERS:  $1 = element, $2 = array contents
#                 XXX needs to be used later with!:  arr=("${_out[@]}")
#===============================================================================
el_array_member_add(){
    _out=()
    local i item=$1 match
    shift

    # see if we have the entry already
    for i in "$@"; do
        if [[ -n "$i" ]] ; then
            if [[ "$item" = "$i" ]]; then
                match=1
            fi
        fi
    done

    # if is repeated, just show the default array, otherwise, append the value
    if ((match)) ; then
        _out=("$@")
    else
        for i in "$@"; do
            if [[ -n "$i" ]] ; then
                _out+=("$i")
            fi
        done

        # add elements to the new array
        _out+=("$item")
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_array_print_per_line
#   DESCRIPTION:  prints each element of the array, one entry per line
#    PARAMETERS:  $1 = array to print
#       RETURNS:  value
#===============================================================================
el_array_print_per_line(){
    # note: echo "${arr[@]}" doesn't works, so this function
    # has been made in order to avoid using it
    printf "%s\n" "$@"
}

#===  FUNCTION  ================================================================
#          NAME:  el_step_requires_fixme
#   DESCRIPTION:  temporal "step" to put in experimental/development code, only
#    PARAMETERS:  $1 = dir to login (optional)
#		  $2 = message (optional)
#===============================================================================
el_step_requires_fixme(){
    # pre {{{
    local dir prev_dir message

    dir="$1"
    shift
    message="$1"
    shift

    prev_dir="$(pwd)"

    : ${dir:="$prev_dir"}

    el_set_display_variables

    # }}}
    el_check_dirs "${dir}"
    cd "$dir"

    if ((is_interactive)) ; then
        echo -e "\n"
        #el_warning "Experimental or uncomplete code:"
        echo -e "We have set a breakpoint here, report to Elive this message if needed:"
        echo -e "${FUNCNAME} for $0"
        echo -e "Function: ${FUNCNAME[1]}  |  Line: $LINENO"
        if [[ -n "$message" ]] ; then
            el_explain 0 "message: XX${message}XX"
            echo -e ""
        fi
        echo -e "$(tput setaf 3)$(tput blink)New SHELL Started$(tput op)"
        el_explain 0 "Type '__exit__' for continue..."
        $SHELL -l
    else
        cd "${prev_dir}"
        el_set_display_variables
        local _dummy
        _dummy="$( eval_gettext "Experimental or incomplete code found, report this to the Elive forums if you deem it necessary. Exiting..." )"
        if [[ "${DISPLAY}" = ":0.0" ]] ; then
            timeout 50 $guitool --warning --text="$( TEXTDOMAIN="elive-tools" eval_gettext "Experimental or incomplete code found, report this to the Elive forums if you deem it necessary. Exiting..." )"
        fi
        exit 1
    fi

    cd "${prev_dir}"

}

#===  FUNCTION  ================================================================
#          NAME:  el_report_to_elive
#   DESCRIPTION:  function to send easly and painless reports to elive
#    PARAMETERS:  $1 = message
#       RETURNS:  -
#===============================================================================
el_report_to_elive(){
    # pre {{{
    # NOREPORTS means that we don't want reports in a forced way, so exit
    if [[ -n "$NOREPORTS" ]] || [[ -n "$NOREPORT" ]] || [[ -n "$NO_ELIVETOOLS_REPORTS" ]] ; then
        # only if we dont want to report specifically something (like: main tool don't send reports, which calls a subcommand with reports, so the first one has the variable exported and we don't want it to affect to us)
        if ! ((REPORTS)) && ! ((FORCE_REPORTS)) ; then
            return 0
        fi
    fi

    local message message_stripped return_status id eliveversion execution_stack architecture tmp_conf_f limit_reports_amount limit_reports_seconds buf messages_extra tool counter fingerprint
    el_security_function_loop || return 0
    # max 5 reports per tool
    limit_reports_amount=6
    # min 4 hours passed if limit is reached to send more reports: 14400, 2 days: 172800
    limit_reports_seconds=172800

    messages_extra=""

    if ((EL_REPORTS)) && ! ((FORCE_REPORTS)) ; then
        # never send reports for systems that are not elive, we don't need them at all (and them don't want that too)
        if ! [[ -s "/etc/elive-version" ]] ; then
            return 0
        fi
        # make sure its not a modified version of Elive, so we don't want to receive reports from other things
        if grep -Fqs "machine-id: " /etc/elive-version && grep -Fqs "fingerprint: " /etc/elive-version ; then
            fingerprint="$( echo "DFF8D7C2+$( grep -F "machine-id: " /etc/elive-version | sed -e 's|^machine-id: ||g' )" | sha1sum | awk '{print $1}'  )"
            if ! grep -Fqs "fingerprint: $fingerprint" /etc/elive-version ; then
                return 0
            fi
        else
            if ! LC_ALL=C grep -Fqs "boot=live" /proc/cmdline && ! LC_ALL=C grep -Fqs "elive-codename: eliveserver" /etc/elive-version ; then
                return 0
            fi
        fi
        # same for specific versions of Elive
        if LC_ALL=C grep -qs "^special-version:" "/etc/elive-version" ; then
            return 0
        fi
    else
        # old code or forced mode:
        if ((REPORTS)) || ((FORCE_REPORTS)) ; then
            # always send reports when REPORTS is set
            # useful for calling subcommands with REPORTS set from a main tool without reports
            true
        else
            # this case means: EL_REPORTS is not set (we dont want reports), and we are not using the old code OR forcing it, so exit because we simply don't want reports...
            # TODO: after 3.8.13 or more, move this REPORTS part to the fingerprint check
            return 0
        fi
    fi

    if [[ -x "$(which nc 2>/dev/null)" ]] ; then
        if [[ -e "/var/lib/dpkg/info/netcat-openbsd.list" ]] ; then
            tool="nc -N"
        else
            tool="nc -q1"
        fi
    else
        return 0
    fi

    if [[ -n "$REPORTS" ]] && [[ -z "$EL_REPORTS" ]] ; then
        messages_extra=" ||| tool '$SOURCE' still uses the REPORTS DEPRECATED CODE, UPDATE IT ${messages_extra}"
    fi

    if ((is_interactive)) ; then
        if ((is_terminal)) ; then
            messages_extra=" ||| terminal mode YES:  '$is_terminal' console '${is_console}' is_interactive '${is_interactive}', BLACKLIST all terminal and console REPORTS because we only need them from the TOOLS? (temporal warning to verify the correct detection) ${messages_extra}"
        else
            messages_extra=" ||| terminal mode NO: '$is_terminal' console '${is_console}' is_interactive '${is_interactive}', BLACKLIST all terminal and console REPORTS because we only need them from the TOOLS? (temporal warning to verify the correct detection) ${messages_extra}"
        fi
    #else
        #messages_extra=" ||| is_interactive '${is_interactive}', is_terminal '${is_terminal}', (example of only-tools (no-interactive) report)"
    fi


    # at least one month old, we can parse the results from the server to show only recent ones too
    if ((FORCE_REPORTS)) ; then
        if el_check_version_development 1>/dev/null 2>&1 ; then
            if ! el_check_version_development_is_days_recent 120 ; then
                return 0
            fi
        else
            if ! el_check_version_is_days_recent 120 ; then
                return 0
            fi
        fi
    else
        if el_check_version_development 1>/dev/null 2>&1 ; then
            # ignore reports for more than X days old
            # 2 weeks after a beta release should be enough to fix any bugs! (1 week to download version + 1 days of download/misc)
            if LC_ALL=C grep -Fqs "boot=live" /proc/cmdline ; then
                if ! el_check_version_development_is_days_recent 10 ; then
                    return 0
                fi
            else
                if ! el_check_version_development_is_days_recent 20 ; then
                    return 0
                fi
            fi
        else
            # stable versions will need more time
            if LC_ALL=C grep -Fqs "boot=live" /proc/cmdline ; then
                if ! el_check_version_is_days_recent 20 ; then
                    return 0
                fi
            else
                if ! el_check_version_is_days_recent 40 ; then
                    return 0
                fi
            fi
        fi
    fi

    # accept a max number of reports to send {{{
    conf_counter_reports_sent=0

    el_config_get
    tmp_conf_f="${HOME}/.config/elive/elive-tools/el_config/${SOURCE//\//%%}_conf.sh"

    # at least X time passed to clean reports counter
    if [[ -s "$tmp_conf_f" ]] ; then
        buf="$( echo "$(date +%s) - $( stat -c %Y "$tmp_conf_f" 2>/dev/null )" | LC_ALL="$EL_LC_EN" bc -l | sed -e 's|\..*$||g' )"
        if [[ -n "$buf" ]] && [[ "$buf" -gt "$limit_reports_seconds" ]] ; then
            conf_counter_reports_sent=0
            el_config_save "conf_counter_reports_sent"
        fi

        if [[ "$conf_counter_reports_sent" -ge "$limit_reports_amount" ]] ; then
            return 0
        fi
    fi


    # }}}


    message="$@"
    # remove special chars like colors, don't depend on colors-remove:
    message_stripped="$( echo -e "$@" | sed -r -e "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" -e "s/\x0f//g" )"

    if [[ -z "$message" ]] || [[ -z "$message_stripped" ]] ; then
        return 0
    fi

    if [[ -s "/etc/elive/settings" ]] ; then
        source "/etc/elive/settings" 1>/dev/null 2>&1
    fi
    if [[ -s "$HOME/.config/elive/settings" ]] ; then
        source "$HOME/.config/elive/settings"
    fi

    # not configured? ask for it
    if [[ -z "$conf_send_debug_reports" ]] ; then

        # ask for reports
        if ! LC_ALL=C grep -Fqs "boot=live" /proc/cmdline ; then
            if [[ "${DISPLAY}" = ":0.0" ]] ; then
                local message_ask_email
                # note: don't use "'" char in the messages or the functions will fail when using it with ZSH
                message_ask_email="$( printf "$( eval_gettext "Error found in %s, insert your email if you want to inform Elive about it, so we can fix the bugs automatically. We will only contact you in case it is an important problem or if we need more details." )" "$(basename $0)" )"
                conf_send_debug_reports_email="$( timeout 240 $guitool --entry --text="$( TEXTDOMAIN="elive-tools" eval_gettext "$message_ask_email" )" )"

                # set conf
                if echo "$conf_send_debug_reports_email" | grep -qs "@.*\." ; then
                    conf_send_debug_reports="yes"
                else
                    conf_send_debug_reports="no"
                fi

                # save conf
                mkdir -p "$HOME/.config/elive"

                sed -i -e "/conf_send_debug_reports=/d" "$HOME/.config/elive/settings" 2>/dev/null
                sed -i -e "/conf_send_debug_reports_email=/d" "$HOME/.config/elive/settings" 2>/dev/null

                echo -e "conf_send_debug_reports=\"$conf_send_debug_reports\"" >> "$HOME/.config/elive/settings"
                echo -e "conf_send_debug_reports_email=\"$conf_send_debug_reports_email\"" >> "$HOME/.config/elive/settings"
            fi
        else
            # don't ask the user for his contact if he's running on live mode
            conf_send_debug_reports="yes"
            conf_send_debug_reports_email="Live"
        fi
    fi

    # user don't wants to report, so ignore it
    if [[ "$conf_send_debug_reports" = "no" ]] || [[ -z "$conf_send_debug_reports" ]] ; then
        if ! ((FORCE_REPORTS)) ; then
            return 0
        fi
    fi

    # protocol 1.0 values (in order):
    #v_version v_id v_type v_filetype v_topic v_sizeb v_from_name v_from_email v_return_status v_custom v_stack_tree

    # }}}
    # set values{{{
    case "$message_stripped" in
        "E: "*)  return_status=1  ; ;;
        "W: "*)  return_status=2  ; ;;
        "I: "*)  return_status=3  ; ;;
        "D: "*)  return_status=4  ; ;;
    esac

    if [[ -z "$id" ]] ; then
        id="$( cat /etc/elive-version | grep -F "machine-id: " | awk '{print $2}' )"
    fi
    # create an unique identifier to differentiate betweem same-reports
    if [[ -z "$id" ]] ; then
        id="$( timeout 4 /sbin/blkid | LC_ALL=C grep -oP 'UUID="\K[^"]+' | sha256sum | awk '{print $1}' )"
    fi
    if [[ -z "$id" ]] ; then
        id="$( ip a | LC_ALL=C grep -E "(link/ether|fe80)" | sha256sum | awk '{print $1}' )"
    fi
    # alternative (dynamic, it will change)
    if [[ -z "$id" ]] ; then
        id="$( dd if=/dev/urandom bs=1k count=1 2>/dev/null | sha1sum | awk '{print $1}' )"
    fi

    if [[ -z "$conf_send_debug_reports_email" ]] ; then
        conf_send_debug_reports_email="anonymous:${id}"
    fi


    eliveversion="$( el_elive_version_get 2>/dev/null )"

    # }}}
    # send {{{
    # only report recent things
    if el_verify_internet fast 1>/dev/null 2>&1 ; then
        # get stack to senD
        execution_stack="$( pstree -A -l -n -s $$ )"
        execution_stack="$( echo "$execution_stack" | sed -e 's|^init---||g' -e 's|^.*lightdm---||g' -e 's|---pstree||g' -e 's|---enlightenment---|---|g' -e 's|---ck-launch-sessi||g' -e's|-+-ck-launch-sessi||g' -e 's|---enlightenment_s||g' -e 's|---e_wrapper---e_wrapper|---e_wrapper|g' -e 's|---el_report_to_elive||g' )"
        architecture="$( el_architecture "host" )"

        # send
        if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::reports::0::::${conf_send_debug_reports_email}::${return_status}::::${architecture}::${eliveversion}::${SOURCE}::" ; echo -e "${message}${messages_extra}" ; echo "     stack: $execution_stack" ; echo -ne "\0" ; } | timeout 4 $tool www.elivecd.org 60008 -w 4 1>/dev/null 2>&1 ; then
            true

            LC_ALL="$EL_LC_EN" sleep 1
            if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::reports::0::::${conf_send_debug_reports_email}::${return_status}::::${architecture}::${eliveversion}::${SOURCE}::" ; echo -e "${message}${messages_extra}" ; echo "      stack: $execution_stack" ; echo -ne "\0" ; } | timeout 8 $tool www.elivecd.org 60008 -w 8 1>/dev/null 2>&1 ; then
                true

                #LC_ALL="$EL_LC_EN" sleep 1
                #if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::reports::0::::${conf_send_debug_reports_email}::${return_status}::::${architecture}::${eliveversion}::${SOURCE}::" ; echo -e "${message}${messages_extra}" ; } | timeout 8 $tool www.elivecd.org 60008 -w 1 1>/dev/null 2>&1 ; then
                    #true

                    #LC_ALL="$EL_LC_EN" sleep 1
                    #if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::reports::0::::${conf_send_debug_reports_email}::${return_status}::::${architecture}::${eliveversion}::${SOURCE}::" ; echo -e "${message}${messages_extra}" ; } | timeout 8 $tool www.elivecd.org 60008 -w 1 1>/dev/null 2>&1 ; then
                        #true
                    #fi
                #fi
            fi
        fi

        conf_counter_reports_sent="$(( $conf_counter_reports_sent + 1 ))"
        el_config_save "conf_counter_reports_sent"
    fi
    # }}}
}
#===  FUNCTION  ================================================================
#          NAME:  el_mark_state
#   DESCRIPTION:  marks states for debug purposes
#    PARAMETERS:  $1 = id | $1 + $2 = category + action
#       RETURNS:  -
#===============================================================================
el_mark_state(){
    # pre {{{

    local id state category action
    if [[ -n "$2" ]] ; then
        category="$1"
        action="$2"
    else
        if [[ -n "$1" ]] ; then
            state="$1"
        fi
    fi

    # demo code: this is an example of how to run background processes without annoying debug info, but adding these settings globally will:
    # Important: this breaks el_confirm in zsh
    #if [[ -n "$ZSH_VERSION" ]] && ! [[ "$0" = "bash" ]] && ! [[ "$SOURCE" = "$0" ]] ; then
        #setopt LOCAL_OPTIONS NO_NOTIFY NO_MONITOR
    #fi

    # }}}
    # only send with user's permission {{{
    # get conf
    if [[ -s "/etc/elive/settings" ]] ; then
        source "/etc/elive/settings" 1>/dev/null 2>&1
    fi
    if [[ -s "$HOME/.config/elive/settings" ]] ; then
        source "$HOME/.config/elive/settings"
    fi

    # exit if user doesn't want to participate
    if [[ "${conf_send_debug_reports}" != "yes" ]] ; then
        return 0
    fi
    # }}}
    # parse ids {{{
    # always run in background to not slow down anything from the tools
    if [[ -n "$category" ]] && [[ -n "$action" ]] ; then
        if [[ -n "$ZSH_VERSION" ]] ; then
            curl -m 10 -L -i -X POST -d '{"requests":["?url=https://www.elivecd.org'${SOURCE}'&idsite=2&rec=1&e_c='${category}'&e_a='${action}'"]}' "https://statistics.elivecd.org/piwik.php" 1>/dev/null 2>&1 || true
        else
            { curl -m 10 -L -i -X POST -d '{"requests":["?url=https://www.elivecd.org'${SOURCE}'&idsite=2&rec=1&e_c='${category}'&e_a='${action}'"]}' "https://statistics.elivecd.org/piwik.php" & disown ; } 1>/dev/null 2>&1 || true
        fi
    fi

    if [[ -n "$state" ]] ; then
        case "$state" in
            test)
                id="3"
                ;;
            upgraded)
                id="2"
                ;;
            installing)
                id="5"
                ;;
            installed)
                id="6"
                ;;
            noreports)
                # TODO: remove, temporal tests
                id="7"
                ;;
        esac
        if [[ -n "$ZSH_VERSION" ]] ; then
            curl -m 10 -L -i -X POST -d '{"requests":["?url=https://www.elivecd.org'${SOURCE}'&idsite=2&rec=1&action_name=track_goal&idgoal='${id}'"]}' "https://statistics.elivecd.org/piwik.php" 1>/dev/null 2>&1 || true
        else
            { curl -m 10 -L -i -X POST -d '{"requests":["?url=https://www.elivecd.org'${SOURCE}'&idsite=2&rec=1&action_name=track_goal&idgoal='${id}'"]}' "https://statistics.elivecd.org/piwik.php" & disown ; } 1>/dev/null 2>&1 || true
        fi
    fi

    if [[ -z "$1" ]] ; then
        if [[ -n "$ZSH_VERSION" ]] ; then
            curl -m 10 -L -i -X POST -d '{"requests":["?url=https://www.elivecd.org&idsite=2&rec=1"]}' "https://statistics.elivecd.org/piwik.php" 1>/dev/null 2>&1 || true
        else
            { curl -m 10 -L -i -X POST -d '{"requests":["?url=https://www.elivecd.org&idsite=2&rec=1"]}' "https://statistics.elivecd.org/piwik.php" & disown ; } 1>/dev/null 2>&1 || true
        fi
    fi
    # - parse ids }}}
}

#===  FUNCTION  ================================================================
#          NAME:  el_flag
#   DESCRIPTION:  control states with marks and locks
#    PARAMETERS:  $2 = action (add|del|check), $3 = name
#       RETURNS:  true or false for check actions
#===============================================================================
el_flag(){
    # pre {{{
    local action name
    el_security_function_loop || return 0

    action="${1}"
    name="${2}"

    #el_debug "$action - $name"

    TMP_FLAGS_d="${TMP_FLAGS_d:-"/tmp/.$(basename $0)-flags-$USER"}"

    # always create dir, flush FS's problems
    mkdir -p "$TMP_FLAGS_d"

    el_check_variables "action|name"

    # }}}
    case $action in
        add|set|put)
            el_explain 4 "added $name flag"
            touch "${TMP_FLAGS_d}/$name"
            ;;
        del|remove|delete|rm)
            rm -f "${TMP_FLAGS_d}/$name"

            if ! el_check_dir_has_files "${TMP_FLAGS_d}" 2>/dev/null ; then
                rmdir "${TMP_FLAGS_d}" 2>/dev/null || true
            fi
            el_debug "removed flag $name"
            ;;
        check|test|verify)
            if [[ -e "${TMP_FLAGS_d}/$name" ]]; then
                el_debug "$action $name -> [flag found]"
                return 0
            else
                el_debug "$action $name -> [no flag]"
                return 1
            fi
            ;;
        *)
            el_error "unknown action ${action}, func: ${FUNCNAME[1]}"
            ;;
    esac
}


#===  FUNCTION  ================================================================
#          NAME:  el_add_on_exit
#   DESCRIPTION:  add commands that will be run on exit of the application
#    PARAMETERS:  command to run
#       RETURNS:  -
#===============================================================================
el_add_on_exit(){
    if [[ -z "$1" ]] ; then
        return 0
    fi
    local n=${#on_exit_items[*]}
    on_exit_items[$n]="$*"

    # add the trap if is not added
    if [[ $n -eq 0 ]]; then
        #echo "Setting trap"
        trap on_exit EXIT
    fi
}
on_exit(){
    local i
    # create empty variable of array type if not exist
    if [[ -z "$on_exit_items" ]] ; then
        declare -a on_exit_items
    fi

    # run each appended command
    for i in "${on_exit_items[@]}"
    do
        #echo "on_exit: $i"
        eval $i
    done
}

#===  FUNCTION  ================================================================
#          NAME:  el_request_report_bug
#   DESCRIPTION:  Request the user to report a bug
#    PARAMETERS:  Message to tell to the user (optional)
#       RETURNS:  -
#===============================================================================
el_request_report_bug(){
    # pre {{{
    local message url
    el_debug
    el_security_function_loop || return 0

    message="$@"
    el_check_variables "message"

    el_set_display_variables

    # set colors for our reports
    local el_c_n el_c_r el_c_r2 el_c_g el_c_g2 el_c_y el_c_y2 el_c_m el_c_m2 el_c_c el_c_c2 el_c_b el_c_b2
    el_c_gr="\033[1;30m" # Gray color
    el_c_gr2="\033[0;30m" # Gray2 color
    el_c_r="\033[1;31m" # Red color  (orig: red)
    el_c_r2="\033[0;31m" # Red2 color  (orig: red)
    el_c_g="\033[1;32m" # Green color  (orig: green)
    el_c_g2="\033[0;32m" # Green2 color  (orig. green2)
    el_c_y="\033[1;33m" # Yellow color  (orig. yellow)
    el_c_y2="\033[0;33m" # Yellow2 color  (orig. yellow)
    el_c_b="\033[1;34m" # Blue color
    el_c_b2="\033[0;34m" # Blue2 color
    el_c_m="\033[1;35m" # Magenta color
    el_c_m2="\033[0;35m" # Magenta2 color
    el_c_c="\033[1;36m" # Cyan color
    el_c_c2="\033[0;36m" # Cyan2 color
    el_c_w="\033[1;37m" # White
    el_c_w2="\033[0;37m" # White strong
    el_c_n="\033[0;39m" # Normal color  (orig: normal)


    # }}}
    # use el_report_to_elive {{{
    local execution_stack
    execution_stack="$( pstree -A -l -n -s $$ )"
    execution_stack="$( echo "$execution_stack" | sed -e 's|^init---||g' -e 's|^.*lightdm---||g' -e 's|---pstree||g' -e 's|---enlightenment---|---|g' -e 's|---ck-launch-sessi||g' -e's|-+-ck-launch-sessi||g' -e 's|---enlightenment_s||g' -e 's|---e_wrapper---e_wrapper|---e_wrapper|g' -e 's|---el_report_to_elive||g' )"
    el_report_to_elive "${el_c_y2}W: ${el_c_gr}[ ${sourcenames_arr} +${el_c_c2}${BASH_LINENO} ${el_c_gr}${funcnames} (${execution_stack})] ${el_c_r}$message${el_c_n}"

    # - use el_report_to_elive }}}
    # we don't need anything more since the new tool # TODO: remove old code
    return 0

    # task list sorted by created time
    #url='http://bugs.elivecd.org/index.php?do=index&project=2&project=2&do=index&order=dateopened&sort=desc'
    ## check if we should ignore this function
    ##if el_check_version_development_is_days_recent 30 ; then
    ## TODO: set 10 only for now, change it to 30 when migrating from NOREPORTS to EL_REPORTS=yes
    #if el_check_version_development_is_days_recent 15 ; then

        #if [[ "${DISPLAY}" = ":0.0" ]] ; then
            #local _dummy
            #_dummy="$( printf "$( eval_gettext "We found something that we want to be informed about its details, it may be a problem in Elive or a simple state that we want to know, since it happened to you it can happen to anybody and we want to make Elive as much stable as possible, please take 1 minute to report this message to our developers:<b>\n\n%s\n\n(file: %s, function: %s, line: %s)</b>\n\nCan you please send us now about your recent problem found ?" )" "$message" "${BASH_SOURCE[1]}" "${FUNCNAME[1]}" "$BASH_LINENO" )"

            #local message_report_bug
            #message_report_bug="$( printf "$( TEXTDOMAIN="elive-tools" eval_gettext "We found something that we want to be informed about its details, it may be a problem in Elive or a simple state that we want to know, since it happened to you it can happen to anybody and we want to make Elive as much stable as possible, please take 1 minute to report this message to our developers:<b>\n\n%s\n\n(file: %s, function: %s, line: %s)</b>\n\nCan you please send us now about your recent problem found ?" )" "$message" "${BASH_SOURCE[1]}" "${FUNCNAME[1]}" "$BASH_LINENO" )"

            #if $guitool --question --text="$message_report_bug" ; then
                #if [[ -x /usr/bin/firefox ]] ; then
                    #firefox "$url" &
                #fi
                #if [[ -x /usr/bin/iceweasel ]] ; then
                    #iceweasel "$url" &
                #fi
                ## use web-launcher TODO
                #if [[ -x /usr/bin/chromium ]] ; then
                    #chromium --temp-profile "$url" &
                #fi

                ## explain some details while reporting it
                #local _dummy
                #_dummy="$( eval_gettext "Make sure that the report doesn't already exist first, then click where it says to add a new task. You must be registered for create a task first. Close this dialog when you have finished. Thank you." )"
                #local message_instructions
                #message_instructions="$( TEXTDOMAIN="elive-tools" eval_gettext "Make sure that the report doesn't already exist first, then click where it says to add a new task. You must be registered for create a task first. Close this dialog when you have finished. Thank you." )"
                #sleep 6
                #timeout 240 $guitool --info --text="$message_instructions" || true

            #fi
        #else
            #el_warning "$message_report_bug --> http://bugs.elivecd.org"
        #fi
    #fi

}

#===  FUNCTION  ================================================================
#          NAME:  el_processes_using_mountpoint
#   DESCRIPTION:  show the name of the processes that is using a mountpoint
#    PARAMETERS:  $1 mountpoint-dir, $2 mode [kill]
#       RETURNS:  -
#===============================================================================
el_processes_using_mountpoint(){
    # pre {{{
    local dir mode pid commands pids_mountpoint_arr
    el_debug
    el_security_function_loop || return 0

    dir="$1"
    mode="$2"

    el_check_variables "dir"
    #el_check_dirs "$dir"

    # get mountpoint if is a device
    if [[ -b "$dir" ]] ; then
        if mounts-manager --check-is-mounted "$dir" 2>/dev/null 1>&2 ; then
            dir="$( mounts-manager --get-mountpoint "$dir" 2>/dev/null )"
        fi
    fi

    # check
    if [[ -b "$dir" ]] ; then
        el_error "$dir is not a directory but a block device, try to use mounts-manager --get-mountpoint"
        return 1
    fi

    if ! [[ -d "$dir" ]] ; then
        el_error "$dir must be a directory"
        return 1
    fi

    # }}}

    for pid in $( fuser -m "$dir" 2>/dev/null | tr ' ' '\n' | LC_ALL=C grep -vE "($dir|$$)" )
    do
        pid="${pid//[^[:digit:]]}"
        commands="$( ps axo pid,comm 2>/dev/null | awk -v pid="$pid" '{if ($1 == pid) { $1="" ; print $0 }}' | sed 's| $||g' )"
        if [[ -n "$commands" ]] ; then
            echo "Mountpoint busy by process $pid: $commands"
            el_array_member_add "$pid" "${pids_mountpoint_arr[@]}" ; pids_mountpoint_arr=("${_out[@]}")
        fi
    done

    if [[ "${mode}" = "kill" ]] ; then
        el_debug "Killing processes in reverse mode until the mountpoints is freed"
        # reverse loop of array
        for (( pid=${#pids_mountpoint_arr[@]} ; pid>=0 ; pid-- ))
        do
            if ps "${pids_mountpoint_arr[pid]}" 1>/dev/null 2>&1 ; then
                el_debug "Killing process: \n$( ps "${pids_mountpoint_arr[pid]}" )"
                kill "${pids_mountpoint_arr[pid]}" 2>/dev/null
                kill -9 "${pids_mountpoint_arr[pid]}" 2>/dev/null
                LC_ALL=C sleep 0.2
            fi
        done
    fi

    unset pids_mountpoint_arr
}

#===  FUNCTION  ================================================================
#          NAME:  el_user_email_get
#   DESCRIPTION:  determine which is the email of the user and return it
#       RETURNS:  email string
#===============================================================================
el_user_email_get(){
    # pre {{{
    local user_email

    # }}}

    # user has configured it for elive
    user_email="$( grep "^email_acount=" "$HOME/.config/email-sender" 2>/dev/null | sed -e 's|^.*="||g' -e 's|".*$||g' | grep -F "@" | tail -1 )"

    # get the email from his git/github account
    if ! echo "$user_email" | grep -qs "[[:alpha:]]" ; then
        user_email="$( git config --get user.email 2>/dev/null | grep -F "@" | tail -1 )"
    fi

    if echo "$user_email" | grep -qs "[[:alpha:]]" ; then
        echo "$user_email"
    else
        el_error "unable to get user's email"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_request_donation
#   DESCRIPTION:  ask to the user to make a donation to elive
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
el_request_donation(){
    # pre {{{
    local arg

    if ! [[ "${DISPLAY}" = ":0.0" ]] ; then
        return 0
    fi

    # }}}

    local _dummy
    _dummy="$( eval_gettext "Elive enjoys making the life of its users easier with unique features and tools. Remember, Elive is a non-commercial project that only survives through donations." )"
    local _dummy2
    _dummy2="$( eval_gettext "Do you want to donate to Elive so that we can keep it alive and continue improving it?" )"

    local _dummy3
    _dummy3="$( eval_gettext "Making a donation only takes you one or two minutes and it guarantees that there will be more greatly improved versions of Elive in the future!" )"

    # show it
    #$guitool --info --text="$( TEXTDOMAIN="elive-tools" eval_gettext "$_dummy" )" || true
    if $guitool --question --text="$( TEXTDOMAIN="elive-tools" eval_gettext "$_dummy $_dummy2" )" ; then
        /etc/alternatives/x-www-browser "https://www.elivecd.org/donate" &
    else
        if $guitool --question --text="$( TEXTDOMAIN="elive-tools" eval_gettext "$_dummy $_dummy3" )" ; then
            /etc/alternatives/x-www-browser "https://www.elivecd.org/donate" &
        fi
    fi


}

#===  FUNCTION  ================================================================
#          NAME:  el_config_get
#   DESCRIPTION:  gets all the previously saved configurations for the $0 tool
#    PARAMETERS:  -
#                 to force conf file: prepend the variable SOURCE ($0) to the function call
#       RETURNS:  sources the file configuration, so it gets the variables
#          NOTE:  this tool cannot work with array variables
#          NOTE:  NEVER set a variable as "local" in your functions or it will be set back to local (so, not fetching any conf), since bash 5.0
#===============================================================================
el_config_get(){
    # pre {{{
    local tmp_conf_f
    #tmp_conf_f="/tmp/.$(basename $0)_${USER}_configs.sh"
    tmp_conf_f="${HOME}/.config/elive/elive-tools/el_config/${SOURCE//\//%%}_conf.sh"

    # }}}
    # checks {{{
    if el_check_is_shell ; then
        el_debug "ignoring el_config_* because we are from a shell"
        return 0
    fi
    # variable must be set
    if [[ -z "${SOURCE}" ]] ; then
        el_error "\$0 (source tool) should be set to access to its conf ID"
        return 1
    fi

    # }}}
    if [[ -s "$tmp_conf_f" ]] ; then
        # Warning: never use "local" variables in your function for the ones that you are going to get
        source "$tmp_conf_f" 1>/dev/null 2>&1
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_config_save
#   DESCRIPTION:  saves a configuration to re-use if we run again the installer
#                 works with bash and zsh, but the SOURCE var needs to be set in main script
#    PARAMETERS:  varname (not value), multiple-ones allowed (space separated)
#                 to force conf file: prepend the variable SOURCE ($0) to the function call
#       RETURNS:  -
#===============================================================================
el_config_save(){
    # pre {{{
    local entry
    # note: by some reason this needs to be alone and first or may not work:

    # checks {{{
    if el_check_is_shell ; then
        el_warning "ignoring el_config_* because we are from a shell"
        return 1
    fi
    # variable must be set
    if [[ -z "${SOURCE}" ]] ; then
        NOREPORTS=1 el_error "\$0 (source tool) should be set to access to its conf ID"
        return 1
    fi

    # }}}

    local tmp_conf_f
    #tmp_conf_f="/tmp/.$(basename $0)_${USER}_configs.sh"
    tmp_conf_f="${HOME}/.config/elive/elive-tools/el_config/${SOURCE//\//%%}_conf.sh"

    if [[ -z "$@" ]] ; then
        el_error "$FUNCNAME called without parameter, (name of variable to save). by ${FUNCNAME[1]}"
        return 1
    fi

    if ! declare -p "$@" 1>/dev/null 2>&1 ; then
        el_error "$FUNCNAME called with a wrong parameter (empty varilable?), use only the name of variable to save. by ${FUNCNAME[1]}"
        return 1
    fi

    # create conf file
    if ! [[ -s "$tmp_conf_f" ]] ; then
        if ! mkdir -p "$( dirname "$tmp_conf_f" )" ; then
            el_error "unable to create confs dir: $( mkdir -p \"$( dirname "$tmp_conf_f" )\" 2>&1 ), $( ls -la "$HOME" | grep "\.config" | tr '\n' ';'  ), $( ls -la "${HOME}/.config/elive/elive-tools/" | tr '\n' ';'  )"
            return 1
        fi

        touch "$tmp_conf_f"
    fi

    # }}}
    # remove old possible entries
    for entry in "$@"
    do
        if ! [[ "$entry" = "conf_"* ]] ; then
            el_warning "variables to save should be prepended as conf_* and you have '$entry', this will ensure that you know that is a conf variable and to NEVER set them as a local variable in your code, otherwise will not work since bash 5.0"
        fi

        # bash entries
        sed -i "/^${entry}=/d" "$tmp_conf_f"
        sed -i "/^declare.* ${entry}=/d" "$tmp_conf_f"
        # zsh entries
        sed -i "/^typeset.* ${entry}=/d" "$tmp_conf_f"
        sed -i "/^typeset.* ${entry}$/d" "$tmp_conf_f"
        #el_debug "deleted old conf: $entry"
    done

    if [[ "$( declare -p "$@" | wc -l )" -gt 1 ]] ; then
        el_warning "saving variables with more than one line give problems, dont use it in your code or improve the function: $@"
    fi

    # append configuration, and save the variable as global so it can work outside this function
    # Warning: never use "local" variables in your function for the ones that you are going to save
    declare -p "$@" | sed -e 's|declare\s--|declare -|g' -e 's|declare -|declare -g|g' | awk '{$2 = $2" --"; print $0}' >> "$tmp_conf_f"
    return 0
}

#===  FUNCTION  ================================================================
#          NAME:  el_config_restart
#   DESCRIPTION:  remove all configurations
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
el_config_restart(){
    # pre {{{
    local tmp_conf_f

    tmp_conf_f="${HOME}/.config/elive/elive-tools/el_config/${SOURCE//\//%%}_conf.sh"

    # }}}
    # checks {{{
    if el_check_is_shell ; then
        el_debug "ignoring el_config_* because we are from a shell"
        return 0
    fi
    # variable must be set
    if [[ -z "${SOURCE}" ]] ; then
        el_error "\$0 is not set"
        return 0
    fi

    # }}}
    if [[ -s "$tmp_conf_f" ]] ; then
        rm -f "$tmp_conf_f"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_ram_usage_show
#   DESCRIPTION:  shows memory usage (ram)
#    PARAMETERS:  $1 = free|total|used (optional)
#       RETURNS:  info
#===============================================================================
el_ram_usage_show(){
    # pre {{{
    local arg used total free

    arg="$1"

    # }}}

    # all reports are in MB
      case "$arg" in
          free)
              free -m | LC_ALL=C grep "^Mem: " | awk '{print $7}'
              ;;
          total)
              free -m | LC_ALL=C grep "^Mem: " | awk '{print $2}'
              ;;
          used)
              free -m | LC_ALL=C grep "^Mem: " | awk '{print $3}'
              ;;
          used_percent)
              used="$( free -m | LC_ALL=C grep "^Mem: " | awk '{print $3}' )"
              total="$( free -m | LC_ALL=C grep "^Mem: " | awk '{print $2}' )"
              echo "( $used / $total ) * 100" | bc -l | sed -e 's|\..*$||g'
              ;;
          *)
              free
              ;;
      esac

}

#===  FUNCTION  ================================================================
#          NAME:  el_architecture
#   DESCRIPTION:  returns the architecture
#    PARAMETERS:  $1 = host | kernel, $2 = file to use to know arch (host mode only)
#       RETURNS:  string
#===============================================================================
el_architecture(){
    # pre {{{
    local arg arch file

    if [[ -n "$1" ]] ; then
        arg="$1"
        shift
    fi

    if [[ -n "$1" ]] ; then
        file="$1"
        shift
    fi

    # defaults
    if [[ -z "$file" ]] ; then
        file="/bin/ls"
    fi

    # }}}
    # fetch data
    case "$arg" in
        kernel)
            arch="$( uname -m )"
            ;;
        host)
            arch="$( file -Lb "$file" | sed -e 's|, version .*$||g' -e 's|^.*, ||g' )"
            ;;
        *)
            el_error "argument missing, select one: host, kernel"
            return 1
            ;;
    esac

    # convert
    case "$arch" in
        x86-64|x86_64|amd64|64bit)
            arch="amd64"
            ;;
        *80386|i386|i486|i586|i686)
            arch="i386"
            ;;
    esac

    # result
    if [[ -n "$arch" ]] ; then
        echo "$arch"
    else
        el_error "unable to know (args '$@' ) the architecture '${arch}' for this machine, uname -m '$(uname -m)', file -Lb /bin/ls '$( file -Lb /bin/ls 2>&1 )'"
        return 1
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  el_get_machine_id
#   DESCRIPTION:  get a unique machine identifier (root)
#    PARAMETERS:  -
#       RETURNS:  value id
#===============================================================================
el_get_machine_id(){
    # pre {{{
    local machine_id
    #el_debug
    #el_security_function_loop || return 0

    # use the cached / saved ID
    if grep -qsF "machine-id: " "/etc/elive-version" 2>/dev/null ; then
        machine_id="$( cat /etc/elive-version | grep "^machine-id: " | sed -e 's|^machine-id: ||g' | tail -1 )"
        if [[ -n "$machine_id" ]] ; then
            echo "$machine_id"
            return
        fi
    fi

    if ! [[ "$UID" = 0 ]] ; then
        el_error "$FUNCNAME must be run with privileges"
        return 1
    fi

    # }}}

    # get system uuid
    if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
        machine_id="$( dmidecode -s system-uuid 2>/dev/null || true )"
        read -r machine_id <<< "$machine_id"
        if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
            unset machine_id
        else
            machine_id="systemuuid${machine_id}"
        fi
    fi

    # get board serial number
    if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
        machine_id="$( cat /sys/class/dmi/id/board_serial 2>/dev/null || true )"
        read -r machine_id <<< "$machine_id"
        if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
            unset machine_id
        else
            machine_id="boardserial${machine_id}"
        fi
    fi

    # get system serial number
    if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
        machine_id="$( dmidecode -s system-serial-number 2>/dev/null || true)"
        read -r machine_id <<< "$machine_id"
        if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
            unset machine_id
        else
            machine_id="systemserialnumber${machine_id}"
        fi
    fi

    # get product name
    if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
        machine_id="$( dmidecode -s system-product-name 2>/dev/null || true )"
        read -r machine_id <<< "$machine_id"
        if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
            unset machine_id
        fi
    fi

    # pack a combination of identifiers to make sure we have a machine id
    if [[ -z "$machine_id" ]] || [[ "$machine_id" = 0 ]] || [[ "$machine_id" = INVALID ]] || [[ "$machine_id" = Not* ]] ; then
        machine_id="$( dmidecode -s bios-vendor )$machine_id"
        machine_id="$( dmidecode -s bios-version )$machine_id"
        machine_id="$( dmidecode -s system-manufacturer )$machine_id"
        machine_id="$( dmidecode -s system-product-name )$machine_id"
        machine_id="$( echo "$( echo "$machine_id" ; cat /proc/cpuinfo 2>/dev/null | LC_ALL=C grep -E "(model name|model|cpu family)" 2>/dev/null | sort -u 2>/dev/null | psort -- -p "^model.*:" | head -1 )" | md5sum 2>/dev/null | awk '{print $1}' 2>/dev/null )"
        read -r machine_id <<< "$machine_id"
        machine_id="packed${machine_id}"
    fi

    # cleanups and backup
    if [[ -z "$machine_id" ]] ; then
        # re-use a backup if we cannot fetch machine-id in shutdown step
        if [[ -e "/tmp/.machine-id" ]] ; then
            machine_id="$( cat /tmp/.machine-id 2>/dev/null || true )"
            read -r machine_id <<< "$machine_id"
        fi
    fi

    # show results
    if [[ -n "$machine_id" ]] ; then
        echo "$machine_id"
    else
        el_error "no machine id found"
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  el_json_append_file
#   DESCRIPTION:  appends a json file to an existing one
#    PARAMETERS:  $1 = file, $2 = extra-file-contents
#===============================================================================
el_json_append_file(){
    # pre {{{
    local file extra extrafile
    el_debug
    el_security_function_loop || return

    file="$1"
    extrafile="$2"

    el_check_variables "file|extrafile"

    if [[ ! -s "$file" ]] ; then
        el_error "file given is empty: $file"
        return 1
    fi
    if [[ ! -s "$extrafile" ]] ; then
        el_error "file extra given is empty: $extrafile"
        return 1
    fi

    if ! el_dependencies_check jq ; then
        el_dependencies_install "jq"
    fi

    # }}}
    # fixes
    extra="$( cat "$extrafile" )"
    if ! cat "$file" | jq -S ". |= . + ${extra}" 1>/dev/null 2>&1 ; then
        extra="$( echo "{ $extra }" )"
    fi

    # append extra file to original one
    if cat "$file" | jq -S ". |= . + ${extra}" 1>/dev/null 2>&1 ; then
        cat "$file" | jq -S ". |= . + ${extra}" > "${file}.new" && mv -f "${file}.new" "$file"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  el_json_delete_ids_regex
#   DESCRIPTION:  delete IDs (named entries) from a regex string
#    PARAMETERS:  $1 = file, $2 = regex
#===============================================================================
el_json_delete_ids_regex(){
    # pre {{{
    local file match
    el_debug
    el_security_function_loop || return

    file="$1"
    match="$2"

    el_check_variables "file|match"

    if [[ ! -s "$file" ]] ; then
        el_error "file given is empty: $file"
        return 1
    fi
    if [[ -z "$match" ]] ; then
        el_error "nothing to match '$match' for given file '$file'"
        return 1
    fi

    if ! el_dependencies_check jq ; then
        el_dependencies_install "jq"
    fi

    # }}}
    # delete matches
    #cat "$file" | jq "delpaths([paths | select(.[-1] | strings | startswith(\"${match}\"))])" > "${file}.new" && mv -f "${file}.new" "$file"
    cat "$file" | jq "delpaths([paths | select(.[-1] | strings | test(\"${match}\"; \"ix\"))])" > "${file}.new" && mv -f "${file}.new" "$file"
}

#-------------------------------------------------------------------------------
#   get the version of an installed package or a candidate, in a faster way
#   $1 = packagename , $2 installed | candidate , $3 full | clean
#-------------------------------------------------------------------------------
el_apt_package_version_get(){
    local package state mode version
    package="$1"
    shift
    state="$1"
    shift
    mode="$1"
    shift

    case "$state" in
        "installed")
            version="$( awk -v FS="\n" -v RS="" -v package="$package" '{ if ( ($1 == "Package: "package ) && ($2 == "Status: install ok installed" || $2 == "Status: hold ok installed") ) print $0}' /var/lib/dpkg/status | LC_ALL=C grep "^Version: " | sed -e 's|^Version: ||g' )"
            if [[ -z "$version" ]] ; then
                version="$( LC_ALL="$EL_LC_EN" apt-cache policy "$package" | LC_ALL=C grep -F "Installed:" | sed -e 's|^.*Installed: ||g' | LC_ALL=C grep -E "^[[:digit:]]*" | head -1 )"
            fi
            ;;

        "candidate")
            version="$( LC_ALL="$EL_LC_EN" apt-cache policy "$package" | LC_ALL=C grep -F "Candidate:" | sed -e 's|^.*Candidate: ||g' | LC_ALL=C grep -E "^[[:digit:]]*" | head -1 )"
            ;;
    esac

    read -r version <<< "$version"

    # check
    if [[ -z "$version" ]] ; then
        return 1
    fi

    case "$mode" in
        clean)
            # clean version values
            version="${version#*:}"
            version="${version%-*}"
            ;;
        full)
            version="${version}"
            ;;
    esac

    echo "$version"
}


#-------------------------------------------------------------------------------
#   apt-get wrapper with lock feature
#-------------------------------------------------------------------------------
el_aptget(){
    local is_waiting i j is_shown
    i=0

    tput sc
    while fuser /var/lib/dpkg/lock /var/lib/apt/lists/lock  >/dev/null 2>&1 ; do
        case $(($i % 4)) in
            0 ) j="-" ;;
            1 ) j="\\" ;;
            2 ) j="|" ;;
            3 ) j="/" ;;
        esac
        tput rc
        if ((is_interactive)) ; then
            echo -en "\r\033[K[$j] Waiting for other software managers to finish..." 1>&2
        else
            if [[ -n "$DISPLAY" ]] && ! ((is_shown)) ; then
                el_notify normal "packages-gdebi" "Package Tasks Running" "Waiting for other software managers to finish before to continue..."
                is_shown=1
            fi
        fi
        is_waiting=1

        sleep 0.5
        ((i=i+1))
    done

    # run what we want
    if [[ "$UID" = 0 ]] ; then
        TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  apt-get "$@"
    else
        if el_check_sudo_automated ; then
            TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  sudo apt-get "$@"
        else
            if [[ "${DISPLAY}" = ":0.0" ]] ; then
                if ! el_dependencies_check gksu ; then
                    el_dependencies_install "gksu"
                fi
                TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  gksu apt-get "$@"
            else
                #su -c "TERM=linux DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true  apt-get $@" root
                urxvt -e bash -c "echo -e 'Installing Dependencies' ; su -c 'TERM=screen-256color DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical DEBCONF_NONINTERACTIVE_SEEN=true DEBCONF_NOWARNINGS=true apt-get $@' root"
            fi
        fi
    fi
}




###################################################################
# DEPRECATED FUNCTIONS TO FALLBACK:
###################################################################
el_notify_user(){
    el_warning "Deprecated function $FUNCNAME by elive-tools functions from $SOURCE $0 - (fallback to el_notify)"
    el_notify "normal" "logo-elive" "$1" "$2"
}
el_notify_user_important(){
    el_warning "Deprecated function $FUNCNAME by elive-tools functions from $SOURCE $0 - (fallback to el_notify)"
    el_notify "critical" "logo-elive" "$1" "$2"
}
el_check_translations_required_notify(){
    el_error "deprecated function $FUNCNAME from elive-tools functions from $SOURCE $0, use el_check_translations_required instead"
}
el_check_dependencies(){
    # compatibility
    el_warning "$FUNCNAME is moved to 'el_dependencies_check', update or report this code (full compatibility still working, don't worry), from: ${FUNCNAME[1]}"
    el_dependencies_check "$@"
}


###################################################################
#  Always run:
###################################################################

# gettext functions
if [[ -x "/usr/bin/gettext.sh" ]] ; then
    . gettext.sh
else
    # make it compatible
    eval_gettext(){
        echo "$@"
    }
fi

if [[ -n "$ZSH_VERSION" ]] ; then
    # Note: seems like if you put a ? just after a char, cannot be sourced correctly from zsh
    setopt nonomatch
    alias shopt=':'
    alias _expand=_bash_expand
    alias _complete=_bash_comp
    #emulate -L sh
    #setopt kshglob noshglob braceexpand
    # always split words or this would make things incompatible, like for i in ${PATH//:/ } (in other words, variables split by spaces instead of sentences, just like in bash
    setopt shwordsplit

    # we cannot set parameters on this variable, so use it without icon:
    [[ -z "$guitool" ]] && [[ -x "/usr/bin/zenity" ]] && guitool="/usr/bin/zenity"
else
    [[ -z "$guitool" ]] && [[ -x "/usr/bin/zenity" ]] && guitool="/usr/bin/zenity --window-icon=/usr/share/icons/gnome/256x256/apps/logo-elive.png"
fi

# do we are in a terminal ? avoid interactive-in-terminal if not
if [[ -n "$TERM" ]] ; then
    # this can be from a cronjob
    if [[ "$TERM" = "dumb" ]] ; then
        # know which desktop we are running, if we are
        if [[ -z "$E_START" ]] && [[ -z "$EROOT" ]] ; then
            if pgrep -U "$UID" e16 1>/dev/null ; then
                if [[ -d "/usr/share/e16" ]] ; then
                    export EROOT=/usr/share/e16
                else
                    el_warning "$FUNCNAME - ${FUNCNAME[1]}: seems like our user is running e16 as desktop but there is not /usr/share/e16 directory"
                fi
            else
                if pgrep -U "$UID" enlightenment_start 1>/dev/null ; then
                    if [[ -e "/usr/bin/enlightenment_start" ]] ; then
                        export E_START="/usr/bin/enlightenment_start"
                    else
                        el_warning "$FUNCNAME - ${FUNCNAME[1]}: seems like our user is running e16 as desktop but there is not /usr/bin/enlightenment_start executable"
                    fi
                fi
            fi
        fi
    fi

    # note: TTY variable not shows in bash login aparently
    if [[ "$TERM" = "linux" ]] ; then
        # note: if you want to enable colors in an application run from E (.desktop file), you must set the TERM variable, and LS_COLORS too
        if [[ -n "$E_START" ]] || [[ -n "$EROOT" ]] ; then
            # launched from e17 itself
            is_terminal=0
            is_console=0
        else
            # note: in the past we had is_terminal=1 forced in order to get features from other things, this is not needed anymore since the use of is_interactive
            is_terminal=0
            is_console=1
        fi
    fi

    # note: do not use [[ "$TERM_PROGRAM" = "tmux" ]] because we may run things from non-interactive using tmux-attach-jobs
    if [[ "$TERM" = *rxvt* ]] || [[ "$TERM" = *xterm* ]] || [[ "$TERM" = "terminology" ]] || [[ "$TERM" = *gnome* ]] || [[ "$TERM" = "screen-256color"* ]] || [[ "$TERM" = *tmux* ]] ; then
        is_terminal=1
        is_console=0
    fi

    # cronjobs must never be interactives
    if [[ "$TERM" = "dumb" ]] ; then
        is_terminal=0
    fi
else
    is_terminal=0
    is_console=0
    # if we don't have TERM we need this value to not trigger 'tput' errors like when running apt commands
    # update: apt should have the variable set itself
    #export TERM="linux"
fi

if ((is_terminal)) || ((is_console)) ; then
    is_interactive=1
fi

if [[ -n "$FORCE_INTERACTIVE" ]] ; then
    case "$FORCE_INTERACTIVE" in
        "yes")      is_interactive=1  ; ;;
        "no")       unset is_interactive  ; ;;
    esac
fi


# TODO: LS_COLORS is not a reliable way to know that we are on a terminal, we should rely on is_terminal then
if [[ -n "$NOCOLOR" ]] || ! ((is_interactive)) ; then
    el_c_n=""
    el_c_r=""
    el_c_r2=""
    el_c_g=""
    el_c_g2=""
    el_c_y=""
    el_c_y2=""
    el_c_m=""
    el_c_m2=""
    el_c_c=""
    el_c_c2=""
    el_c_b=""
    el_c_b2=""
    el_c_gr=""
    el_c_gr2=""
    el_c_w=""
    el_c_w2=""

    el_c_blink=""
    el_c_underline=""
    el_c_italic=""
    el_c_bold=""
else
    el_c_gr="\033[1;30m" # Gray color
    el_c_gr2="\033[0;30m" # Gray2 color
    el_c_r="\033[1;31m" # Red color  (orig: red)
    el_c_r2="\033[0;31m" # Red2 color  (orig: red)
    el_c_g="\033[1;32m" # Green color  (orig: green)
    el_c_g2="\033[0;32m" # Green2 color  (orig. green2)
    el_c_y="\033[1;33m" # Yellow color  (orig. yellow)
    el_c_y2="\033[0;33m" # Yellow2 color  (orig. yellow)
    el_c_b="\033[1;34m" # Blue color
    el_c_b2="\033[0;34m" # Blue2 color
    el_c_m="\033[1;35m" # Magenta color
    el_c_m2="\033[0;35m" # Magenta2 color
    el_c_c="\033[1;36m" # Cyan color
    el_c_c2="\033[0;36m" # Cyan2 color
    el_c_w="\033[1;37m" # White
    el_c_w2="\033[0;37m" # White strong
    el_c_n="\033[0;39m" # Normal color  (orig: normal)

    if ((is_console)) ; then
        ## gray's are not visible in console when vga=normal (t460s doesnt configure the good one so it fallbacks to normal), use cyan's instead
        el_c_gr="\033[1;36m" # Gray color
        #el_c_gr2="\033[0;36m" # Gray2 color
    fi
    #else
        #el_c_gr="\033[1;30m" # Gray color
        #el_c_gr2="\033[0;30m" # Gray2 color
    #fi

    el_c_blink="\033[5m" # Blink 'color' effect  (orig. blink)
    el_c_underline="\033[4m" # Underline 'color' effect  (orig. underline)
    el_c_italic="\033[3m" # Italic 'color' effect
    el_c_bold="\033[1m" # Bold 'color' effect
fi

# Elive debug verbosity:
# - 0 : only show errors
# - 1 : + warnings
# - 2 : + info messages (user always should want to see information messages, so this should be the default one)
# - 3 : + debug
# - 4 : + very debug
# - 5 : + very very debug
#if grep -Fqs thanatest /proc/cmdline ; then
    #EL_DEBUG=${EL_DEBUG:-"3"}
#else
    EL_DEBUG=${EL_DEBUG:-"2"}
#fi


# extra vars
source /etc/adduser.conf 2>/dev/null || true
[[ -z "$DHOME" ]] && export DHOME=/home
# set the user's home, sometimes, like if we are in an init script, the home points to /
if [[ -z "$HOME" ]] || [[ "$HOME" = "/" ]] ; then
    if [[ "$UID" = "0" ]] || [[ "$USER" = "root" ]] ; then
        export HOME="/root"
    else
        export HOME="$DHOME/$(id -un)"
    fi
fi

if [[ -z "$USER" ]] ; then
    export USER="$(id -un)"
fi


# use LC_ALL=C like this instead:  LC_ALL="$EL_LC_EN":
if LC_ALL=C grep -qs "^en_US.UTF-8\s*" "/etc/locale.gen" ; then
    EL_LC_EN="en_US.UTF-8"
else
    # warning: this can broke things by not being utf8
    EL_LC_EN="C"
fi





# FIXME: implement:
#
# - check same proceses
# - el_fixme_required -> report to the user that the feature is not implemented by some future userfriendly way
# - arrays ?
# - run web
# - trap signals (exit statuses, etc)
#EXAMPLES (of correct managing of traps):
    #set -E  # inherit errors to parent, good for deep traping, suggested
    #trap "error_signal_debug" ERR  # the ERR traps any error, so "ls idontexist" would send this signal too, which is not suggested to have in the exit_error function, but at least good for a debug purpose and know that something failed somewhere
    #trap "exit_error" 1 2 3 6 9 11 13 14 15
    #trap "exit_ok" 0 EXIT
    #el_add_on_exit exit_ok  # or you can use this feature, so it calls commands when something is finished, good to add "rm thisfile" everywhere arounds the code
    #error_signal_debug(){
        #_trapped="$?"
        #if [[ -n "$_trapped" ]] ; then
            #el_warning "trapped signal: '${_trapped}' from '${FUNCNAME[1]}' in lines '${BASH_LINENO[*]}'"
        #fi
    #}
    #exit_error(){
        #_trapped="$?"
        #cleanups
        #exit $_trapped
    #}
    #exit_ok(){
        #echo "good bye"
    #}
# - report, something for inform the user about something important, which interfaces and cases ?
# -
# -
# -
# -
# -
# -


# vim: set foldmethod=marker filetype=sh :

