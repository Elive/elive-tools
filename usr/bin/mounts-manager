#!/bin/bash
source /usr/lib/elive-tools/functions

#===  FUNCTION  ================================================================
#          NAME:  chroot_layers_mount
#   DESCRIPTION:  mount the layers needed for a working chroot
#    PARAMETERS:  $1 directory, $2 name-id-to-use, $3 = mode (opt)
#       RETURNS:  -
#===============================================================================
chroot_layers_mount(){
    # pre {{{
    local dir id mode is_mode_bind
    el_debug
    el_security_function_loop 10 || return

    dir="$1"
    id="$2"
    mode="$3"
    if ! el_check_variables "dir,id" || ! el_check_dirs "$dir" ; then
        exit 1
    fi

    if [[ "${UID}" != "0" ]] ; then
        el_error "must require root privileges"
    fi

    if [[ "$mode" = "bind" ]] ; then
        is_mode_bind=1
        el_debug "using bind mode of mounting layers"
    fi

    sync

    # }}}

    if el_flag check "chroot_layer_prepared" ; then
        el_explain 3 "chroot layers already mounted"
        return
    fi

    # create some needed dirs if they don't exist yet:
    mkdir -p "${dir}/home" "${dir}/tmp" "${dir}/var/lib/live" "${dir}/var/lock" "${dir}/var/log" "${dir}/var/run" "${dir}/var/tmp" "${dir}/var/spool"

    # devpts
    mkdir -p "$dir/dev/pts"
    if ((is_mode_bind)) ; then
        mount --bind "/dev" "${dir}/dev"
        mount --bind "/dev/pts" "${dir}/dev/pts"
    else
        mount devpts-$id -t devpts "${dir}/dev/pts" || true
    fi

    # proc
    mkdir -p "$dir/proc"
    if ((is_mode_bind)) ; then
        mount --bind "/proc" "${dir}/proc"
        rm -f "${dir}/etc/mtab"
        ln -s /proc/mounts "${dir}/etc/mtab"
    else
        mount proc-$id -t proc "${dir}/proc" || true
    fi

    # selinux
    if [[ -e "/selinux/enforce" ]] && [[ "$(cat /selinux/enforce)" = "1" ]] ; then
        mkdir -p "$dir/selinux"
        if ((is_mode_bind)) ; then
            mount --bind "/selinux" "${dir}/selinux"
        else
            mount selinuxfs-$id -t selinuxfs "${dir}/selinux" || true
        fi
    fi

    # sysfs
    mkdir -p "$dir/sys"
    if ((is_mode_bind)) ; then
        mount --bind "/sys" "${dir}/sys"
    else
        mount sysfs-$id -t sysfs "${dir}/sys" || true
    fi

    # debian chroot mark
    mkdir -p "$dir/etc"
    echo "live" > "${dir}/etc/debian_chroot"

    # custom start-stop-daemon
    if [[ -e "$dir/sbin/start-stop-daemon" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /sbin/start-stop-daemon
        echo -e "#!/bin/sh\nexit 0" > "${dir}/sbin/start-stop-daemon"
        chmod 755 "${dir}/sbin/start-stop-daemon"
    fi

    # disable dpkg syncin
    mkdir -p "$dir/etc/dpkg/dpkg.cfg.d"
    echo -e "force-unsafe-io" > "${dir}/etc/dpkg/dpkg.cfg.d/live-build"

    # flash-kernel
    if [[ -e "$dir/usr/sbin/flash-kernel" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /usr/sbin/flash-kernel
        ln -s /bin/true "${dir}/usr/sbin/flash-kernel"
    fi

    # sysv-rc
    mkdir -p "$dir/usr/sbin"
    if [[ -e "$dir/usr/sbin/policy-rc.d" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /usr/sbin/policy-rc.d
        echo -e "#!/bin/sh\necho 'All runlevel operations denied by policy, made by elive modifications' >&2 \nexit 101" > "${dir}/usr/sbin/policy-rc.d"
        chmod 0755 "${dir}/usr/sbin/policy-rc.d"
    fi

    # upstart
    if [[ -e "$dir/sbin/initctl" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /sbin/initctl
        echo -e "#!/bin/sh\necho 'All runlevel operations denied by policy, made by elive modifications' >&2 \nexit 101" > "${dir}/sbin/initctl"
        chmod 0755 "${dir}/sbin/initctl"
    fi

    # hosts file
    mkdir -p "$dir/etc"
    if [[ -f "$dir/etc/hosts" ]] ; then
        mv "$dir/etc/hosts" "$dir/etc/hosts.orig"
    fi
    echo -e "127.0.0.1\tlocalhost localhost.localdomain\n127.0.1.1\tdebian" > "$dir/etc/hosts"
    cat /etc/hosts >> "$dir/etc/hosts"

    # resolv.conf
    mkdir -p "$dir/etc"
    if [[ -e "$dir/etc/resolv.conf" ]] ; then
        mv "$dir/etc/resolv.conf" "$dir/etc/resolv.conf.orig"
        : > "$dir/etc/resolv.conf"
    elif [[ -L "$dir/etc/resolv.conf" ]] ; then
        mv "$dir/etc/resolv.conf" "$dir/etc/resolv.conf.orig"
    fi
    cp /etc/resolv.conf "$dir/etc/resolv.conf"

    # hostname
    mkdir -p "$dir/etc" "$dir/bin"
    if [[ -e "$dir/etc/hostname" ]] ; then
        mv "$dir/etc/hostname" "$dir/etc/hostname.orig"
    fi
    echo "localhost.localdomain" > "$dir/etc/hostname"
    if [[ -x "$dir/usr/bin/dpkg-divert" ]] ; then
        chroot "$dir" dpkg-divert --rename --quiet --add /bin/hostname
        echo -e "#!/bin/sh\necho 'localhost.localdomain'" > "$dir/bin/hostname"
        chmod 755 "$dir/bin/hostname"
    fi

    echo "Layers for chroot $dir are now ready"

    # add a flag
    el_flag add "chroot_layer_prepared"


}
#===  FUNCTION  ================================================================
#          NAME:  chroot_layers_umount
#   DESCRIPTION:  umount the layers of a chroot
#    PARAMETERS:  $1 dir , $2 name-id-to-use
#       RETURNS:  -
#===============================================================================
chroot_layers_umount(){
    # pre {{{
    local dir id mode is_mode_bind
    el_debug
    el_security_function_loop 10 || return

    dir="$1"
    id="$2"
    mode="$3"
    el_check_variables "dir"
    el_check_dirs "$dir"

    if [[ "${UID}" != "0" ]] ; then
        el_error "must require root privileges"
    fi

    if [[ "$mode" = "bind" ]] ; then
        is_mode_bind=1
        el_debug "using bind mode of umounting layers"
    fi

    sync

    # }}}

    if ! el_flag check "chroot_layer_prepared" ; then
        el_explain 3 "chroot layers already umounted"
        return
    fi

    # devpts
    if ((is_mode_bind)) ; then
        if check_is_mounted "$dir/dev/pts" 2>/dev/null 1>&2 ; then
            umount "$dir/dev/pts"
        fi
        if check_is_mounted "$dir/dev" 2>/dev/null 1>&2 ; then
            umount "$dir/dev"
        fi
    else
        if check_is_mounted "$dir/dev/pts" 2>/dev/null 1>&2 ; then
            if grep -qs "$dir/dev/pts" /proc/mounts || el_check_dir_has_files "$dir/"dev/pts/* ; then
                umount "$dir/dev/pts"
            else
                umount -f "$dir/dev/pts" 2>/dev/null 1>&2 || true
            fi
        fi
    fi

    # proc
    if ((is_mode_bind)) ; then
        if check_is_mounted "$dir/proc" 2>/dev/null 1>&2 ; then
            umount "$dir/proc"
        fi

        # this was a link to parent /proc/mounts
        rm -f "${dir}/etc/mtab"
    else
        if check_is_mounted "$dir/proc" 2>/dev/null 1>&2 ; then
            if [[ -e "${dir}/proc/sys/fs/binfmt_misc/status" ]] ; then
                umount "$dir/proc/sys/fs/binfmt_misc"
            fi
            if [[ -e "${dir}/proc/version" ]] ; then
                umount "$dir/proc"
            fi
        fi
    fi

    # selinux
    if ((is_mode_bind)) ; then
        if check_is_mounted "$dir/selinux" 2>/dev/null 1>&2 ; then
            umount "$dir/selinux"
        fi
    else
        if check_is_mounted "$dir/selinux" 2>/dev/null 1>&2 || [[ -e "$dir/selinux/enforce" ]] ; then
            umount "$dir/selinux"
        fi
    fi

    # sysfs
    if ((is_mode_bind)) ; then
        if check_is_mounted "$dir/sys" 2>/dev/null 1>&2 ; then
            umount "$dir/sys"
        fi
    else
        if check_is_mounted "$dir/sys" 2>/dev/null 1>&2 ; then
            umount "$dir/sys"
        fi
    fi

    # debian chroot mark
    rm -f "${dir}/etc/debian_chroot"

    # flash-kernel
    if [[ -e "$dir/usr/sbin/flash-kernel.distrib" ]] ; then
        rm -f "${dir}/usr/sbin/flash-kernel"
        chroot "$dir" dpkg-divert --rename --quiet --remove /usr/sbin/flash-kernel
    fi
    # custom start-stop-daemon
    if [[ -e "$dir/sbin/start-stop-daemon.distrib" ]] ; then
        rm -f "${dir}/sbin/start-stop-daemon"
        chroot "$dir" dpkg-divert --rename --quiet --remove /sbin/start-stop-daemon
    fi
    # disable dpkg syncin
    rm -f "${dir}/etc/dpkg/dpkg.cfg.d/live-build"

    # sysv-rc
    if [[ -e "$dir/usr/sbin/policy-rc.d.distrib" ]] ; then
        rm -f "${dir}/usr/sbin/policy-rc.d"
        chroot "$dir" dpkg-divert --rename --quiet --remove /usr/sbin/policy-rc.d
    fi

    # upstart
    if [[ -e "$dir/sbin/initctl.distrib" ]] ; then
        rm -f "${dir}/sbin/initctl"
        chroot "$dir" dpkg-divert --rename --quiet --remove /sbin/initctl
    fi

    # hosts file
    if [[ -f "$dir/etc/hosts.orig" ]] ; then
        mv "$dir/etc/hosts.orig" "$dir/etc/hosts"
    else
        : > "$dir/etc/hosts"
    fi

    # resolv.conf
    if [[ -f "$dir/etc/resolv.conf.orig" ]] ; then
        mv "$dir/etc/resolv.conf.orig" "$dir/etc/resolv.conf"
    else
        : > "$dir/etc/resolv.conf"
    fi
    if [[ -e "$dir/etc/resolv.conf.d" ]] ; then
        rm -f "$dir/etc/resolv.conf.d/original"
        rm -f "$dir/etc/resolv.conf.d/tail"
    fi

    # hostname
    rm -f "$dir/etc/hostname"
    if [[ -e "$dir/etc/hostname.orig" ]] ; then
        mv "$dir/etc/hostname.orig" "$dir/etc/hostname"
    fi
    if [[ -e "$dir/bin/hostname.distrib" ]] ; then
        rm -f "${dir}/bin/hostname"
        chroot "$dir" dpkg-divert --rename --quiet --remove /bin/hostname
    fi

    echo "Layers for chroot $dir are umounted"

    # remove the flag
    el_flag del "chroot_layer_prepared"

}

#===  FUNCTION  ================================================================
#          NAME:  get_mountpoint
#   DESCRIPTION:  get the mountpoint of a device
#    PARAMETERS:  $1 = device
#       RETURNS:  -
#===============================================================================
get_mountpoint(){
    # pre {{{
    local dev is_mounted mountpoint is_temporally_mounted
    el_debug
    el_security_function_loop 10 || return

    dev="$1"
    el_check_variables "dev"
    el_dependencies_check "udisks"

    # }}}

    if [[ ! -b "$dev" ]] ; then
        el_explain 1 "$dev is not a device, skipping"
        return 1
    fi


    mountpoint="$( LC_ALL=C udisks --show-info "$dev" | grep "mount paths:" | sed -e 's|^.*mount paths:||g' )"
    read -r mountpoint <<< "$mountpoint"

    # not mounted ? mount it first
    if [[ -z "$mountpoint" ]] && ! check_is_mounted "$dev" 2>/dev/null 1>&2 ; then
        #if LC_ALL=C udisks --show-info "$dev" | grep -qs "is mounted:.*0" ; then

        #udisks --mount "$dev" 1>/dev/null
        #sync
        # TODO: if i use el_mount here it fails by some strange reason, why ? get_mountpoint not gets the mountpoint correctly?
        if el_mount "$dev" 1>/dev/null ; then

            # get data again
            mountpoint="$( LC_ALL=C udisks --show-info "$dev" | grep "mount paths:" | sed -e 's|^.*mount paths:||g' )"
            # remove extra leading blank chars
            read -r mountpoint <<< "$mountpoint"
            # umount it
            if [[ -n "$mountpoint" ]] ; then
                el_umount "$mountpoint" 1>/dev/null
            fi
        fi
    fi


    # get the mountpoint
    if [[ -n "$mountpoint" ]] ; then
        # disable this supposed feature, it brokes when labels of partitions includes a space like "ian home"
        #if [[ "$(echo "$mountpoint" | wc -w )" -gt 1 ]] ; then
            #el_warning "More than one mountpoint assigned to ${dev}: ${mountpoint}, using the last one"
            #mountpoint="$(echo "$mountpoint" |tr ' ' '\n' | tail -1)"
        #fi

        # and so, show the result
        echo "$mountpoint"
        return 0
    else
        # nothing get, return an error
        el_warning "unable to get mountpoint for ${dev}, is it this partition formated and mountable?"
        return 1
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  check_is_mounted
#   DESCRIPTION:  returns true if a device or mountpoint is mounted
#    PARAMETERS:  $1 dev or mountpoint
#       RETURNS:  true if is mounted, false if not
#===============================================================================
check_is_mounted(){
    # pre {{{
    local arg device mountpoint is_device is_mountpoint
    el_security_function_loop 10 || return

    arg="$1"
    el_check_variables "arg"

    sync
    # }}}

    if [[ "$arg" = /dev/* ]] ; then
        is_device=1
        device="$arg"
        if [[ ! -b "$device" ]] ; then
            el_error "$FUNCNAME, device $device doesn't seems to exist"
            return 1
        fi
    else
        is_mountpoint=1
        mountpoint="${arg%/}"
    fi


    if ((is_mountpoint)) ; then
        if LC_ALL=C mount | grep -qs "on ${mountpoint} type" ; then
            el_debug "Mountpoint $mountpoint mounted"
            echo "Mounted"
            return 0
        else
            el_debug "Mountpoint $mountpoint not mounted"
            echo "Not mounted"
            return 1
        fi
    fi

    if ((is_device)) ; then
        # mounted
        if LC_ALL=C udisks --show-info "$device" | grep -qs "is mounted:.*1" ; then
            el_debug "Device $device mounted"
            echo "Mounted"
            return 0
        fi
        # not mounted
        if LC_ALL=C udisks --show-info "$device" | grep -qs "is mounted:.*0" ; then
            el_debug "Device $device not mounted"
            echo "Not mounted"
            return 1
        fi
        # well, maybe not working?
        if LC_ALL=C udisks --show-info "$device" 2>&1 | grep -qs "Cannot find device with major:minor" ; then
            # re-read partition table
            sync ; sleep 1
            /sbin/sfdisk -R "${dev%%[0-9]*}" 2>/dev/null || true

            el_sudo service udev restart
            #el_sudo service dbus restart
            el_warning "udev needed to be restarted from $FUNCNAME"
            #el_array_member_add "UDEV needed to be restarted in 'check_is_mounted' from 'mounts-manager' with device '$device'" "${errors_found[@]}" ; errors_found=("${_out[@]}")
            return 1
        fi
    fi

}
#===  FUNCTION  ================================================================
#          NAME:  el_umount
#   DESCRIPTION:  overwrite layer for a real umount feature
#    PARAMETERS:  $1 dev or mountpoint that we want to umount
#       RETURNS:  true if successfull, false if not
#===============================================================================
el_umount(){
    # pre {{{
    local arg device mountpoint is_device is_mountpoint is_umounted
    el_security_function_loop 10 || return

    # }}}
    for arg in "$@"
    do
        sync

        unset device mountpoint is_device is_mountpoint
        if [[ ! -b "$arg" ]] && [[ ! -d "$arg" ]] && [[ ! -L "$arg" ]] && [[ ! -e "$arg" ]] ; then
            el_warning "What $arg is ? skipping.."
        fi
        if [[ "$arg" = /dev/* ]] ; then
            is_device=1
            device="$arg"
            if [[ ! -b "$device" ]] ; then
                el_error "$FUNCNAME, device $device doesn't seems to exist"
                return 1
            fi
        else
            is_mountpoint=1
            mountpoint="${arg%/}"
        fi

        if ((is_mountpoint)) && ! check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
            # if we are not mounted, nothing more to do
            return 0
        fi

        if ((is_device)) ; then
            # is a wap what we try to umount ?
            if LC_ALL=C file -s "$device" | grep -qs "swap file" ; then
                swapoff "$device" 2>/dev/null
                el_debug "Umounted (swap): $@"
                return 0
            fi
            # if we are not mounted, nothing more to do
            if ! check_is_mounted "$device" 2>/dev/null 1>&2 ; then
                return 0
            fi

            #otherwise get the needed data
            mountpoint="$( get_mountpoint "$device" )"

            if [[ -z "$mountpoint" ]] ; then
                el_warning "unable to get mountpoint for $device, which means that is not mounted, although this function should have not been called, everything is fine, continuing..."
                # return that is not mounted
                return 0
            fi
        fi


        # try to umount
        if ((is_mountpoint)) ; then
            if [[ "$EL_DEBUG" -ge 3 ]] ; then
                command umount "$mountpoint" || command umount "$device"
            else
                command umount "$mountpoint" 2>/dev/null 1>&2 || command umount "$device" 2>/dev/null 1>&2
            fi

            if check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
                el_warning "unable to umount (umount) $dev for ${mountpoint}, trying with another alternative..."
            else
                # special dir created by this own tool, we don't need it anymore
                for dir in  /mnt/*_elive
                do
                    if ! check_is_mounted "$dir" 1>/dev/null ; then
                        rmdir "$dir"
                    fi
                done

                el_debug "Umounted: $@"
                return 0
            fi
        fi


        # try with gvfs-mount first, since seems like it is unable to umount with the other ones
        if ((is_device)) ; then
            if [[ "$EL_DEBUG" -ge 3 ]] ; then
                gvfs-mount -u "$mountpoint"
            else
                gvfs-mount -u "$mountpoint" 2>/dev/null 1>&2
            fi
            if check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
                el_warning "unable to umount (gvfs-mount) $dev for ${mountpoint}, trying with udisks..."
            else
                # special dir created by this own tool, we don't need it anymore
                for dir in  /mnt/*_elive
                do
                    if ! check_is_mounted "$dir" 1>/dev/null ; then
                        rmdir "$dir"
                    fi
                done

                el_debug "Umounted: $@"
                return 0
            fi

            # try with udisks maybe
            if [[ "$EL_DEBUG" -ge 3 ]] ; then
                udisks --unmount "$mountpoint"
            else
                udisks --unmount "$mountpoint" 2>/dev/null 1>&2
            fi
            if check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
                el_warning "unable to umount (udisks) $dev for ${mountpoint}, trying with umount..."
            else
                # special dir created by this own tool, we don't need it anymore
                for dir in  /mnt/*_elive
                do
                    if ! check_is_mounted "$dir" 1>/dev/null ; then
                        rmdir "$dir"
                    fi
                done

                el_debug "Umounted: $@"
                return 0
            fi

            if [[ "$EL_DEBUG" -ge 3 ]] ; then
                command umount "$mountpoint" || command umount "$device"
            else
                command umount "$mountpoint" 2>/dev/null 1>&2 || command umount "$device" 2>/dev/null 1>&2
            fi
            if check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
                el_warning "unable to umount (umount) $dev for ${mountpoint}, so hum... let me think"
            else
                # special dir created by this own tool, we don't need it anymore
                for dir in  /mnt/*_elive
                do
                    if ! check_is_mounted "$dir" 1>/dev/null ; then
                        rmdir "$dir"
                    fi
                done

                el_debug "Umounted: $@"
                return 0
            fi
        fi

        # try to know why we cannot umount it
        el_processes_using_mountpoint "$mountpoint"

        # force ? we should never do this
        if ((is_forced)) ; then
            # kill all the children processes used on this mountpoint:
            el_processes_using_mountpoint "$mountpoint" kill 1>/dev/null

            gvfs-mount -u "$mountpoint" 2>/dev/null 1>&2
            if check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
                el_warning "unable to umount (gvfs-mount) $dev for ${mountpoint}, trying with udisks..."
            else
                # special dir created by this own tool, we don't need it anymore
                for dir in  /mnt/*_elive
                do
                    if ! check_is_mounted "$dir" 1>/dev/null ; then
                        rmdir "$dir"
                    fi
                done

                el_debug "Umounted (forced): $@"
                return 0
            fi

            # try with udisks maybe
            udisks --unmount "$mountpoint" 2>/dev/null 1>&2
            if check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
                el_warning "unable to umount (udisks) $dev for ${mountpoint}, trying with umount..."
            else
                # special dir created by this own tool, we don't need it anymore
                for dir in  /mnt/*_elive
                do
                    if ! check_is_mounted "$dir" 1>/dev/null ; then
                        rmdir "$dir"
                    fi
                done

                el_debug "Umounted (forced): $@"
                return 0
            fi

            command umount "$mountpoint" 2>/dev/null 1>&2 || command umount "$device" 2>/dev/null 1>&2

            if check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
                el_warning "ok, bruteforce time"
                # supercow powers
                command umount -l "$mountpoint" || command umount -l "$device" || command umount -f "$mountpoint" || command umount -f "$device"
            else
                # special dir created by this own tool, we don't need it anymore
                for dir in  /mnt/*_elive
                do
                    if ! check_is_mounted "$dir" 1>/dev/null ; then
                        rmdir "$dir"
                    fi
                done

                el_debug "Umounted (forced): $@"
                return 0
            fi
        fi

        if check_is_mounted "$mountpoint" 2>/dev/null 1>&2 ; then
            el_error "unable to umount $dev for ${mountpoint}, I'm upset now"
            return 1
        else
            el_debug "Umounted (forced): $@"
            el_warning "well, finally umounted"
            # special dir created by this own tool, we don't need it anymore
            for dir in  /mnt/*_elive
            do
                if ! check_is_mounted "$dir" 1>/dev/null ; then
                    rmdir "$dir"
                fi
            done

            return 0
        fi
    done
}
#===  FUNCTION  ================================================================
#          NAME:  el_mount
#   DESCRIPTION:  overwrite layer for a real mount feature
#    PARAMETERS:  $1 = device
#       RETURNS:  true if success, false if not
#===============================================================================
el_mount(){
    # pre {{{
    local dev uuid
    el_security_function_loop 10 || return

    dev="$1"
    shift

    el_check_variables "dev"

    sync

    # }}}

    if [[ "$dev" != "/dev/"* ]] || [[ ! -b "$dev" ]] ; then
        el_error "Argument passed to $FUNCNAME is not a device: $dev"
        return 1
    fi

    # try to mount
    if [[ "$EL_DEBUG" -ge 3 ]] ; then
        timeout 60 udisks --mount "$dev" "$@"
    else
        timeout 60 udisks --mount "$dev" "$@" 1>/dev/null
    fi

    # check if mounted
    sync
    if check_is_mounted "$dev" 2>/dev/null 1>&2 ; then
        echo "$dev mounted in: $(get_mountpoint "$dev" )"
        return 0
    fi


    # re-read partition table and try again
    sync
    /sbin/sfdisk -R "${dev%%[0-9]*}" 2>/dev/null || true
    sync

    # try to mount
    if [[ "$EL_DEBUG" -ge 3 ]] ; then
        timeout 60 udisks --mount "$dev" "$@"
    else
        timeout 60 udisks --mount "$dev" "$@" 1>/dev/null
    fi

    # check if mounted
    sync
    if check_is_mounted "$dev" 2>/dev/null 1>&2 ; then
        echo "$dev mounted in: $(get_mountpoint "$dev" ), after to re-read partition table"
        return 0
    fi


    # try again
    #sync
    #el_sudo service dbus restart
    #sync
    #/sbin/sfdisk -R "${dev%%[0-9]*}" 2>/dev/null || true
    #sync

    ## try to mount
    #if [[ "$EL_DEBUG" -ge 3 ]] ; then
        #timeout 60 udisks --mount "$dev" "$@"
    #else
        #timeout 60 udisks --mount "$dev" "$@" 1>/dev/null
    #fi

    ## check if mounted
    #sync
    #if check_is_mounted "$dev" 2>/dev/null 1>&2 ; then
        #echo "$dev mounted in: $(get_mountpoint "$dev" ), after to: restart dbus + re-read"
        #return 0
    #fi


    # try again
    sync
    el_sudo service udev restart
    #sync
    #el_sudo service dbus restart
    sync
    /sbin/sfdisk -R "${dev%%[0-9]*}" 2>/dev/null || true
    sync

    # try to mount
    if [[ "$EL_DEBUG" -ge 3 ]] ; then
        timeout 60 udisks --mount "$dev" "$@"
    else
        timeout 60 udisks --mount "$dev" "$@" 1>/dev/null
    fi

    # check if mounted
    sync
    if check_is_mounted "$dev" 2>/dev/null 1>&2 ; then
        #echo "$dev mounted in: $(get_mountpoint "$dev" ), after to: restart udev + dbus + re-read"
        echo "$dev mounted in: $(get_mountpoint "$dev" ), after to: restart udev  + re-read"
        return 0
    fi


    # if root, try to mount it in any of the cases
    if [[ "$UID" = 0 ]] ; then
        sync ; sleep 1
        /sbin/sfdisk -R "${dev%%[0-9]*}" 2>/dev/null || true
        uuid="$( lsblk -nio UUID "$dev" )"
        target="/mnt/${uuid}_elive"
        mkdir -p "$target"

        if check_is_mounted "$target" 2>/dev/null 1>&2 ; then
            el_error "$target is already mounted, we cannot use it"
        fi

        mount "$dev" "$target"
        sync
        sleep 1
        sync
        if check_is_mounted "$dev" 2>/dev/null 1>&2 ; then
            echo "$dev mounted in: $(get_mountpoint "$dev" )"
            return 0
        else
            el_error "Unable to mount $dev"
            return 1
        fi
    else
        el_error "unable to mount $dev, try the same command from root"
    fi
}


main(){
    # pre {{{
    local arg

    # }}}
    # Usage
    if [[ -z "${1}" ]] ; then
        echo -e "Usage: $(basename $BASH_SOURCE) options:"
        echo -e "Basic partitions / mountpoins features:"
        echo -e "--get-mountpoint dev  : get the mountpoint of a device address"
        echo -e "--check-is-mounted [dev|mountpoint]  : returns true|false if the argument is mounted"
        echo -e "--mount dev [args]  : mount a device, args must be in udisks format:"
        echo -e "                    (--mount-fstype reiserX --mount-options foo,bar)"
        echo -e "--umount [dev|mountpoint]  : umounts a device|mountpoint"
        echo -e "--umount-force [dev|mountpoint]  : umounts a device|mountpoint in a forced mode, NEVER do this"
        echo -e ""
        echo -e "Chroots related:"
        echo -e "--chroot-layers-mount directory idname  : mount the layers needed for a full-working chroot (proc, sysfs, etc)"
        echo -e "--chroot-layers-umount directory [idname]  : umount the layers"
        exit 1
    fi

    # checks {{{
    if LC_ALL=C udisks --dump 2>&1 | grep -qs "Couldn't enumerate devices" ; then
        # restart daemons {{{
        if [[ "$UID" = 0 ]] ; then
            killall udisks-daemon 2>/dev/null || killall -9 udisks-daemon 2>/dev/null || true
            killall polkitd 2>/dev/null || killall -9 polkitd 2>/dev/null || true

            /usr/lib/udisks/udisks-daemon 2>/dev/null 1>&2 & disown
            /usr/lib/policykit-1/polkitd 2>/dev/null 1>&2 & disown
        else
            if el_check_sudo_automated ; then
                sudo killall udisks-daemon 2>/dev/null || killall -9 udisks-daemon 2>/dev/null || true
                sudo killall polkitd 2>/dev/null || killall -9 polkitd 2>/dev/null || true

                sudo /usr/lib/udisks/udisks-daemon 2>/dev/null 1>&2 & disown
                sudo /usr/lib/policykit-1/polkitd 2>/dev/null 1>&2 & disown
            else
                el_error "We need to restart some polkitd services, please run again this tool from root"
            fi
        fi

        sleep 1

        # - restart daemons }}}
        if LC_ALL=C udisks --dump 2>&1 | grep -qs "Couldn't enumerate devices" ; then
            el_array_member_add "Command 'udisks --dump' doesn't shows any valid info, perhaps a reboot may fix the problem?" "${errors_found[@]}" ; errors_found=("${_out[@]}")
        fi
    fi
    # - checks }}}

    case "$1" in
        --get-mountpoint)
            shift
            get_mountpoint "$@"
            ;;
        --check-is-mounted)
            shift
            check_is_mounted "$@"
            ;;
        --mount)
            shift
            el_mount "$@"
            ;;
        --umount)
            shift
            el_umount "$@"
            ;;
        --umount-force)
            shift
            is_forced=1
            el_umount "$@"
            ;;
        --chroot-layers-mount)
            shift
            chroot_layers_mount "$@"
            ;;
        --chroot-layers-umount)
            shift
            chroot_layers_umount "$@"
            ;;
    esac

    if [[ -n "$errors_found" ]] ; then
        el_request_report_bug "${errors_found[@]}"
    fi

}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
