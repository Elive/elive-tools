#!/bin/bash
SOURCE="$0"
source /usr/lib/elive-tools/functions
EL_REPORTS="1"
el_make_environment
#set -x
#set -v
#set -T

# TODO: alternative to bkp that should be faster, try git stage
# TODO: create a list of commits already-imported, so when we run again a same git-watcher, they should be skipped (and removed from the counter list) -- or at least list all the commits that we cherry-picked, if they are matched when we enter on them, show a warning message saying that we already cherry-picked it to FOO (mark this too)
# TODO: add el_package_*... like in the elive installer to check for newer version, note: the warning can be annoying if displayed multiple times

#===  FUNCTION  ================================================================
#          NAME:  exit_cleanups
#   DESCRIPTION:  delete temporal things when exit
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
exit_cleanups(){
    # pre {{{
    el_debug

    # }}}
    # do we need to recover our original position?
    travel_restore

    if ! [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
        rm -rf "$conf_repo_d"
    fi

    # tell us if we save
    if [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
        el_explain 0 "Session __saved__"
    else
        el_explain 0 "Session not saved"
    fi

    # share session always when exiting
    if ((is_shared)) ; then
        # store actual position for future calls of this tool
        if [[ "$commit_id" != "$( tail -1 "$shared_personal_d/last_commit_tracked" 2>/dev/null )" ]] ; then
            # store our commit-id
            echo "$commit_id" > "$shared_personal_d/last_commit_tracked"
            # store our progress
            echo -e "$counter $counter_total" > "$shared_personal_d/last_commit_tracked_progress"

            #echo "$counter $counter_total" > "$shared_personal_d/last_commit_tracked_progress"
            el_explain 0 "Share __saved__"
        fi

    else
        el_explain 0 "Session is not shared"
    fi

    # do we had another branch outside git-watcher? restore it
    if [[ -n "$branch_working_prev" ]] ; then
        command git checkout "$branch_working_prev"
    fi
}

el_add_on_exit exit_cleanups

#===  FUNCTION  ================================================================
#          NAME:  shared_accounts_state_show
#   DESCRIPTION:  scan and show status of other accounts
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
shared_accounts_state_show(){
    # pre {{{
    el_debug

    local _user _dir _email
    # }}}

    # loop for each user found
    if ((is_shared)) ; then
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "  ${el_c_gr}${el_c_blink}Scanning paralel dimensions...${el_c_n}"

        for _dir in "$shared_d"/*
        do
            _user="$( basename "$_dir" )"
            _email="$( cat "$_dir/email.txt" )"
            _commit_id="$( cat "$_dir/last_commit_tracked" )"
            _commits_step="$( cat "$_dir/last_commit_tracked_progress" | awk '{print $1}' )"
            _commits_total="$( cat "$_dir/last_commit_tracked_progress" | awk '{print $2}' )"

            # skip our own user
            # TODO: re-enable after to finish tests
            #if [[ "${git_email}" = "$_email" ]] ; then
                #continue
            #fi

            # header nice image
            if [[ -n "$TERMINOLOGY" ]] ; then
                if [[ -s "$_dir/gravatar.png" ]] ; then
                    tycat "$_dir"/gravatar.png
                fi
            fi

            echo -e "..:: $_user ::.."
            #echo -e ""
            echo -e "email:   $_email"
            echo -e "step:    ${el_c_n}[${el_c_g}${_commits_step}${el_c_n}/${el_c_y}${_commits_total}${el_c_n}]${el_c_n}  (${_commit_id:0:12})"


            # only if we are not ourselves
            if [[ "${git_email}" != "$_email" ]] ; then
                # anything to work later?
                if [[ "$_commits_total" -gt "$_commits_total_biggest" ]] ; then
                    _commits_total_biggest="$_commits_total"
                    _commits_total_biggest_user="$_user"
                fi

                if [[ "$_commits_step" -gt "$_commits_step_biggest" ]] ; then
                    _commits_step_biggest="$_commits_step"
                    _commits_step_biggest_user="$_user"
                    _commit_id_biggest="$_commit_id"
                fi

                # show available time-traveling capsules
                if el_check_dir_has_files "${_dir}/ttc/to_${git_username}/review" 2>/dev/null ; then
                    _ttc_counter="$( ls -1 "${_dir}/ttc/to_${git_username}/review" | wc -l )"
                    el_explain 0 "__${_user}__ has __${_ttc_counter}__ XXTime-Traveling CapsulesXX for you!"
                fi

                if el_check_dir_has_files "${_dir}/ttc/to_${git_username}/questions" 2>/dev/null ; then
                    _ttc_counter="$( ls -1 "${_dir}/ttc/to_${git_username}/questions" | wc -l )"
                    el_explain 0 "__${_user}__ has __${_ttc_counter}__ XXQuestionsXX in Capsules for you!"
                fi

            fi

            # done
            echo -e ""
        done
    fi

    # compare and update if needed
    if [[ "$_commits_total_biggest" -gt "$counter_total" ]] ; then
        el_explain 0 "Seems like __${_commits_total_biggest_user}__ is using an updated repo than yours"
        if el_confirm "Update your git repo now? (git pull --rebase)" ; then

            # which remote to fetch from?
            if [[ -z "$remote_fetching_working" ]] ; then
                if [[ "$( command git remote -v | grep "(fetch)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
                    echo -e "\nWhich remote ID you want to track the changes on '$branch_working' from? (empty cancels)\n"
                    command git remote -v | grep "(fetch)" | sed -e 's|(fetch).*$||g' | column -t | awk '{$1 = "(id: "$1") "; print $0}'

                    read -e remote_fetching_working
                else
                    remote_fetching_working="$(command git remote -v | grep "(fetch)" | awk '{print $1}' | head -1 )"
                fi

                echo "$remote_fetching_working" > "$conf_remote_fetch_working_from_f"
            fi

            # pull remote
            #command git pull --rebase "$remote_fetching_working" "$branch_working" # don't use this method, leads to diverged branches
            command git pull --rebase "$remote_fetching_working" "+${branch_working}:refs/remotes/${remote_fetching_working}/${branch_working}"

            check_if_has_diverged

            # update total of commits
            do_count_commits
            is_recount_position_needed=1

            _is_shared_scanned=1
        fi
    fi

    # walk steps?
    if [[ "$_commits_step_biggest" -gt "$counter" ]] ; then
        el_explain 0 "Seems like __${_commits_step_biggest_user}__ is ahead of you in steps"

        if el_confirm "Join its commit-id position?" ; then
            commit_id="$_commit_id_biggest"

            # update total of commits
            do_count_commits
            is_recount_position_needed=1

            _is_shared_scanned=1
        fi
    fi


    if ((_is_shared_scanned)) ; then
        el_explain 0 "Finished to scan paralel worlds, press Enter to continue..."
        read nothing
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  shared_messages_create
#   DESCRIPTION:  elaborate messages to send to other users
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
shared_messages_create(){
    # pre {{{
    el_debug
    local _message_option _mark_message _entity

    # }}}

    # Select a user where to send message:
    el_explain 0 "Other carbon-based life forms:"
    echo -en "${el_c_g}"

    if [[ -z "$shared_d" ]] ; then
        # if we are not running on shared session, just insert an email
        echo -e "\n${el_c_g}Type a destination email:${el_c_n}"
        read _entity_email

    else
        if [[ "$( ls -1 "${shared_d}" | grep -v "$git_username" | wc -l )" -gt 1 ]] ; then
            ls -1 "${shared_d}" | grep -v "$git_username"
            echo -en "${el_c_n}"

            echo -e "\nType an entity:"
            read _entity
        else
            _entity="$( ls -1 "${shared_d}" | grep -v "$git_username" | tail -1 )"
            el_explain 0 "Messaging to the XX${_entity}XX carbon-based life form"
        fi

        if ! [[ -d "${shared_d}/$_entity" ]] ; then
            el_error "Carbon-based life form doesn't exist, are you in the correct planet?"
            echo -e "\nType an entity:"
            read _entity

            if ! [[ -d "${shared_d}/$_entity" ]] ; then
                return
            fi
        fi

        # get email of entity
        _entity_email="$( cat "${shared_d}/${_entity}/email.txt" | grep "@" )"
    fi

    if ! echo "$_entity_email" | grep -qs "$_entity_email" ; then
        el_error "$_entity has not a valid email?: $_entity_email"
    fi


    # message type?
    option_show "a" "Ask a question to ${_entity} (no importing required)"
    option_show "i" "Importing request to backport this commit"
    ###option_show "r" "Reply a question"
    option_show "q" "quit this menu"

    read -N 1 _message_option

    # message?
    echo -e "\nMessage to include?  (blank = no message)"
    read -e _mark_message

    # get the remote working repo url to include in the email {{{
    if [[ -z "$remote_working" ]] ; then
        if [[ "$( command git remote -v | grep "(push)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
            echo -e "\nWhich one is the remote repo where you normally push your work that is shared with your collaborators?\n"
            command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | column -t | awk '{$1 = "(id: "$1") "; print $0}'

            echo -e "\nInsert remote repo:"
            read -e remote_working

            # translate remote-id to url, which is what we need
            if command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | awk '{print $1}' | grep -qs "^$remote_working" ; then
                remote_working="$( command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | grep "^$remote_working" | head -1 | awk '{$1 = ""; print $0}' )"
                # remove extra leading blank chars
                read -r remote_working <<< "$remote_working"
            fi


            # small check, just in case
            if ! echo "$remote_working" | grep -qsE "(@|:|/)" ; then
                el_error "Have you inserted the identifier instead of the remote URL? mmh... do it again:"
                read -e remote_working
            fi
        else
            remote_working="$( command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | head -1 | awk '{$1 = ""; print $0}' )"
        fi

        #echo "$remote_working" > "$conf_remote_work_from_f"
    fi
    # }}}

    # send email and set specific values
    case "$_message_option" in
        a|A)
            _message_option="questions"

            el_explain 0 "Sending email..."

            email-sender -t "$_entity_email" -s "$git_username has a question for you" -S "<i style=\"color: #FC61B3;\">${git_username}</i> wants to ask you:" <<EOF
<p><strong>
$_mark_message
</strong></p>

To know more you need to take a <i>Time-Traveling Capsule</i> to join its universe, for that:

<ul>
<li>cd into your git copy of: '${remote_working}' <i>(${git_username} has it at: ${working_directory_d//#//})</i></li>
<li>copy and run the command: $  <strong>$(basename $0) -w ${branch_working} ${tool_arguments} -g ${commit_id}</strong></li>
</ul>
EOF

            ;;
        i|I)
            _message_option="review"

            el_explain 0 "Sending email..."

            email-sender -t "$_entity_email" -s "$git_username wants to know if we should backport a commit" -S "<i style=\"color: #FC61B3;\">${git_username}</i> wants you to consider backporting this commit into ${branch_working}" <<EOF
<p><strong>
$_mark_message
</strong></p>

To take your <i>Time-Traveling Capsule</i> you should:

<ul>
<li>cd into your git copy of: '${remote_working}' <i>(${working_directory_d//#//})</i></li>
<li>copy and run the command: $  <strong>$(basename $0) -w ${branch_working} $tool_arguments -g ${commit_id}</strong></li>
</ul>

Or without the -g option you can just read your capsules in any moment
EOF
            ;;
        q|Q)
            return
            ;;
        *)
            el_error "Unknown message type option, canceling"
            return
            ;;
    esac

    # create shared marks
    if ((is_shared)) ; then
        mkdir -p "${shared_personal_d}/ttc/to_$_entity/$_message_option/${commit_id}"

        if [[ -n "$_mark_message" ]] ; then
            echo "${git_username}: $_mark_message" >> "${shared_personal_d}/ttc/to_$_entity/$_message_option/${commit_id}/message.txt"
        fi

        # mark position too
        echo -e "[$counter/$counter_total] " >> "${shared_personal_d}/ttc/to_$_entity/$_message_option/${commit_id}/position.txt"
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  check_if_has_diverged
#   DESCRIPTION:  simple checker about if the branch has diverged
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
check_if_has_diverged(){
    if command git status | grep -iqs "your branch.*have diverged" ; then
        echo -e "" 1>&2
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        el_explain 0 "XXWarning: your branch has divergedXX"
        el_explain 0 "You should check your git history and status XXmanuallyXX, exit from this tool and do it by yourself"
        el_explain 0 "This can probably happen if only a __branch was updated__ without all of them, a good solution to try is to pull from the entire remote, like for example: __git pull --rebase origin__"
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "" 1>&2
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  scan_travels
#   DESCRIPTION:  Scans available travels and allow to pick them
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
scan_travels(){
    # pre {{{
    el_debug
    if ! ((is_shared)) ; then
        el_explain 0 "Skipping scan for capsules, this watcher is not shared"
        return
    fi


    local _user _dir _email
    # }}}

    # loop for each user found
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    echo -e "  ${el_c_gr}${el_c_blink}Scanning Time-Traveling Capsules...${el_c_n}"

    for _dir in "$shared_d"/*
    do
        _user="$( basename "$_dir" )"
        _email="$( cat "$_dir/email.txt" )"
        _commit_id="$( cat "$_dir/last_commit_tracked" )"
        _commits_step="$( cat "$_dir/last_commit_tracked_progress" | awk '{print $1}' )"
        _commits_total="$( cat "$_dir/last_commit_tracked_progress" | awk '{print $2}' )"

        # skip our own user
        if [[ "${git_email}" = "$_email" ]] ; then
            continue
        fi

        # show available time-traveling capsules
        if el_check_dir_has_files "${_dir}/ttc/to_${git_username}/review" 2>/dev/null ; then
            _ttc_review=1
        fi

        if el_check_dir_has_files "${_dir}/ttc/to_${git_username}/questions" 2>/dev/null ; then
            _ttc_question=1
        fi


        # show info of only needed ones
        if ((_ttc_review)) || ((_ttc_question)) ; then
            # header nice image
            if [[ -n "$TERMINOLOGY" ]] ; then
                if [[ -s "$_dir/gravatar.png" ]] ; then
                    tycat "$_dir"/gravatar.png
                fi
            fi

            echo -e "..:: $_user ::.."
            #echo -e ""
            echo -e "email:   $_email"
            echo -e "step:    ${el_c_n}[${el_c_g}${_commits_step}${el_c_n}/${el_c_y}${_commits_total}${el_c_n}]${el_c_n}  (${_commit_id:0:12})"
        fi

        if ((_ttc_review)) ; then
            _ttc_counter="$( ls -1 "${_dir}/ttc/to_${git_username}/review" | wc -l )"
            #el_explain 0 "XX${_user}XX wants you to consider backporting XX${_ttc_counter}XX __commits__:"
            el_explain 0 "XX${el_c_underline}${_ttc_counter} Backporting requestsXX:"

            while read -ru 3 dir
            do
                [[ -d "$dir" ]] || continue

                _has_capsules=1
                _ttc_id_last="$( basename "$dir" )"

                echo -e "${el_c_b}ID:       ${el_c_g}${_ttc_id_last}${el_c_n}"

                if [[ -s "$dir/position.txt" ]] ; then
                    echo -en "${el_c_b}Position: ${el_c_y}"
                    cat "$dir/position.txt" 2>/dev/null
                fi
                if [[ -s "$dir/message.txt" ]] ; then
                    echo -e "${el_c_b}Message:  ${el_c_m2}"
                    cat "$dir/message.txt" 2>/dev/null
                fi
                echo -e "${el_c_n}"

            done 3<<< "$( find "${_dir}/ttc/to_${git_username}/review" -mindepth 1 -maxdepth 1 -type d )"
        fi

        if ((_ttc_question)) ; then
            _ttc_counter="$( ls -1 "${_dir}/ttc/to_${git_username}/questions" | wc -l )"
            #el_explain 0 "XX${_user}XX wants you to ask you XX${_ttc_counter}XX things about specific commits:"
            el_explain 0 "XX${el_c_underline}${_ttc_counter} QuestionsXX:"

            while read -ru 3 dir
            do
                [[ -d "$dir" ]] || continue

                _has_capsules=1
                _ttc_id_last="$( basename "$dir" )"

                echo -e "${el_c_b}ID:       ${el_c_g}${_ttc_id_last}${el_c_n}"

                if [[ -s "$dir/position.txt" ]] ; then
                    echo -en "${el_c_b}Position: ${el_c_y}"
                    cat "$dir/position.txt" 2>/dev/null
                fi
                if [[ -s "$dir/message.txt" ]] ; then
                    echo -e "${el_c_b}Message:  ${el_c_m2}"
                    cat "$dir/message.txt" 2>/dev/null
                fi
                echo -e "${el_c_n}"

            done 3<<< "$( find "${_dir}/ttc/to_${git_username}/questions" -mindepth 1 -maxdepth 1 -type d )"
        fi


        # done
        echo -e ""
    done

    # finished
    if ((_has_capsules)) ; then
        # fast way to read messages if only one
        if [[ "${_ttc_counter}" = "1" ]] && [[ -n "$_ttc_id_last" ]] ; then
            # only one question? directly go to it
            el_explain 0 "Let's __travel__ to $_ttc_id_last"

            go_to_commit "$_ttc_id_last"
        else
            go_to_commit
        fi
    else
        el_explain 0 "No messages for you"
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  scan_marked_states
#   DESCRIPTION:  Scans and show marked states like todo's
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
scan_marked_states(){
    # pre {{{
    el_debug

    # }}}
    if ! el_check_dir_has_files "${conf_repo_d}/ttc" 2>/dev/null ; then
        return
    fi

    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    el_explain 0 "You have XXNew MessagesXX"


    while read -ru 3 dir
    do
        [[ -d "$dir" ]] || continue

        echo -e "${el_c_b}ID:       ${el_c_g}$(basename "$dir" )${el_c_n}"

        if [[ -s "$dir/message.txt" ]] ; then
            echo -en "${el_c_b}Message:  ${el_c_m2}"
            cat "$dir/message.txt" 2>/dev/null
            echo -e "${el_c_n}"
        fi

        el_explain 0 "You can travel to its __ID__ on the __g__ option"
        el_explain 0 "If you need external help you can go to it and send a message to somebody"

        if el_confirm "Delete it?" ; then
            rm -rf "$dir"
        fi


    done 3<<< "$( find "${conf_repo_d}/ttc/" -mindepth 1 -maxdepth 1 -type d )"


    #echo -e "Press Enter to continue..."
    #LC_ALL=C sleep 0.8
    #read nothing

}

#===  FUNCTION  ================================================================
#          NAME:  conf_share_setup
#   DESCRIPTION:  configure shares if not configured yet
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
conf_share_setup(){
    # pre {{{
    local arg
    el_debug

    # }}}
    # TODO: implementation:
    # - run an inotify in BG that prints el_explain's everytime founds a modification of X files, + read nada
    # - send email summarized to collaborators when we finish & save a session
    # - mark "points" to ask collaborators to review them, a message must be included, and options should be shown as resolved/unnaccepted, etc... which reverse notification
    # -
    #
    # TODO: show marks / messages, reviews, etc...
    # TODO: marks:
    #       - later / todo
    #       - review (accept / approve)
    #       - ask/suggest a cherry-pick
    #       - message to @who
    #       - positions (marks of commits should move you [temporally] to the marked position)


    # TODO: INBOX: show by default message to "you"



    # setup new shared conf
    if ! [[ -L "$conf_repo_d/shared" ]] ; then
        if el_confirm "Enable sharing features?" ; then
            # let's cowork!
            run_dropbox

            # dropbox shared dir
            local _dropbox_dir
            if [[ -z "$shared_main_d" ]] ; then
                _dropbox_dir="$( find-approximate-matching-homedir dropbox )"
                if [[ -e "$_dropbox_dir" ]] ; then
                    _dropbox_dir="$_dropbox_dir/git-watcher-eworks"
                else
                    _dropbox_dir="$HOME/Dropbox/git-watcher-eworks"
                fi
            else
                _dropbox_dir="$shared_main_d"
            fi

            echo -e "\nTo be synced with others we use Dropbox, insert the path of your main shared dropbox directory\nfor example: $_dropbox_dir (TAB to autocomplete)"
            read -e shared_main_d
            # remove extra leading blank chars
            read -r shared_main_d <<< "${shared_main_d%/}"


            # check it
            if [[ -d "$shared_main_d" ]] ; then
                mkdir -p "$shared_main_d"
                # add a small readme file
                echo -e "This directory is used for share git-watcher projects, do not delete it, EVER! :) so it is used automagically by git-watcher tool, you don't need to do anything with it, but you can manually modify things if you know what are you doing!, there's no manual pages so use your intuition powers!" > "$shared_main_d/README.txt"

                # save this conf as default
                echo "$shared_main_d" > "$conf_d/shared_main_default_dir.txt"
            fi

            # remote working place, needed for use as an identifier in the shares
            if [[ -z "$remote_working" ]] ; then
                if [[ "$( command git remote -v | grep "(push)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
                    echo -e "\nWhich one is the remote repo where you normally push your work that is shared with your collaborators?\n"
                    command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | column -t | awk '{$1 = "(id: "$1") "; print $0}'

                    echo -e "\nInsert remote repo:"
                    read -e remote_working

                    # translate remote-id to url, which is what we need
                    if command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | awk '{print $1}' | grep -qs "^$remote_working" ; then
                        remote_working="$( command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | grep "^$remote_working" | head -1 | awk '{$1 = ""; print $0}' )"
                        # remove extra leading blank chars
                        read -r remote_working <<< "$remote_working"
                    fi


                    # small check, just in case
                    if ! echo "$remote_working" | grep -qsE "(@|:|/)" ; then
                        el_error "Have you inserted the identifier instead of the remote URL? mmh... do it again:"
                        read -e remote_working
                    fi
                else
                    remote_working="$( command git remote -v | grep "(push)" | sed -e 's|(push).*$||g' | head -1 | awk '{$1 = ""; print $0}' )"
                fi

                echo "$remote_working" > "$conf_remote_work_from_f"
            fi

            # send invitations (+ instructions) via email
            echo -e "\nGive me a list of emails (comma-separated) to send invitations to this watcher with the needed instructions (can be empty):"
            read _emails_invitations
            _emails_invitations="$( echo "$_emails_invitations" | tr ',' ' ' | tr ';' ' ' | tr ' ' '\n' )"
            while read -ru 3 _email
            do
                [[ -z "$_email" ]] && continue

                el_explain 0 "Sending email to __${_email}__"

                email-sender -t "$_email" -s "$git_username wants to share a $(basename $0) with you" -S "These are the needed instructions to join the watcher:" <<EOF
This could be one of the most amazing tools that you may have never see!

First you need to accept the dropbox directory shared with you (you should have an invitation in your email)

After, go to your git repository that references to <i>'${remote_working}'</i>, and run from it:

<ul>$ <strong>$(basename $0) $tool_arguments</strong></ul>

After to have it loaded, exit from $(basename $0) and select the options:
<li>Save the session</li>
<li>Enable Share features</li>
<li>Fill up the correct sharing information</li>

Now just run <strong>$(basename $0) $tool_arguments</strong> again to start using it in shared mode!

EOF

            done 3<<< "$( echo "$_emails_invitations" | grep "@" )"


            # create location for this repository identifier
            if ! [[ -d "$shared_main_d/$remote_working/$repo_id_shared" ]] ; then
                mkdir -p "$shared_main_d/$remote_working/$repo_id_shared"
                el_explain 2 "created watcher reference in __$shared_main_d/$remote_working/${repo_id_shared}__"

                # invite friends! (on this step because we are the first ones to use this share, dir not existed before)
                if el_confirm "You need to invite collaborators from Dropbox too to use this directory, open Dropbox Web now?" ; then
                    { /etc/alternatives/x-www-browser "https://www.dropbox.com/home" & disown ; } 1>/dev/null 2>&1
                fi
            fi

            ln -s "$shared_main_d/$remote_working/$repo_id_shared" "$conf_repo_d/shared"
            el_explain 2 "linked shared location on __$conf_repo_d/shared__"


            shared_d="$conf_repo_d/shared"
            shared_personal_d="$shared_d/$git_username"
            mkdir -p "$shared_personal_d"

            echo "$git_email" > "$shared_personal_d/email.txt" # and this is how we expect to be contacted
            el_explain 2 "added your email reference in __$shared_personal_d/email.txt"

            # save gravatar too, w00t!
            curl -s "http://www.gravatar.com/avatar/"$( echo -n "$git_email" | awk '{print tolower($0)}' | tr -d '\n ' | md5sum --text | tr -d '\- ' )"?s=48&d=404" > "$shared_personal_d/gravatar.png"
            if ! file "$shared_personal_d/gravatar.png" | grep -qsi "image" ; then
                rm -f "$shared_personal_d/gravatar.png"
            fi



            # sync our changes
            run_dropbox

            # done
            el_explain 0 "You are now ready to work with others on this shared watcher! __enjoy__"
            el_explain 0 "The next time that you will work on this watcher, your collaborators will be __notified__ and you __can walk__ on their steps"
            el_explain 0 "Remote collaborators: just go to their git repo clone and run __$(basename $0) ${tool_arguments}__, then exit saving session and sharing"

            # save shared confs at exit
            is_shared=1

        else
            # we don't want to share, remember that
            touch "$conf_repo_d/no-shared"
        fi
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  run_dropbox
#   DESCRIPTION:  run the dropbox daemon
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
run_dropbox(){
    # pre {{{
    el_debug

    el_dependencies_check "dropbox"

    # }}}
    if ! ps ux | grep -v grep | grep -qs "$HOME/\.dropbox-dist/" ; then
        el_explain 0 "Starting dropbox..."
        dropbox start -i  2>/dev/null 1>&2
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  go_to_commit
#   DESCRIPTION:  go to a commit position, and returns back on the normal history when finished
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
go_to_commit(){
    # pre {{{
    el_debug
    # }}}
    # FIXME: if we have a capsule, print it

    # save our real position
    _commit_id="$commit_id"

    # ask for ID if we are not requesting it directly
    if [[ -n "$1" ]] ; then
        commit_id="$1"
    else
        echo -e "Insert the ID to travel"
        read -e commit_id
    fi

    # check if space-time position exists
    if ! command git rev-parse "$commit_id" 1>/dev/null 2>&1 ; then
        el_error "This ID don't exist?"

        echo -e "Insert the commit-ID to go on"
        read -e commit_id

        if ! command git rev-parse "$commit_id" 1>/dev/null 2>&1 ; then

            el_error "Commit-id not found. Perhaps you need to update your repo first?"
            LC_ALL=C sleep 0.4

            el_explain 0 "restoring original ID..."
            # something went wrong so make sure the user read this rare-case moment
            sleep 1
            commit_id="$_commit_id"
            unset is_traveling

            return
        fi
    fi

    # we got an ID, so we are in
    is_traveling=1

    tycat "/usr/share/git-watcher/images/ttc.gif"

    # mark our new position
    echo "$commit_id" > "$conf_commit_last_f"

    # count our new position
    do_count_commits

    # shared things here? {{{
    for dir in "${shared_d}/"*"/ttc/to_${git_username}/questions"/*
    do
        [[ -d "$dir" ]] || continue

        _ttc_id="$( basename "$dir" )"
        _ttc_id_user="$( echo "$dir" | sed -e "s|^.*$shared_d/||g" -e "s|/ttc/.*$||" )"
        _ttc_id_user_email="$( cat "$shared_d/$_ttc_id_user/email.txt" )"

        if [[ "$commit_id" = "$_ttc_id" ]] ; then
            echo ""
            el_explain 0 "You have a question here:"

            echo -en "${el_c_m2}"
            cat "$dir/message.txt"
            echo -en "${el_c_n}"

            echo -e "Reply to $_ttc_id_user ? (empty for cancel)"
            read _mark_message

            if [[ -n "$_mark_message" ]] ; then
                mkdir -p "${shared_personal_d}/ttc/to_$_ttc_id_user/questions/${commit_id}"

                el_explain 0 "Sending email..."

                email-sender -t "$_ttc_id_user_email" -s "$git_username has answered you" -S "<i style=\"color: #FC61B3;\">${git_username}</i> thinks that:" <<EOF
<p><strong>
$_mark_message
</strong></p>
From your question about:
<ul>
$(cat "$dir/message.txt")
</ul>

To know more you need to take a <i>Time-Traveling Capsule</i> to join its universe, for that:

<ul>
<li>cd into your git copy of: '${remote_working}' <i>(${git_username} has it at: ${working_directory_d//#//})</i></li>
<li>copy and run the command:$  <strong>$(basename $0) -w ${branch_working} $tool_arguments -g ${commit_id}</strong></li>
</ul>
EOF


                cat "$dir/message.txt" >> "${shared_personal_d}/ttc/to_$_ttc_id_user/questions/${commit_id}/message.txt"
                echo "${git_username}: $_mark_message" >> "${shared_personal_d}/ttc/to_$_ttc_id_user/questions/${commit_id}/message.txt"

                rm -rf "$dir"
            else
                if el_confirm "Delete ${_ttc_id_user}'s question-type capsule?" ; then
                    rm -rf "$dir"
                fi
            fi
        fi
    done
    # requests to deal with?
    for dir in "${shared_d}/"*"/ttc/to_${git_username}/review"/*
    do
        [[ -d "$dir" ]] || continue

        _ttc_id="$( basename "$dir" )"
        _ttc_id_user="$( echo "$dir" | sed -e "s|^.*$shared_d/||g" -e "s|/ttc/.*$||" )"

        if [[ "$commit_id" = "$_ttc_id" ]] ; then
            if el_confirm "Delete ${_ttc_id_user}'s backport-type capsule?" ; then
                rm -rf "$dir"
            fi
        fi
    done


    # - shared things here? }}}

    # and so, what you want to do now?
    options_main_interact

    # restore our original position
    travel_restore

}

#===  FUNCTION  ================================================================
#          NAME:  travel_restore
#   DESCRIPTION:  restores a possible traveled position
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
travel_restore(){
    # pre {{{
    el_debug

    # we should not be here
    if ! ((is_traveling)) ; then
        return
    fi

    if ! [[ -n "$_commit_id" ]] ; then
        el_error "You have not a location of origin in your passport for traveling? (prev commit-id)"
    fi

    # }}}

    tycat "/usr/share/git-watcher/images/ttc.gif"
    el_explain 0 "Restoring time-traveling position!"

    # marks: delete
    if [[ -d "${conf_repo_d}/ttc/${commit_id}" ]] ; then

        if el_confirm "Delete marked state?" ; then
            if el_check_variables "conf_repo_d|commit_id" ; then

                rm -rf "${conf_repo_d}/ttc/${commit_id}"
                el_debug "deleted mark: '${conf_repo_d}/ttc/${commit_id}'"
            else
                el_error "Very fatal error, report it, we were going to rm -rf something wrong but this super smart application avoided it!"
            fi
        fi
    fi

    # Questions to deal with?
    # should create a new question with the previous question pre-pended? sounds like the easiest way
    for dir in "${shared_d}/"*"/ttc/to_${git_username}/questions"/*
    do
        [[ -d "$dir" ]] || continue

        _ttc_id="$( basename "$dir" )"
        _ttc_id_user="$( echo "$dir" | sed -e "s|^.*$shared_d/||g" -e "s|/ttc/.*$||g" )"
        _ttc_id_user_email="$( cat "$shared_d/$_ttc_id_user/email.txt" )"

        if [[ "$commit_id" = "$_ttc_id" ]] ; then
            echo ""
            el_explain 0 "You have a pending message:"

            echo -en "${el_c_m2}"
            cat "$dir/message.txt"
            echo -en "${el_c_n}"

            echo -e "Reply to $_ttc_id_user ? (empty for cancel)"
            read _mark_message

            if [[ -n "$_mark_message" ]] ; then
                mkdir -p "${shared_personal_d}/ttc/to_$_ttc_id_user/questions/${commit_id}"

                el_explain 0 "Sending email..."

                email-sender -t "$_ttc_id_user_email" -s "$git_username has answered you" -S "<i style=\"color: #FC61B3;\">${git_username}</i> thinks that:" <<EOF
<p><strong>
$_mark_message
</strong></p>
From your question about:
<ul>
$(cat "$dir/message.txt")
</ul>

To know more you need to take a <i>Time-Traveling Capsule</i> to join its universe, for that:

<ul>
<li>cd into your git copy of: '${remote_working}' <i>(${git_username} has it at: ${working_directory_d//#//})</i></li>
<li>copy and run the command: $  <strong>$(basename $0) -w ${branch_working} $tool_arguments -g ${commit_id}</strong></li>
</ul>
EOF


                cat "$dir/message.txt" >> "${shared_personal_d}/ttc/to_$_ttc_id_user/questions/${commit_id}/message.txt"
                echo "${git_username}: $_mark_message" >> "${shared_personal_d}/ttc/to_$_ttc_id_user/questions/${commit_id}/message.txt"

                rm -rf "$dir"
            else
                if el_confirm "Delete ${_ttc_id_user}'s question-type capsule?" ; then
                    rm -rf "$dir"
                fi
            fi
        fi
    done
    # requests to deal with?
    for dir in "${shared_d}/"*"/ttc/to_${git_username}/review"/*
    do
        [[ -d "$dir" ]] || continue

        _ttc_id="$( basename "$dir" )"
        _ttc_id_user="$( echo "$dir" | sed -e "s|^.*$shared_d/||g" -e "s|/ttc/.*$||" )"

        if [[ "$commit_id" = "$_ttc_id" ]] ; then
            if el_confirm "Delete ${_ttc_id_user}'s backport-type capsule?" ; then
                rm -rf "$dir"
            fi
        fi
    done


    # we are back! let's restore
    commit_id="$_commit_id"

    # count our new position
    do_count_commits
    is_recount_position_needed=1

    # mark our back position
    echo "$commit_id" > "$conf_commit_last_f"

    unset is_traveling
}
#===  FUNCTION  ================================================================
#          NAME:  show_history
#   DESCRIPTION:  show last history if any
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
show_history(){
    # pre {{{
    el_debug
    local lines

    # }}}
    el_explain 0 "History:"

    lines="$( LC_ALL=C command git status | grep "ahead.*by.*commits" | sed -e 's|^.* by ||g' -e 's| commits.*$||g' )"

    if [[ -n "$lines" ]] ; then
        lines="$(( $lines + 1 ))"
        el_explain 0 "Your __not pushed__ changes:"


        command git log --graph --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(bold white)%an%C(reset) %C(white)— %s%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative -$lines
    else
        el_explain 0 "Recent history in your working branch:"
        command git --no-pager log --graph --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(bold white)%an%C(reset) %C(white)— %s%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative -12
        # seems like we miss a newline:
        echo

    fi
}

#===  FUNCTION  ================================================================
#          NAME:  show_states
#   DESCRIPTION:  shows our actual snapshoted states list available
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
show_states(){
    # pre {{{
    local _branch_working _keyword_search _files_search is_header_show _progress _commits_total _commits_remaining _commits_done _author_search _dir_sources

    el_check_variables "conf_d"
    el_check_dirs "$conf_d"
    # - pre }}}

    while read -ru 3 line
    do
        if [[ -d "$conf_d/$line" ]] ; then
            if ! ((is_header_show)) ; then
                #echo -e "Watchers:"
                #echo '---------'

                echo -e "${el_c_b}Watchers Tracking:${el_c_n}"
                echo -e "on Branch: | only Keyword: | on Files: | Authored by: | Progress:"
                echo -e "|"

                is_header_show=1
            fi

            el_debug "entry is $line"

            _dir_sources="$(    echo "$line" | awk -F "::" '{print $1}' )"
            _branch_working="$( echo "$line" | awk -F "::" '{print $2}' )"
            _keyword_search="$( echo "$line" | awk -F "::" '{print $3}' )"
            _files_search="$(   echo "$line" | awk -F "::" '{print $4}' | sed -e 's|#|/|g' )"
            _author_search="$(  echo "$line" | awk -F "::" '{print $5}' )"

            #_commits_total="$( echo "$( cat "$conf_d/$line/last_commit_tracked_progress" 2>/dev/null | awk '{print $2}' )" )"
            # FIXME: is not remaining but actual progress?
            _commits_remaining="$( echo "$( cat "$conf_d/$line/last_commit_tracked_progress" 2>/dev/null | tr ' ' '/'  )" )"
            #_commits_done="$( echo "$_commits_total - $_commits_remaining" | bc -l 2>/dev/null )"

            #if [[ -n "$_commits_done" ]] ; then
                #_progress="$( echo "${_commits_done}/${_commits_remaining}" )"
            #fi


            if [[ "$_branch_working" = "$branch_working" ]] \
                && [[ "$_keyword_search" = "$keyword_search" ]] \
                && [[ "$_files_search" = "$files_search" ]] \
                && [[ "$_author_search" = "$author_search" ]] ; then
                echo -e "${el_c_g}$_branch_working | $_keyword_search | $_files_search | $_author_search | $_commits_remaining  ${el_c_y}${el_c_n}"
            else

                if [[ -n "$_branch_working" ]] ; then

                    echo -e "$_branch_working | $_keyword_search | $_files_search | $_author_search | $_commits_remaining "

                fi
            fi


            unset _branch_working _keyword_search _files_search _author_search _commits_remaining _commits_total _progress
        fi
    done 3<<< "$( ls -1 "$conf_d" )"  | column -s $'|' -t
    # append space
    echo '' 1>&2

    # end
    echo '' 1>&2
}

#===  FUNCTION  ================================================================
#          NAME:  show_commit_stat
#   DESCRIPTION:  show the actual commit stat, good to "remember" where you are
#    PARAMETERS:  $1 = pre-git options
#       RETURNS:  -
#===============================================================================
show_commit_stat(){
    # pre {{{
    el_debug
    local pre_git_options

    el_check_variables "commit_id"
    pre_git_options="$1"

    # }}}
    # show actual position
    #echo -e "${el_c_y} [$counter/$counter_total] ${el_c_g} Position in remaining commits  ${el_c_n}"
    #echo -e "${el_c_y}[$counter/$counter_total] ${el_c_n}"

    # show actual commit-id
    if [[ -n "$keyword_search" ]] ; then
        # hilight the keyword to search
        command git $pre_git_options show --stat "$commit_id" | grep --color -Ei "^|$keyword_search|"
    else
        command git $pre_git_options show --stat "$commit_id"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  clear_screen
#   DESCRIPTION:  clears the screen
#    PARAMETERS:  $1 = default | interactive
#       RETURNS:  -
#===============================================================================
clear_screen(){
    # pre {{{
    local mode
    el_debug

    mode="$1"
    el_check_variables "mode"

    #if [[ "$counter" -gt "$counter_total" ]] || [[ "$counter" -le 0 ]] ; then
        #el_debug "not clearing the screen"
        #echo -e "\n\n"
        #return
    #fi

    # }}}
    case "$mode" in
        default)
            true
            ;;
        interactive)
            echo -e "\nPress Enter to continue..." 1>&2
            read nothing
            ;;
    esac

    if [[ "${EL_DEBUG}" -lt "3" ]] ; then
        # clear is not enough, if you scroll back you can see old things, reset is too slow, so let's put some huge separator instead
        echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

        clear
    else
        echo -e "\n\n\n\n\n\n\n"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  do_count_commits
#   DESCRIPTION:  counter of total commits to track
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
do_count_commits(){
    # pre {{{
    el_debug

    local _counter _counter_total _is_commit_id_last_reached

    el_check_variables "branch_working|branch_watch"

    unset _is_commit_id_last_reached
    _counter_total="$counter_total"
    _counter="$counter"

    counter_total=0
    counter=1

    # }}}
    # pre-statistics a bit: show the amount of commits between branches
    while read -ru 3 line
    do
        # get commit line
        if [[ "$line" = "commit "* ]] ; then

            counter_total="$(( $counter_total + 1 ))"

            # skip until last commit
            if [[ -n "$commit_id" ]] && ! ((_is_commit_id_last_reached)) ; then
                if [[ "$line" = "commit "$commit_id ]] ; then
                    _is_commit_id_last_reached=1
                else
                    # loop until we reach the desired commit
                    counter="$(( $counter + 1 ))"
                fi
            fi

            #echo -en "\r${el_c_b}Calculating total commits and our position: \t${el_c_y}[$counter/$counter_total]   ${el_c_n}"
            echo -en "\r${el_c_b}Computing space time coordinates: \t${el_c_y}[$counter/$counter_total]   ${el_c_n}"
        fi

    done 3<<< "$( command git log ${options_extra_git_before[@]} --reverse "$branch_working".."$branch_watch" ${options_extra_git_after[@]} )"
    echo ""


    # do we have found new commits?
    if [[ -n "$_counter_total" ]] ; then
        if ! [[ "$(( $counter_total - $_counter_total ))" = 0 ]] ; then
            el_explain 0 "Nice! XX$(( $counter_total - $_counter_total ))XX New commits found on this watcher!"
            echo "Press Enter to continue"
            read nothing
        fi
    fi

    if [[ "${counter}" -gt "${counter_total}" ]] ; then
        # show this on the counter tab instead, because this commit is out of our tracking line,
        # we will go back later so nothing to worry about
        counter="0"
    fi


    el_explain 3 "Recounted commits: counter is $counter, total commits is $counter_total"
}

#===  FUNCTION  ================================================================
#          NAME:  do_cherry_pick_menu
#   DESCRIPTION:  menu of options in cherry-pick state, useful when it fails
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
do_cherry_pick_menu(){
    # pre {{{
    el_debug

    # }}}

    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
    option_show "s" "Show status"
    option_show "d" "Show actual diff"
    option_show "n" "Abort / Next commit"
    option_show "m" "mergetool (auto / smart mode)"
    option_show "M" "mergetool (manual / human mode)"
    option_show "h" "mergetool config"
    option_show "l" "Login Shell (to do things manually)"
    option_show "c" "Continue operation (cherry-pick) in progress"
    option_show "f" "Finish - return to main menu even if uncomplete"
    echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

    read -N 1 option
    echo

    case "$option" in
        s)
            command git status

            $FUNCNAME
            ;;
        d)  # show patch
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            GIT_PAGER=cat command git diff --cached
            command git status
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            # return back to main menu
            $FUNCNAME

            ;;
        n|a) # shortcut to "a" too if we want to call it as "abort"
            command git cherry-pick --abort

            el_explain 0 "Aborted cherry-pick..."
            LC_ALL=C sleep 1.2

            ;;
        c)
            # TODO: improve this option, is not easy to find (far on the list, we need an option for "accepted merge" or similar, more intuitive)
            # TODO: check the options, we don't want to write a message probably, do we also want to use the option -x ?
            if command git cherry-pick --continue ; then
                # store actual position for future calls of this tool
                echo "$commit_id" > "$conf_commit_last_f"

                # make a list of the commits that we have already imported
                if ! grep -qs "^${commit_id}$" "${conf_imported_commits_list_f}" ; then
                    echo "$commit_id ${branch_working}" >> "$conf_imported_commits_list_f"
                    if ((is_shared)) ; then
                        echo "$commit_id ${branch_working}" >> "${conf_imported_commits_list_shared_f}"
                    fi
                fi

                # return to the main menu since we continued successfully
                true
            else
                $FUNCNAME
            fi
            ;;
        m)
            # FIXME: my confs has been updated for BUSTER, this code needs to be updated and we need to add a detector of conf, that we will also add an auto conf creator for it (and so ignoring the 'h)' option)
            # TODO: add an explanation of what is for each tab, you can found this info in my .gitconfig file
            if grep -qs "mergetool.*meld-auto" "$HOME/.gitconfig" ; then
                command git mergetool -t meld-auto
                # mergetool can success or not, so ask again what to do
            else
                el_error "meld-auto conf for mergetool not found in your config, use the option 'h' first"
            fi
            $FUNCNAME
            ;;

        M)
            if grep -qs "mergetool.*meld-manual" "$HOME/.gitconfig" ; then
                command git mergetool -t meld-manual
                # mergetool can success or not, so ask again what to do
            else
                el_error "meld-auto conf for mergetool not found in your config, use the option 'h' first"
            fi
            # mergetool can success or not, so ask again what to do
            $FUNCNAME
            ;;

        h)
            el_explain 0 "Unfortunately there's no way to run specific git mergetools without touch the confs, so first, add these lines to your .gitconfig:"
            cat <<'EOF'
[merge]
# by default let's use meld-auto, if you need manual use "git mergetool -t meld-manual"
tool = meld-auto
conflictstyle = diff3
[mergetool "meld-auto"]
# cmd reference to the meld version 1.6 syntax1
cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $BASE $REMOTE $MERGED
;# howto use the meld on this way: http://blog.wuwon.id.au/2010/09/painless-merge-conflict-resolution-in.html
;# so you have in the first tab the differences between the base and the local work, in the second the base with the remote work, and in the last tab you have in the middle the state where you need to resolve and save the conflicts
;# TIP: in meld run ^F for search the (??) expression, which is the conflict marks, and ^G for search the next one
[mergetool "meld-manual"]
cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $MERGED $REMOTE

[mergetool "meld17"]
# use this for Meld >=1.7
# see http://stackoverflow.com/a/22911793/859591
# second solution:
cmd = meld $LOCAL $MERGED $REMOTE
# first solution:
#cmd = meld $LOCAL $BASE $REMOTE --auto-merge
# see entries for 1.7 in the old commented code
[mergetool "meld16"]
# this one not works very good, at least on wheezy's version of meld
;cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $BASE $REMOTE --output $MERGED
# old/previous
cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $BASE $REMOTE $MERGED
;cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --diff $LOCAL $MERGED $REMOTE
# another attempt?
#cmd = meld $LOCAL $BASE $REMOTE -o $MERGED --diff $BASE $LOCAL --diff $BASE $REMOTE
EOF

            echo -e "\nPress Enter to continue..." 1>&2
            read nothing

            # return to menu
            $FUNCNAME

            ;;
        l)
            el_explain 0 "Starting a login shell, use ^d or logout when you finish to return back here"

            $SHELL -l

            $FUNCNAME
            ;;
        f)
            true
            ;;
    esac

    # remove unwanted .orig files remaining
    if command git status -su | grep -e"\.orig$" ; then
        command git status -su | grep -e"\.orig$" | cut -f2 -d" " | xargs rm -f 2>/dev/null
    fi

}
#===  FUNCTION  ================================================================
#          NAME:  do_cherry_pick
#   DESCRIPTION:    run a cherry-pick to the commit_id variable, run helpers if something fails
#===============================================================================
do_cherry_pick(){
    # pre {{{
    el_debug

    # }}}

    el_explain 0 "git cherry-pick -Xpatience -x -s '$commit_id'"
    if command git cherry-pick -Xpatience -x -s "$commit_id" ; then
        command git --no-pager show
        el_explain 0 "__Successfully applied!__"
        #el_explain 0 "If you need to __add related__ commits in more cherry-picks, use the list-nearest feature and give the commits in a list to the multiple-cherry-pick feature"

        #echo -e "Press Enter to continue"
        #read nothing
        #sleep 1

        # store actual position for future calls of this tool
        echo "$commit_id" > "$conf_commit_last_f"

        # make a list of the commits that we have already imported
        if ! grep -qs "^${commit_id}$" "${conf_imported_commits_list_f}" ; then
            echo "$commit_id ${branch_working}" >> "$conf_imported_commits_list_f"
            if ((is_shared)) ; then
                echo "$commit_id ${branch_working}" >> "${conf_imported_commits_list_shared_f}"
            fi
        fi

        el_debug "stored '$commit_id' to '$conf_commit_last_f'"
    else
        el_error "Oops, cherry-pick failed! select an option now:"

        do_cherry_pick_menu
    fi

    show_history

}

#===  FUNCTION  ================================================================
#          NAME:  do_cherry_pick_multiple
#   DESCRIPTION:  do cherry-picking of multiple commits
#    PARAMETERS:  $1 = comma-separated list of commit-ids to cherry-pick
#       RETURNS:  -
#===============================================================================
do_cherry_pick_multiple(){
    # pre {{{
    local commits
    el_debug

    commits="$1"
    commits="${commits//,/ }"

    # }}}

    if [[ -n "$commits" ]] ; then
        el_explain 0 "command git cherry-pick -x -s $commits"

        if command git cherry-pick -x -s $commits  ; then
            el_explain 0 "__Successfully applied!__  Hit return to continue"
            read nothing
        else
            el_error "Oops, cherry-pick failed! select an option now:"

            do_cherry_pick_menu
        fi

        show_history
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  option_show
#   DESCRIPTION:  show an option to pick in a nice-colored way
#    PARAMETERS:  $1 = char, $2 = description
#       RETURNS:  -
#===============================================================================
option_show(){
    # pre {{{
    local char
    local description

    char="$1"
    description="$2"
    el_check_variables "char|description"

    # }}}

    echo -e "${el_c_c} ${char}  ${el_c_g}${description}${el_c_n}"

}

#===  FUNCTION  ================================================================
#          NAME:  options_main_interact
#   DESCRIPTION:
#    PARAMETERS:  -
#       RETURNS:  -
#===============================================================================
options_main_interact(){
    # pre {{{
    el_debug
    local _counter_show

    if ((is_recount_position_needed)) ; then
        return
    fi
    # }}}
    if [[ "${counter}" = "0" ]] ; then
        _counter_show="out of this universe"
    else
        _counter_show="$counter"
    fi

    echo -e ""
    #echo -e "${el_c_y} [$counter/$counter_total] ${el_c_g} Position in remaining commits  ${el_c_n}"
    if ((is_traveling)) ; then
        echo -e "${el_c_b}------------------------------------${el_c_gr}(${el_c_m}parallel reality${el_c_gr})${el_c_b}----${el_c_y}[${el_c_g}$_counter_show${el_c_y}/$counter_total]${el_c_b}-----${el_c_n}"
    else
        echo -e "${el_c_b}-----------------------------------------------------${el_c_y}[$_counter_show/$counter_total]${el_c_b}-----${el_c_n}"
    fi
    echo -e "${el_c_y}   OPTIONS: ${el_c_n}"
    #option_show "h"         "Help: how this tool works" # TODO add
    option_show "r"         "Read Capsules"
    option_show "n"         "Next commit"
    option_show "p"         "Prev commit"
    option_show "s"         "Show commit summary"
    option_show "S"         "Show detailed info"
    option_show "h"         "Show history"
    option_show "d"         "Show diff"
    option_show "a"         "list Around commits (from our working thread)"
    option_show "A"         "list Around commits (from the watching branch)"
    option_show "i"         "Import this commit (cherry-pick)"
    option_show "I"         "Import other or multiple commits (cherry-pick)"
    option_show "e"         "Edit the files affected by this commit (good to read all code)"
    option_show "m"         "mark, adds a mark on this position, to review later"
    option_show "M"         "Message, questions and requests to others"
    option_show "g"         "Go to commit id (space-time travel)"
    option_show "G"         "Go to a counter position"
    option_show "u"         "Update working branch (pull --rebase)"
    option_show "U"         "Update watching branch (pull --rebase)"

    if [[ -n "$user_input_backport_branches" ]] ; then
        option_show "b"         " > Backport to: $user_input_backport_branches"
    else
        option_show "b"         "Backport it to another branches too (set them as comma-separated)"
    fi
    option_show "z"         "Undo last commit in your working branch"
    option_show "c"         "compile (make), useful for check if new code is compatible"
    option_show "C"         "use your own Command to run (ex: make && sudo make install && enlightenment_remote -restart)"
    ## not needed: we moved it to C
    #if [[ -n "$user_input_command" ]] ; then
        #option_show "r"     " > Run:  $user_input_command"
    #fi
    option_show "l"         "Login Shell (to do things manually)"
    option_show "B/R"       "Backup / Restore directory state (bkp tool)" # bkp is the best option for not mess up things, can be slow but it has also incrememental saving states too
    option_show "q"         "Quit"
    option_show "Q"         "Quit!"
    echo -e "${el_c_b}================================================================${el_c_n}"

    if grep -qs "^${commit_id}" "$conf_imported_commits_list_f" "${conf_imported_commits_list_shared_f}"  2>/dev/null ; then
        echo -e ""
        el_explain 0 "XXNoteXX: this commit was __already imported__, to the branch __$(grep "^$commit_id" "${conf_imported_commits_list_f}" "${conf_imported_commits_list_shared_f}" 2>/dev/null | tail -1 | awk '{print $2}' )__"
        echo -e ""
    fi

    check_if_has_diverged

    # select an option {{{
    #read -N 1 option

    # alternative to previous "read", this option makes possible to skip multichars entries tripling the loop for when you use inputs like "up arrow", it basically cleans the input to a single entry and accepts only alpha/numeric values
    local _c _d
    while read -N 1 _c
    do
        while read -t 0
        do read -N1 _d
            _c+=$_d
        done
        option="$( printf "%q" "$_c" | grep --color=never -E "^[[:alnum:]]$" )"
        break
    done

    el_debug "option picked is: '$option'"
    echo

    # }}}

    case "$option" in
        r)  # read messages / capsules
            scan_travels

            # go back to main menu
            $FUNCNAME

            ;;

        n)  # Next commit
            #el_explain 0 "Saving last commit watched"
            return

            ;;
        p)  # Prev commit
            # FIXME: we can go BACKWARDS 0 and -1 -2 -3... make a check in the main "while true" loop for not be able to go before the first commit
            # FIXME: (in E's git we have a bkp saved that includes only one commit about the XDG issue, not 2 ones, we need to "bkp g" to this state in order to reproduce this problem)
                # so there is, go to that state and use the option "U" to update the watching branch, it founds 1 new commit, but then it should show that we are in the commit 11/13 (if we was in 11/12 previously) but instead it tells us that we are in 14/13, wrong!!!!
                # FIXME 2: there's also another problem: when updating with the option "U" it doesn't include the force-update that we did, and it shows a "branch diversion" message, we need to HILIGHT it and warn the user, requesting him to investigate the issue, which should be probably fixed with a simple "git pull --rebase REMOTE" (not-including the branch seems like to accept the force-update)

            if ((is_traveling)) ; then
                # so we return from who called it, which is go_to_commit
                return
            fi

            # get the previous commit id
            commit_id="$( command git log ${options_extra_git_before[@]} --reverse "$branch_working".."$branch_watch" ${options_extra_git_after[@]} | grep "^commit" | grep -B 1 "$commit_id" | awk '{print $2}' | head -1 )"

            # mark our new position
            echo "$commit_id" > "$conf_commit_last_f"
            el_debug "stored '$commit_id' to '$conf_commit_last_f'"

            # set the counter to count another commit remaining
            counter="$(( $counter - 1 ))"

            # exit loop if no remaining commits
            if [[ "$counter" -le 0 ]] ; then
                el_explain 0 "You cannot go before the creation of the universe!"
                sleep 3
            fi

            # cleanup
            clear_screen default

            # go back to positioning loop
            is_recount_position_needed=1
            return


            ;;
        g)  # go to commit id
            go_to_commit

            # go back to main menu
            $FUNCNAME

            ;;
        G)  # go to a jumping mode commit

            echo -e "\n${el_c_g}Type a number of the counter to jump:${el_c_n}"
            read -e _n

            if echo "$_n" | grep -v "[[:alpha:]]" | grep -qs "[[:digit:]]" ; then

                commit_id="$( command git log ${options_extra_git_before[@]} --reverse "$branch_working".."$branch_watch" $options_extra_git_after | grep "^commit " | head -n "$_n" | awk '{print $2}' | tail -1 )"

                # mark our new position
                echo "$commit_id" > "$conf_commit_last_f"
                el_debug "stored '$commit_id' to '$conf_commit_last_f'"

                # count to the actual jump
                counter="$_n"
                # always remove one, because we return
                counter="$(( $counter + -1 ))"

                # exit loop if no remaining commits
                if [[ "$counter" -le 0 ]] ; then
                    el_explain 0 "You cannot go before the creation of the universe!"
                    sleep 3
                fi

                # cleanup
                clear_screen default

                # go back to positioning loop
                is_recount_position_needed=1
                return
            else
                el_error "You need to insert a numeric value in the range of the watching commits"
                sleep 2
                $FUNCNAME
            fi


            ;;
        u)  # update working branch

            # which remote to fetch from?
            if [[ -z "$remote_fetching_working" ]] ; then
                if [[ "$( command git remote -v | grep "(fetch)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
                    echo -e "\nWhich remote ID you want to track the changes on '$branch_working' from? (empty cancels)\n"
                    command git remote -v | grep "(fetch)" | sed -e 's|(fetch).*$||g' | column -t | awk '{$1 = "(id: "$1") "; print $0}'

                    read -e remote_fetching_working
                else
                    remote_fetching_working="$(command git remote -v | grep "(fetch)" | awk '{print $1}' | head -1 )"
                fi

                echo "$remote_fetching_working" > "$conf_remote_fetch_working_from_f"
            fi

            #el_explain 0 "git pull --rebase $remote_fetching_working $branch_working"
            el_explain 0 "git pull --rebase \"$remote_fetching_working\" \"+${branch_working}:refs/remotes/${remote_fetching_working}/${branch_working}\""
            #command git pull --rebase "$remote_fetching_working" "$branch_working"  # don't use this method, leads to diverged branches
            command git pull --rebase "$remote_fetching_working" "+${branch_working}:refs/remotes/${remote_fetching_working}/${branch_working}"
            check_if_has_diverged

            # update total of commits
            do_count_commits
            is_recount_position_needed=1

            # return back to main menu
            $FUNCNAME

            ;;
        U)  # update watching branch

            # which remote to fetch from?
            if [[ -z "$remote_fetching_watch" ]] ; then
                if [[ "$( command git remote -v | grep "(fetch)" | awk '{print $1}' | wc -l )" -gt 1 ]] ; then
                    echo -e "\nWhich remote ID you want to track the changes on '$branch_watch' from ?\n"
                    #command git remote -v | grep "(fetch)" | awk '{print $1}'
                    command git remote -v | grep "(fetch)" | sed -e 's|(fetch).*$||g' | column -t | awk '{$1 = "(id: "$1") "; print $0}'

                    read -e remote_fetching_watch
                else
                    remote_fetching_watch="$(command git remote -v | grep "(fetch)" | awk '{print $1}' | head -1 )"
                fi

                echo "$remote_fetching_watch" > "$conf_remote_fetch_watch_from_f"
            fi


            el_explain 0 "git checkout $branch_watch"
            command git checkout "$branch_watch"

            #el_explain 0 "git pull --rebase $remote_fetching_watch $branch_watch"
            el_explain 0 "git pull --rebase \"$remote_fetching_watch\" \"+${branch_watch}:refs/remotes/${remote_fetching_watch}/${branch_watch}\""
            #command git pull --rebase "$remote_fetching_watch" "$branch_watch"  # buggy method
            command git pull --rebase "$remote_fetching_watch" "+${branch_watch}:refs/remotes/${remote_fetching_watch}/${branch_watch}"
            check_if_has_diverged

            # go back to our working one
            el_explain 0 "git checkout $branch_working"
            command git checkout "$branch_working"
            check_if_has_diverged


            # update total of commits
            do_count_commits
            is_recount_position_needed=1

            # return back to main menu
            $FUNCNAME

            ;;
        s)  # show info
            # show actual commit-id
            show_commit_stat


            # return back to main menu
            $FUNCNAME
            ;;
        S)  # show detailed info
            echo -e "\n\n\n\n\n\n\n\n\n\n\n"
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # show history
            show_history
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # show status
            el_explain 0 "Status:"
            command git status

            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # show actual commit-id
            show_commit_stat

            # return back to main menu
            $FUNCNAME
            ;;

        h)  #history
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # show history
            show_history
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            # return back to main menu
            $FUNCNAME

            ;;
        d)  # show patch
            clear_screen default
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            command git --no-pager show "$commit_id" | lsdiff
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            command git show "$commit_id"
            # return back to main menu
            $FUNCNAME

            ;;
        e)  # edit files
            # TODO: enter in the specific lines if vim
            if [[ -z "$EDITOR" ]] ; then
                echo -e "Set the editor (command) that you want to use"
                read -e EDITOR
            fi

            # edit files
            $EDITOR $(git --no-pager show "$commit_id" | lsdiff | sed -e 's|^a/||g' -e 's|^b/||g' | tr '\n' ' ' )


            # show back the diff, we always want to see it again
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"
            command git --no-pager show "$commit_id" | lsdiff
            echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

            command git --no-pager show "$commit_id"

            # return back to main menu
            $FUNCNAME

            ;;
        i)  # cherry-pick
            do_cherry_pick

            # separator
            echo -e "\n\n"

            # go to next commit
            return
            ;;

        I)  # cherry-pick

            # first:  list around nearest
            el_explain 0 "(commits from oldest to newest)"
            command git log --oneline --abbrev=12 ${options_extra_git_before[@]} "$branch_working".."$branch_watch" ${options_extra_git_after[@]} | tac | grep --color -C 6 "${commit_id:0:12}"

            el_explain 0 "Give a list of spaces-separated commits to cherry-pick in earlier-order"
            el_explain 0 "Use the 'listing-nearest' feature to show more commits. Empty value will skip the action"

            read _commits

            do_cherry_pick_multiple "$_commits"

            # show the last commit, to make sure that we know where we are
            show_commit_stat --no-pager

            # return back to main menu
            $FUNCNAME

            ;;
        m)
            el_explain 0 "TODO / mark added"

            echo -e "\nMessage to include?  (blank = no message)"
            read -e _mark_message

            # create mark
            mkdir -p "${conf_repo_d}/ttc/${commit_id}"

            if [[ -n "$_mark_message" ]] ; then
                echo "$_mark_message" >> "${conf_repo_d}/ttc/${commit_id}/message.txt"
            fi

            # return back to main menu
            $FUNCNAME

            ;;
        M)

            # create messages for other users
            shared_messages_create

            # return back to main menu
            $FUNCNAME

            ;;
        b)  # extra branches where to backport
            if [[ -z "$user_input_backport_branches" ]] ; then
                echo -e "Set the name of the branches which you want to backport too, ex. enlightenment-0.18"
                read -e user_input_backport_branches
            fi

            if [[ -n "$user_input_backport_branches" ]] ; then

                while read -ru 3 branch
                do
                    command git checkout "$branch"
                    do_cherry_pick
                    command git checkout "$branch_working"

                done 3<<< "$( echo "$user_input_backport_branches" | tr ',' '\n' )"
            fi

            # return back to main menu
            $FUNCNAME
            ;;
        z)  # undo

            # show our actual commit
            show_history
            echo ""

            if el_confirm "Do you want to permanently remove the last commit?" ; then
                el_explain 0 "$ git reset --hard HEAD~1"
                command git reset --hard HEAD~1
                # delete it from the list of the ones we have imported too
                sed -i "s|$commit_id ${branch_working}||g" "$conf_imported_commits_list_f"
                sed -i "s|${commit_id}.*$||g" "$conf_imported_commits_list_shared_f"
                sed -i "/^$/d" "$conf_imported_commits_list_f"
                sed -i "/^$/d" "$conf_imported_commits_list_shared_f"
            fi

            # return back to main menu
            $FUNCNAME
            ;;
        c)  # make
            if make ; then
                el_explain 0 "__Compiled Correctly__"
            else
                el_explain 0 "XXCompilation FailedXX"
            fi


            #el_speak_text "make complete"
            # return back to main menu
            $FUNCNAME
            ;;
        C)  # command specific
            if [[ -z "$user_input_command" ]] ; then
                echo -e "\nEnter the command that you want to use:"
                echo -e "Example:  make && sudo make install && enlightenment_remote -restart"
                read -e user_input_command
            fi

            if [[ -n "$user_input_command" ]] ; then
                if ! bash -c "$user_input_command" ; then
                    el_speak_text "error, compilation failed"
                else
                    el_speak_text "compilation finished successfully"
                fi
            fi

            # return back to main menu
            $FUNCNAME
            ;;
        a)  #  list around nearest
            el_explain 0 "nearest commits to your actual position in our working branch:"

            el_explain 2 "command git log --oneline --abbrev=12 --graph --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(bold white)%an%C(reset) %C(white)— %s%C(reset)%C(bold yellow)%d%C(reset)' ${options_extra_git_before[@]} \"$branch_working\"..\"$branch_watch\" ${options_extra_git_after[@]} | grep --color -C 20 \"${commit_id:0:12}\""
            command git log --oneline --abbrev=12 --graph --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(bold white)%an%C(reset) %C(white)— %s%C(reset)%C(bold yellow)%d%C(reset)' ${options_extra_git_before[@]} "$branch_working".."$branch_watch" ${options_extra_git_after[@]} | grep --color -C 20 "${commit_id:0:12}"

            el_explain 0 "list showed from newest to oldest"


            # return back to main menu
            $FUNCNAME
            ;;
        A)  # list Around nearest commits full
            el_explain 0 "nearest commits to your actual position in the watching branch history:"

            el_explain 2 "command git log --oneline --abbrev=12 --graph --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(bold white)%an%C(reset) %C(white)— %s%C(reset)%C(bold yellow)%d%C(reset)' ${options_extra_git_before[@]} \"$branch_watch\" | grep --color -C 20 \"${commit_id:0:12}\""

            command git log --oneline --abbrev=12 --graph --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(bold white)%an%C(reset) %C(white)— %s%C(reset)%C(bold yellow)%d%C(reset)' ${options_extra_git_before[@]} "$branch_watch" | grep --color -C 20 "${commit_id:0:12}"

            el_explain 0 "list showed from newest to oldest"

            # return back to main menu
            $FUNCNAME
            ;;
        l)  # shell
            el_explain 0 "Starting a login shell, use ^d or logout when you finish to return back here"

            $SHELL -l

            # return back to main menu
            $FUNCNAME

            ;;
        B)  # bkp
            bkp save

            # return back to main menu
            $FUNCNAME
            ;;
        R)  # bkp
            bkp get

            # return back to main menu
            $FUNCNAME
            ;;
        q)  # quit

            # ask if save
            if ! [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
                if el_confirm "Do you want to save this session?" ; then
                    # add a mark to know that this is a persistent watcher to save
                    touch "$conf_repo_d/flags/persistent_watcher"

                    # save some needed info
                    echo "$branch_working" > "$conf_branch_working_f"
                fi
            fi

            # ask if share, only if we are saving session
            if [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
                if ! [[ -L "$conf_repo_d/shared" ]] && ! [[ -e "$conf_repo_d/no-shared" ]] ; then
                    # ask and conf about sharing session
                    conf_share_setup
                fi
            fi

            exit

            ;;
        Q)
            exit
            ;;


        # LAST option
        *)
            # return back to main menu because you picked a wrong option accidentally
            echo -e "wrong option?"
            sleep 1
            $FUNCNAME
            ;;
    esac
}
#===  FUNCTION  ================================================================
#          NAME:  usage_show
#===============================================================================
usage_show(){
    echo ""
    echo -e "$(basename $0) is a tool to watch what recently happened to a git repository and gives you some handy features like cherry-picking." 1>&2

    echo -e "Important notes: " 1>&2
    echo -e " - you must be in the branch where you want to apply the work" 1>&2
    echo -e " - watching states will be saved and shareable among remotes, check the .$(basename $0) dir" 1>&2
    echo -e " - the last-commit ID is memorized, based on the directory-name/working-branch/keyword name" 1>&2

    echo -e ""
    echo -e "Options:"
    option_show "-b" "Branch that you want to track changes"
    option_show "-w" "Branch working from (forced checkout on it)"
    option_show "-k" "Keyword to search in the commit descriptions, listing only these ones, ex: 'fix'"
    option_show "-a" "Author (committer) of commits to search, useful for track changes from somebody (name/email, one word)"
    option_show "-f" "Files/dirs which to track changes only, comma-separated, ex: 'src/bin/e_border.c,src/bin/e_win.c'"
    echo -e ""
    option_show "-g" "Go to commit-id (temporally)"


    echo -e ""
    echo -e "Example of a new watcher: $(basename $0) -b master -k fix" 1>&2
    echo -e "To delete an existing watcher just remove the dir reference in .git-watcher" 1>&2

    echo -e ""

    show_states
}

main(){
    # version of this tool
    tool_version="1.4"
    tool_arguments="$@"
    # pre {{{

    # get the working branch name
    branch_working="$( command git symbolic-ref HEAD )"
    branch_working="${branch_working#refs/heads/}"

    if [[ -z "$branch_working" ]] ; then
        el_error "You are not in a git repository, this tool is meant to be used from a git repo"
        exit 1
    fi


    # }}}
    # input parameters {{{

    while getopts "b:w:k:a:f:g:" opt ; do
        case "$opt" in
            b)
                branch_watch="$OPTARG"
                ;;
            w)
                branch_working="$OPTARG"
                ;;
            k)
                keyword_search="$OPTARG"
                #options_extra_git_before="-i --grep $keyword_search $options_extra_git_before"
                #el_array_member_add "-i --grep $keyword_search" "${options_extra_git_before[@]}" ; options_extra_git_before=("${_out[@]}")
                el_array_member_add "-i -E --grep $keyword_search" "${options_extra_git_before[@]}" ; options_extra_git_before=("${_out[@]}")
                ;;
            a)
                # better to be case-insensitive
                author_search="$OPTARG"
                # more than one word don't works in our getargs, so just use one
                if echo "$author_search" | grep -qs "\ " ; then
                    el_explain 0 "XXWarningXX: there's a space included in your author's name, you can use its email instead which is a single word, continuing using: __${author_search%% *}__"
                fi
                author_search="${author_search%% *}"
                #options_extra_git_before="--committer='$author_search' $options_extra_git_before"
                el_array_member_add "-i --committer $author_search" "${options_extra_git_before[@]}" ; options_extra_git_before=("${_out[@]}")
                ;;
            f)
                files_search="$OPTARG"
                # cleanups {{{
                while read -ru 3 line
                do
                    if [[ -d "$line" ]] ; then
                        # append a / at the end of the entry, force it to not have wrongly duplicated sessions
                        _files_search="${_files_search},${line%/}/"
                    else
                        _files_search="${_files_search},${line}"
                    fi

                done 3<<< "$( echo "$files_search" | tr ',' '\n' )"

                files_search="${_files_search#,}"
                el_debug "$files_search"

                # }}}
                #options_extra_git_after="$options_extra_git_after -- ${files_search//,/ }"
                el_array_member_add "-- ${files_search//,/ }" "${options_extra_git_after[@]}" ; options_extra_git_after=("${_out[@]}")
                ;;
            g)
                travel_commit_id="$OPTARG"
                is_travel_wanted=1
                ;;
            \?|*)
                echo ""
                #echo "Invalid option" 1>&2
                usage_show
                exit
                ;;
            :)
                echo ""
                #echo "Option -$OPTARG requires an argument" 1>&2
                usage_show
                exit
                ;;
        esac
    done

    # - input parameters }}}
    # configurations saved {{{
    conf_d="$HOME/.config/$(basename $0)"

    # compatibility replacements
    files_search_regexed="$( echo "$files_search" | sed -e 's|/|#|g' )"

    # checks {{{

    if ! el_check_dirs "$conf_d" 2>/dev/null ; then
        mkdir -p "$conf_d"
    fi

    if el_check_variables "branch_working|branch_watch" 2>/dev/null ; then
        el_explain 0 "Branch tracking from: __${branch_watch}__"
        el_explain 0 "Branch to work on:    __${branch_working}__"
        if [[ "${branch_watch}" = "${branch_working}" ]] ; then
            el_explain 0 "XXWarning:XX Branch tracking is the same as where you are working on, you may not see any commit because you are comparing the same thing"
        fi
    else
        usage_show
        exit
    fi

    # check if we have checkoutable the watching branch too
    # update: we may not need to checkoutable, just access (like when a branch is just fetched)
    if ! command git branch -va | awk '{print $1}' | grep -v "remotes/" | grep -qs "$branch_watch" ; then
        #el_explain 0 "Pre-checking out: __${branch_watch}__"
        #command git checkout "${branch_watch}"
        #command git checkout "${branch_working}"
        if ! [[ -s ".git/refs/remotes/$branch_watch" ]] ; then
            el_error "Branch ${branch_watch} seems like to not have any data, you need to be able to checkout it or at least to have it fetched"
        fi

    fi
    # force checkout in the working branch
    if ! [[ "$( command git symbolic-ref HEAD | sed -e 's|refs/heads/||g' )" = "$branch_working" ]] ; then
        branch_working_prev="$( command git symbolic-ref HEAD | sed -e 's|refs/heads/||g' )"
        el_explain 0 "checking on: __${branch_working}__"
        command git checkout "${branch_working}"
    fi

    # }}}

    # append keyword in conf file if we have it
    working_directory_d="$( pwd | sed -e 's|/|#|g' )"
    repo_id="${working_directory_d}::${branch_watch}::${keyword_search}::${files_search_regexed}::${author_search}"
    repo_id_shared="${branch_watch}::${keyword_search}::${files_search_regexed}::${author_search}"
    conf_repo_d="${conf_d}/${repo_id}"

    mkdir -p "$conf_repo_d/flags"
    mkdir -p "$conf_repo_d/ttc"

    conf_commit_last_f="${conf_repo_d}/last_commit_tracked"
    conf_imported_commits_list_f="${conf_repo_d}/commits_imported_list"
    conf_commit_last_progress_f="${conf_repo_d}/last_commit_tracked_progress"
    conf_remote_fetch_working_from_f="${conf_repo_d}/remote_fetching_working_from"
    conf_remote_fetch_watch_from_f="${conf_repo_d}/remote_fetching_watch_from"
    conf_remote_work_from_f="${conf_repo_d}/remote_fetching_from"
    conf_branch_working_f="${conf_repo_d}/branch_working_for"
    tool_version_f="${conf_repo_d}/version_tool.txt"

    # - configurations saved }}}
    # version tool {{{
    el_check_variables "tool_version"
    tool_version_watcher="$( tail -1 "${conf_d}/version.txt" 2>/dev/null )" # old, for compatibility
    tool_version_watcher="$( tail -1 "$tool_version_f" 2>/dev/null )"

    # first time? add it
    if [[ -z "$tool_version_watcher" ]] ; then
        tool_version_watcher="$tool_version"
        echo "$tool_version" > "${tool_version_f}"
    fi

    # upgrade required
    if dpkg --compare-versions "$tool_version_watcher" gt "$tool_version" ; then
        el_package_update_last_version "elive-tools"
        el_error "Your $(basename $0) has been upgraded, run it again"

        exit
    fi

    # our tool is newer, manual upgrade required
    if dpkg --compare-versions "$tool_version_watcher" lt "$tool_version" ; then
        # prev conf dir:
        _conf_repo_d="${conf_repo_d}.old_v$tool_version_watcher"

        # do a backup for meld if wanted
        cp -a "${conf_repo_d}" "${_conf_repo_d}"
        el_explain 0 "XXWarning:XX your watcher confs needs to be upgraded, you can __manually__ merge later your old dir bits (first exit saving session) using meld as:  $  __meld \"${_conf_repo_d}\" \"${conf_repo_d}\"__"

        echo -e "\nPress Enter to continue..." 1>&2
        read nothing


        # migration upgrade cases (auto hooks): {{{
        while true
        do
            case "$tool_version_watcher" in
                1\.1)
                    # this version just needs to remove a file
                    el_explain 0 "Dummy / test upgrade state"
                    tool_version_watcher="1.2"
                    ;;
                1\.2)
                    # this version just needs to remove a file
                    set -x
                    rm -f "${conf_d}/version.txt"
                    rm -f "${conf_repo_d}/remote_fetching_from"
                    set +x

                    el_explain 0 "removed wrong files (you can safely continue)"
                    tool_version_watcher="1.3"
                    ;;
                1\.3)
                    # we moved to a different dir structure, pwd is needed on repo_id
                    el_explain 0 "entirely restructure was needed"

                    tool_version_watcher="1.3"
                    ;;
                *)
                    el_explain 0 "Nothing more to __automatically__ upgrade"
                    break
                    ;;
            esac
        done

        echo -e "\nPress Enter to continue..." 1>&2
        read nothing


        # }}}

        # update version number
        echo "$tool_version" > "$tool_version_f"
    fi


    # }}}
    # configurations get configurations {{{


    # last commit
    if [[ -s "$conf_commit_last_f" ]] ; then
        commit_id="$( tail -1 "$conf_commit_last_f" )"
    fi


    # remote fetching
    if [[ -s "$conf_remote_fetch_working_from_f" ]] ; then
        remote_fetching_working="$( tail -1 "$conf_remote_fetch_working_from_f" )"
    fi
    if [[ -s "$conf_remote_fetch_watch_from_f" ]] ; then
        remote_fetching_watch="$( tail -1 "$conf_remote_fetch_watch_from_f" )"
    fi
    # remote working
    if [[ -s "$conf_remote_work_from_f" ]] ; then
        remote_working="$( tail -1 "$conf_remote_work_from_f" )"
    fi


    # branch working
    if [[ -s "$conf_branch_working_f" ]] ; then
        _branch_working="$( tail -1 "$conf_branch_working_f" )"
        if [[ "$branch_working" != "$_branch_working" ]] ; then
            el_explain 0 "XXWarningXX: you have already a watcher like this, but your actual working branch is __${branch_working}__ and not __${_branch_working}__"
            if el_confirm "Want to switch to $_branch_working ?" ; then
                branch_working="${_branch_working}"
                command git checkout "$branch_working"
                check_if_has_diverged
            fi
        fi
    fi

    git_username="$( command git config user.name | tail -1 )"
    git_email="$( command git config user.email | tail -1 )"

    # do we are in a saved session?
    if [[ -e "$conf_repo_d/flags/persistent_watcher" ]] ; then
        is_session_saved=1
    fi

    # - configurations get }}}

    # get share configurations
    if [[ -s "$conf_d/shared_main_default_dir.txt" ]] ; then
        shared_main_d="$( cat "$conf_d/shared_main_default_dir.txt" )"
    fi

    if [[ -L "$conf_repo_d/shared" ]] ; then
        is_shared=1

        shared_d="$conf_repo_d/shared"
        shared_personal_d="$shared_d/$git_username"
        conf_imported_commits_list_shared_f="${shared_d}/commits_imported_list"

        # start the share daemon
        run_dropbox
    fi

    # get the total of commits list
    do_count_commits

    if ! ((is_travel_wanted)) ; then
        # scan your own to-do marks:
        scan_marked_states

        # scan if other users are ahead of you
        shared_accounts_state_show

        echo -e "${el_c_b}----------------------------------------------------------------${el_c_n}"

        # debug
        if [[ "${EL_DEBUG}" -ge "2" ]] ; then
            el_explain 2 "git log __${options_extra_git_before[@]} --reverse __${branch_working}__..__${branch_watch}__ __${options_extra_git_after}"
            #sleep 2
        fi

    fi

    # FIXME: the option showing "commits not pushed yet" not works well, the comparison is wrong? it doesnt point to the correct remote maybe?


    # loop
    while true
    do

        # loop!
        while read -ru 3 line
        do
            # nothing found at all, exiting
            if [[ "$counter" -gt "$counter_total" ]] || [[ "$counter" -le 0 ]] ; then
                is_recount_position_needed=1
                counter=1
            fi

            # get commit
            if [[ "$line" = "commit "* ]] ; then

                # recount our position against our commit-id
                if ((is_recount_position_needed)) ; then
                    #echo -en "\r${el_c_b}--- Traveling back in time: ${el_c_y}($counter/$counter_total)${el_c_b} ---${el_c_n}"
                    #el_debug "recounting position needed"
                    if [[ -n "$commit_id" ]] && [[ "$line" = "commit "$commit_id ]] ; then
                        is_commit_id_last_reached=1
                        unset is_recount_position_needed
                        #echo -e "" # append a newline because the counter entered on itself
                    else
                        # loop until we reach the desired commit
                        #el_debug "skipping commit because is not $commit_id : $line"
                        counter="$(( $counter + 1 ))"

                        continue
                    fi
                fi

                # skip until last commit, this only runs when starting back a watcher
                if ! ((is_commit_id_last_reached)) && ((is_session_saved)) ; then
                    if [[ -n "$commit_id" ]] && [[ "$line" = "commit "$commit_id ]] ; then
                        is_commit_id_last_reached=1
                    else
                        # loop until we reach the desired commit
                        el_debug "skipping commit because is not $commit_id : $line"
                        continue
                    fi
                else
                    # we are in a new session, simulate that we have reached the last needed position
                    is_commit_id_last_reached=1
                fi


                # get the commit id of this loop
                commit_id="${line#commit }"

                if ((is_travel_wanted)) && [[ -n "$travel_commit_id" ]] ; then
                    go_to_commit "$travel_commit_id"
                fi

                # show actual commit
                show_commit_stat --no-pager

                # store actual position for future calls of this tool
                echo "$commit_id" > "$conf_commit_last_f"
                el_debug "stored '$commit_id' to '$conf_commit_last_f'"

                echo -e "$counter $counter_total" > "$conf_commit_last_progress_f"
                el_debug "stored counter at '$counter' with '$counter_total' total in '$conf_commit_last_progress_f'"


                #
                # show main options
                options_main_interact

                if ((is_recount_position_needed)) ; then
                    break 1
                fi

                el_debug "going to next loop"
                #
                #

                # exit loop if no remaining commits
                if [[ "$counter" -ge "$counter_total" ]] || [[ "$counter" -le "0" ]] || [[ "$counter_total" -le "0" ]] ; then
                    is_recount_position_needed=1
                    break 1
                fi

                # count another commit because we go to next loop
                counter="$(( $counter + 1 ))"


                # clear screen, but after that we did everything before to start
                clear_screen default

            fi

        done 3<<< "$( command git log ${options_extra_git_before[@]} --reverse "$branch_working".."$branch_watch" $options_extra_git_after )"
        # if you search with -k without matches, infinite loop happens, avoid it with this check
        if [[ "$counter" -ge "$counter_total" ]] || [[ "$counter" -le "0" ]] || [[ "$counter_total" -le "0" ]] ; then
            is_recount_position_needed=1
            break
        fi

        if ((is_recount_position_needed)) ; then
            counter=1
            unset is_commit_id_last_reached
            clear_screen default
            #el_explain 0 "recounting..."
        fi
    done


    if ((is_commit_id_last_reached)) ; then
        el_explain 0 "__No more commits found__, ow yeah baby!"
    else
        if ((is_header_show)) ; then
            el_error "Something wrong happened? seems like we cannot found your last position, so where is this commit then? $commit_id"
        else
            # instead of just exit, give at least the options (if you need to update for example)
            unset is_recount_position_needed
            options_main_interact

            el_explain 0 "XXNo commitsXX found"
        fi
    fi

}

#
#  MAIN
#
main "$@"


# vim: set foldmethod=marker :

