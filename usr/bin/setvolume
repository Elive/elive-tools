#!/bin/bash
source /usr/lib/elive-tools/functions

#===  FUNCTION  ================================================================
#          NAME:  get_meter
#   DESCRIPTION:  prints the meter that we should use for modify volumes
#    PARAMETERS:  -
#       RETURNS:  meter name in a string value
#===============================================================================
get_meter(){
    # pre {{{
    local meter
    el_debug
    el_security_function_loop || return

    el_check_variables "list"


    # }}}

    if [[ -z $meter ]] ; then
        if echo "$list" | grep -q "'PCM'" ; then
            meter=PCM
        fi
    fi

    ##################
    if [[ -z $meter ]] ; then
        if echo "$list" | grep -q "'Front'" ; then
            meter=Front
        fi
    fi

    ##################
    if [[ -z $meter ]] ; then
        if echo "$list" | grep -q "'Wave'" ; then
            meter=Wave
        fi
    fi

    ##################
    if [[ -z $meter ]] ; then
        if echo "$list" | grep -q "'Center'" ; then
            meter=Center
        fi
    fi

    # this doesn't exist on this time but may make things working in the future
    if [[ -z $meter ]] ; then
        if echo "$list" | grep -q "'PulseAudio'" ; then
            meter=PulseAudio
        fi
    fi
    ##################
    # Master should be everytime on Max volume or you got distortions
    if [[ -z $meter ]] ; then
        if echo "$list" | grep -q "'Master'" ; then
            meter=Master
        fi
    fi

    ##################
    # Special Cards, like ice1712/Terratec_ewx24/96
    if [[ -z $meter ]] ; then
        if echo "$list" | grep -q "'DAC'" ; then
            meter=DAC
        fi
    fi

    # so wtf
    if [[ -z $meter ]] ; then
        el_error "No meter found, is your audio card working?"
    fi

    # DONE, show it
    echo "$meter"
}

#===  FUNCTION  ================================================================
#          NAME:  get_volume
#   DESCRIPTION:  get the actual volume status
#    PARAMETERS:  -
#       RETURNS:  volume percentage in a simple integer value
#===============================================================================
get_volume(){
    # pre {{{
    local volume meter
    el_debug
    el_security_function_loop || return

    meter="$( get_meter )"
    el_check_variables "meter,list"

    # }}}

    # show and return a value
    if echo "$list" | grep -q "'$meter',1" ; then
        # stereo
        LC_ALL=C amixer sget "${meter},0" 2>/dev/null | grep -E "(Playback:|Right:|Mono:)" | psort -- -p "Playback:" -p "Right:" -p "Mono:" | tr ' ' '\n' | grep "%" | sed -e 's|\[||g' -e 's|\]||g' -e 's|%||g' | grep -E "[[:digit:]]*" | tail -1
    else
        # mono
        LC_ALL=C amixer get "${meter}" 2>/dev/null | grep -E "(Playback:|Right:|Mono:)" | psort -- -p "Playback:" -p "Right:" -p "Mono:" | tr ' ' '\n' | grep "%" | sed -e 's|\[||g' -e 's|\]||g' -e 's|%||g' | grep -E "[[:digit:]]*" | tail -1
    fi

}
#===  FUNCTION  ================================================================
#          NAME:  mute_modes_force
#   DESCRIPTION:  force (hack) a mute mode for un unsupported card
#    PARAMETERS:  $1 = mode: mute|unmute  (no toggle modes)
#       RETURNS:  -
#===============================================================================
mute_modes_force(){
    # pre {{{
    local mode conf volume_before volume_actual
    el_debug
    el_security_function_loop 8 || return

    mode="$1"
    conf="$HOME/.config/setvolume"
    el_check_variables "mode"


    # }}}

    # get volume from conf
    if [[ -e "$conf" ]] && [[ -s "$conf" ]] ; then
        volume_before="$( grep "^volume:" "$conf" )"
        volume_before="${volume_before#volume:}"
        # remove extra leading blank chars
        read -r volume_before <<< "$volume_before"
    else
        # no conf? get it now
        volume_before="$( get_volume )"
    fi

    # get actual volume
    volume_actual="$( get_volume )"
    if [[ -z "$volume_actual" ]] ; then
        el_error "unable to get actual volume"
        exit
    fi

    # set mute modes
    case "$mode" in
        muteset)
            # save our last state of volume for next use
            sed -i '/^volume:/d' "$conf" 2>/dev/null
            echo -e "volume: $volume_actual" >> "$conf"

            # set volume to 0
            "$0" "0%"

            ;;
        unmute|unmuteset)

            # set volume to our previous state
            "$0" "${volume_before}%"

            ;;
        mute|toggle)
            el_explain 0 "volumes was originally at $volume_before and now $volume_actual"
            if [[ "$volume_actual" -lt 2 ]] ; then
                $FUNCNAME unmute
            else
                $FUNCNAME muteset
            fi

            ;;
        *)
            el_error "Unkown $mode option for $FUNCNAME"
            ;;
    esac


}
#===  FUNCTION  ================================================================
#          NAME:  mute_modes
#   DESCRIPTION:  set mute or unmute the audio card
#    PARAMETERS:  $1 = mode: mute (toggle), muteset, unmute|unmuteset
#       RETURNS:  -
#===============================================================================
mute_modes(){
    # pre {{{
    local state_before state_after mode
    el_debug
    el_security_function_loop 8 || return

    mode="$1"
    el_check_variables "mode"

    # }}}
    state_before="$( LC_ALL=C amixer get "$meter" | grep Right | tail -1 | tr ' ' '\n' | grep -E "(on|off)" | grep "\[" | sed 's/\[//g' | sed 's/\]//g' )"
    # remove extra leading blank chars
    read -r state_before <<< "$state_before"

    case "$mode" in
        unmute|unmuteset)
            # set talk
            if [[ -n "$state_before" ]] ; then
                if amixer -q set "$meter" unmute 2>/dev/null ; then
                    el_explain 2 "mute was on"
                else
                    # failed to set, force
                    mute_modes_force unmute
                    return
                fi
            else
                # we dont know about mute values for this channel/card, force
                mute_modes_force unmute
                return
            fi
            # force detect {{{
            state_after="$( LC_ALL=C amixer get "$meter" | grep Right | tail -1 | tr ' ' '\n' | grep -E "(on|off)" | grep "\[" | sed 's/\[//g' | sed 's/\]//g' )"
            # remove extra leading blank chars
            read -r state_after <<< "$state_after"

            # unsuccessful mute, force
            if [[ "$state_after" = "off" ]] ; then
                el_explain 2 "mute has not changed, forcing it"
                mute_modes_force unmute
                return
            fi

            # - force detect }}}

            ;;
        muteset)
            # set silent
            if [[ -n "$state_before" ]] ; then
                if amixer -q set "$meter" mute 2>/dev/null ; then
                    el_explain 2 "mute was off"
                else
                    # failed to set, force
                    mute_modes_force mute
                    return
                fi
            else
                # we dont know about mute values for this channel/card, force
                mute_modes_force mute
                return
            fi
            # force detect {{{
            state_after="$( LC_ALL=C amixer get "$meter" | grep Right | tail -1 | tr ' ' '\n' | grep -E "(on|off)" | grep "\[" | sed 's/\[//g' | sed 's/\]//g' )"
            # remove extra leading blank chars
            read -r state_after <<< "$state_after"

            # unsuccessful mute, force
            if [[ "$state_after" = "on" ]] ; then
                el_explain 2 "mute has not changed, forcing it"
                mute_modes_force mute
                return
            fi

            # - force detect }}}

            ;;
        mute)
            # Toggle mute modes
            if [[ -n "$state_before" ]] ; then

                if [[ "$state_before" = "off" ]] ; then
                    if amixer -q set "$meter" unmute 2>/dev/null ; then
                        el_explain 2 "mute was on"
                    else
                        # failed to set, force
                        mute_modes_force unmute
                        return
                    fi
                fi

                if [[ "$state_before" = "on" ]] ; then
                    if amixer -q set "$meter" mute 2>/dev/null ; then
                        el_explain 2 "mute was off"
                    else
                        # failed to set, force
                        mute_modes_force mute
                        return
                    fi
                fi
            else
                # we dont know about mute values for this channel/card, force
                mute_modes_force toggle
                return
            fi
            # force detect {{{
            state_after="$( LC_ALL=C amixer get "$meter" | grep Right | tail -1 | tr ' ' '\n' | grep -E "(on|off)" | grep "\[" | sed 's/\[//g' | sed 's/\]//g' )"
            # remove extra leading blank chars
            read -r state_after <<< "$state_after"

            # unsuccessful mute, force
            if [[ "$state_before" = "$state_after" ]] ; then
                el_explain 2 "mute has not changed, forcing it"
                mute_modes_force toggle
                return
            fi

            # - force detect }}}

            ;;
        *)
            el_error "Unkown $mode option for $FUNCNAME"
            ;;
    esac

}
main(){
    # pre {{{
    local list action meter actualvalue

    el_dependencies_check amixer

    # }}}

    # Usage
    if [[ -z "${1}" ]] ; then
        echo -e "Usage: $(basename $BASH_SOURCE) args"
        echo -e "\nExamples:"
        echo -e "$(basename $0) defaults  # set volumes generically to optimal ones"
        echo -e "$(basename $0) 80%  # set the volume to the 80 % level"
        echo -e "$(basename $0) 10%+ # increases 10% the actual volume"
        echo -e "$(basename $0) mute    # switch on/off mute mode"
        echo -e "$(basename $0) muteset # set ON mute mode"
        echo -e "$(basename $0) unmute  # set OFF mute mode"

        echo -e "\n$(basename $0) uses special powers making any card to work with all the features even the mute one, if doesn't, report the bug to us"
        exit 1
    fi


    list="$( amixer scontrols )"
    action="$@"

    if [[ "${1}" = "defaults" ]] ; then
        # extra volumes up
        amixer -q set Headphone 100% 2>/dev/null
        amixer -q set Speaker 100% 2>/dev/null
        # unmute channels
        amixer -q set Master unmute 2>/dev/null
        amixer -q set PCM    unmute 2>/dev/null
        amixer -q set Front  unmute 2>/dev/null
        amixer -q set Wave   unmute 2>/dev/null
        amixer -q set DAC    unmute 2>/dev/null

        # Master should be always set to 100 % in order to avoid distortions
        el_explain 2 "Master set to 100%"
        amixer -q set Master,0 100  2>/dev/null
        amixer -q set Master,1 100  2>/dev/null

        # Mic configurations
        amixer -q set Capture unmute 2>/dev/null
        amixer -q set Capture 90% 2>/dev/null
        amixer -q set Mic unmute 2>/dev/null
        amixer -q set Mic 70% 2>/dev/null
        # capture mode
        amixer -q sset Mic cap 2>/dev/null
        amixer -q sset Capture cap 2>/dev/null
        # mute playback of mic, very annoying
        amixer -q sset Mic Playback mute 2>/dev/null

        # Fix for skype when we dont have a "Mic" control
        if ! LC_ALL=C amixer scontrols | sed -e 's|^.mixer control||g' | grep -vi boost | grep -q "Mic" ; then
            if [[ -d "$HOME/.Skype" ]] && grep -q "<AGC>.</AGC>" "$HOME/.Skype/shared.xml" ; then
                killall skype 2>/dev/null || killall -9 skype 2>/dev/null
                sync
                sed -i "s|<AGC>.</AGC>|<AGC>0</AGC>|g" "$HOME/.Skype/shared.xml"

                el_explain 0 "added a fix for your skype: to not modify your volumes, your audio-card model needs this"
            else
                el_warning "If you use Skype you need to configure in the audio preferences to NOT modify your audio values"
            fi
        else

            if [[ -d "$HOME/.Skype" ]] && grep -q "<AGC>.</AGC>" "$HOME/.Skype/shared.xml" ; then
                killall skype 2>/dev/null || killall -9 skype 2>/dev/null
                sync
                sed -i "s|<AGC>.</AGC>|<AGC>1</AGC>|g" "$HOME/.Skype/shared.xml"

                el_explain 0 "added a fix for your skype: to allow it modify your volumes, because your audio-card model needs this"
            else
                el_warning "If you use Skype you need to configure in the audio preferences to NOT modify your audio values"
            fi
        fi

        # then set a default generic volume
        main 80% 1>/dev/null
        exit
    fi


    # fixes percent space
    action="${action/ %/%}"

    action="${action/ up/+}"
    action="${action/ down/-}" # FIXME: e17 mouse bindings does a segfault when the action is to enter a command like "setvolumes 2%+" ? if yes, report it to E17

    ##################
    # First = see if first option is available, if not, try with the next one
    meter="$( get_meter )"
    ##################

    el_explain 2 "selected meter: $meter"

    # MUTE modes
    # silent
    if [[ "$action" = "muteset" ]] ; then
        mute_modes "muteset"
        exit
    fi
    # speak
    if [[ "$action" = "unmute" ]] ; then
        mute_modes "unmute"
        exit
    fi
    # toggle
    if [[ "$action" = "mute" ]] ; then
        mute_modes "mute"
        exit
    fi

    ##################

    # normal actions, like setting the volume
    if echo "$list" | grep -q "'$meter',1" ; then
        # stereo
        amixer -q set ${meter},0 $action 2>/dev/null
        amixer -q set ${meter},1 $action 2>/dev/null
    else
        # mono
        amixer -q set $meter $action 2>/dev/null
    fi
    ##################

    # this is old and deprecated
}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
