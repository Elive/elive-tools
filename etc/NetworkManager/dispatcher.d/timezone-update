#!/bin/bash
source /usr/lib/elive-tools/functions

# This tool is called as:   command eth1 up

main(){
    # pre {{{
    local iface state conf timezone_last timezone connected_gateway connected_mac

    iface="$1"
    state="$2"
    conf="/etc/elive-tools/geolocation/timezones.conf"

    el_dependencies_check "ip,arp,showmytimezone,dig,ping"
    #el_check_variables "iface,state"

    if [[ ! -e "$conf" ]] ; then
	if [[ "${conf}" = */* ]] ; then
	    mkdir -p "${conf%/*}"
	fi
        touch "$conf"
    fi

    case "$iface" in
	-f|--force)
	    is_force=1
	    unset iface
	    ;;
	-c|--clean)
	    mode_clean=1
	    unset iface
	    ;;
	wlan*|ath*|ra*)
	    is_wifi=1
	    ;;
    esac


    case "$state" in
	down)
	    # nothing useful to do when we disconnect
	    exit
	    ;;
	up|*)
	    true
	    ;;
    esac


    if ((mode_clean)) ; then
	rm -f "${conf}"
	el_explain 0 "Conf file cleaned"
	exit
    fi


    # }}}

    # let's connect to internet first, and do at least one ping somewhere! or arp -a will not work
    el_verify_internet delayed 2>/dev/null 1>/dev/null
    timeout 20 ping -c 1 google.com 1>/dev/null 2>/dev/null
    timeout 20 dig NS google.com 1>/dev/null 2>/dev/null
    sleep 1

    # get our connected MAC
    connected_gateway="$(ip route | grep default | awk '{ print $3 }' | tail -1 )"
    connected_mac="$(arp -a | grep "(${connected_gateway}) at" | sed -e "s|^.*${connected_gateway} at||g" | tr ' ' '\n' | grep -E ":.*:.*:.*:" | tail -1 )"

    # make sure that we have a mac
    if [[ -z "$connected_mac" ]] ; then
	el_error "MAC '${connected_mac}' of where we are connected not found"
	exit
    fi

    # get the last location
    timezone_last="$( awk -v FS=":::" '{if ($1 == "last") print $2}' "${conf}" | tail -1 )"


    # get the location of our actual connection
    connected_timezone="$( grep "^${connected_mac}:::" "${conf}" | awk -v FS=":::" '{print $2}' | tail -1 )"

    # get the ssid identifier
    connected_ssid="$( iwconfig 2>&1 | grep "^${iface}[[:blank:]]*" | tr ' ' '\n' | grep ESSID | sed -e 's|ESSID:"||g' -e 's|".*$||g' | head -1 )"

    # get the actual timezone
    if [[ -n "$connected_timezone" ]] ; then
	timezone="${connected_timezone}"
    else
	timezone="$(showmytimezone)"
	if [[ "${timezone}" = "Etc/UTC" ]] ; then
	    if [[ -n "${timezone_last}" ]] ; then
		el_warning "we have not detected the timezone correctly, switching to last"
		timezone="${timezone_last}"
	    else
		el_error "timezone not detected correctly"
		exit
	    fi
	fi
    fi

    # check
    if [[ -z "$timezone" ]] ; then
        el_error "We have not found a timezone '${timezone}', exiting..."
	exit
    fi

    # first time, need to determine if use utc or not
    if [[ -z "$timezone_last" ]] ; then
	el_explain 0 "first time, determine if we use UTC or localtime"


	if LC_ALL=C hwclock -r -D | grep -q "^Assuming hardware clock is kept in UTC" ; then
	    mode_bios="UTC"
	else
	    mode_bios="LOCAL"
	fi






	## temporal set to utc
	#_AREA="Etc"
	#_ZONE="UTC"

	#rm -f /etc/localtime
	#ln -s "/usr/share/zoneinfo/${_AREA}/${_ZONE}" /etc/localtime
	#echo "$_AREA/$_ZONE" > /etc/timezone

	## call tzdata and update things
	## debconf set configurations
	#cat > "/tmp/debconf.$(basename $0)" << EOF
#tzdata tzdata/Areas select ${_AREA}
#tzdata tzdata/Zones/${_AREA} select ${_ZONE}
#EOF
	#debconf-set-selections < "/tmp/debconf.$(basename $0)"
	#rm -f "/tmp/debconf.$(basename $0)"

	#if ! ntpdate pool.ntp.org 2>/dev/null 1>/dev/null ; then
	    #if ! ntpdate europe.pool.ntp.org 2>/dev/null 1>/dev/null ; then
			    #el_warning "can't set time from ntp servers"
	    #fi
	#fi

	## know the real time for UTC
	#TZBase=$(LC_ALL=C TZ=UTC0 date)
	#UTdate=$(LC_ALL=C TZ=UTC0 date -d "$TZBase" +%H )

	## unpredictable bugs can happen all the time, seems like is not a good time to get the hour value
	#if [[ "$(date +%M)" = "59" ]] ; then
	    #el_explain 0 "waiting 1 minute"
	    #sleep 70
	    #TZBase=$(LC_ALL=C TZ=UTC0 date)
	    #UTdate=$(LC_ALL=C TZ=UTC0 date -d "$TZBase" +%H )
	#fi

	## save the real utc time to use later
	#UTC_time="$UTdate"
	#el_explain 0 "real UTC time is __${UTC_time}__"


	## try in localtime mode
	#hwclock -s --localtime

	#TZBase=$(LC_ALL=C TZ=UTC0 date)
	#UTdate=$(LC_ALL=C TZ=UTC0 date -d "$TZBase" +%H )

	## save it to compare later
	#UTC_bios_1="$UTdate"



	## Now try to change to a different GMT
	#_AREA="Etc"
	#_ZONE="GMT+6"

	#rm -f /etc/localtime
	#ln -s "/usr/share/zoneinfo/${_AREA}/${_ZONE}" /etc/localtime
	#echo "$_AREA/$_ZONE" > /etc/timezone

	## call tzdata and update things
	## debconf set configurations
	#cat > "/tmp/debconf.$(basename $0)" << EOF
#tzdata tzdata/Areas select ${_AREA}
#tzdata tzdata/Zones/${_AREA} select ${_ZONE}
#EOF
	#debconf-set-selections < "/tmp/debconf.$(basename $0)"
	#rm -f "/tmp/debconf.$(basename $0)"

	#if ! ntpdate pool.ntp.org 2>/dev/null 1>/dev/null ; then
	    #if ! ntpdate europe.pool.ntp.org 2>/dev/null 1>/dev/null ; then
		#el_warning "can't set time from ntp servers"
    #fi
	#fi

	## know the real time for UTC
	#TZBase=$(LC_ALL=C TZ=UTC0 date)
	#UTdate=$(LC_ALL=C TZ=UTC0 date -d "$TZBase" +%H )


	## try in localtime mode
	#hwclock -s --localtime

	#TZBase=$(LC_ALL=C TZ=UTC0 date)
	#UTdate=$(LC_ALL=C TZ=UTC0 date -d "$TZBase" +%H )

	#UTC_bios_2="$UTdate"



	#if [[ "${UTC_bios_1}" = "$UTC_bios_2" ]] ; then
	    #el_explain 2 "bios clock uses localtime (doesn't change)"
	    #mode_bios="LOCAL"
	#else
	    #el_explain 2 "bios clock uses utc (changes)"
	    #mode_bios="UTC"
	#fi

	# save the mode to use
	if [[ -n "$mode_bios" ]] ; then
	    echo "bios mode:::$mode_bios" >> "${conf}"

	    ed -s /etc/adjtime << EOF
3d
a
$mode_bios
.
w
EOF

	    # update things
	    dpkg-reconfigure -fnoninteractive util-linux 2>/dev/null 1>/dev/null
	fi

    fi


    # compare our last location with our actual one
    if [[ "${timezone}" = "${timezone_last}" ]] ; then
	if ! ((is_force)) ; then
	    # nothing more to do, everything is fine
	    exit
	fi
    fi

    #
    # We changed our location
    #

    # update times
    if [[ -z "$timezone_last" ]] ; then
	echo "last:::${timezone}" >> "${conf}"
    fi

    if [ -n "${timezone}" ]
    then
	_AREA="$(echo "${timezone}" | cut -f1 -d '/')"
	_ZONE="$(echo "${timezone}" | cut -f2 -d '/')"
    else
	_AREA="Etc"
	_ZONE="UTC"
    fi


    rm -f /etc/localtime
    ln -s "/usr/share/zoneinfo/${_AREA}/${_ZONE}" /etc/localtime
    echo "$_AREA/$_ZONE" > /etc/timezone

    # call tzdata and update things
    # debconf set configurations
    cat > "/tmp/debconf.$(basename $0)" << EOF
tzdata tzdata/Areas select ${_AREA}
tzdata tzdata/Zones/${_AREA} select ${_ZONE}
EOF
    debconf-set-selections < "/tmp/debconf.$(basename $0)"
    rm -f "/tmp/debconf.$(basename $0)"

    if ! ntpdate pool.ntp.org 2>/dev/null 1>/dev/null ; then
	if ! ntpdate europe.pool.ntp.org 2>/dev/null 1>/dev/null ; then
	    if ! ntpdate north-america.pool.ntp.org 2>/dev/null 1>/dev/null ; then
		if ! ntpdate 1.pool.ntp.org 2>/dev/null 1>/dev/null ; then
		    if ! ntpdate 0.pool.ntp.org 2>/dev/null 1>/dev/null ; then
			el_warning "can't set time from ntp servers"
		    fi
		fi
	    fi
	fi
    fi




    # which mode of bios we have? utc or localtime?
    mode_bios="$(head -3 /etc/adjtime  | tail -1)"

    # finally, save the time to hwclock if needed
    case $mode_bios in
	UTC)
	    hwclock -w --utc
	    ;;
	LOCAL)
	    hwclock -w --localtime
	    ;;
	*)
	    el_explain 2 "not saving time with hwclock since we don't know which mode to use"
	    ;;
    esac


    # say something
    el_explain 0 "Changed Timezone to __${timezone}__, we are now at:"
    date


    # update to our last location
    if ! grep -q "^${connected_mac}:::" "${conf}" ; then
	# but remember it only if we have an interface
	# TODO mobile connections should be never saved, since they moves!
	if [[ -n "$iface" ]] ; then
	    if [[ -n "$connected_ssid" ]] ; then
		echo "${connected_mac}:::${timezone}:::${iface}:::${connected_ssid}" >> "${conf}"
	    else
		echo "${connected_mac}:::${timezone}:::${iface}" >> "${conf}"
	    fi
	fi
    fi

    sed -i '/^last:::.*$/d' "${conf}"
    echo "last:::${timezone}" >> "${conf}"

}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :

